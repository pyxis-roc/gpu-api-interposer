#!/usr/bin/env python3

import argparse
import yaml
import os
from pycparser import c_ast, c_generator
from geninterposer import FuncDeclVisitor, get_ast, preprocess
import sys

def load_yaml(f):
    with open(f, "r") as yf:
        return yaml.safe_load(yf)

def get_func_decls(hfile, cpp_args_file = None, fake_c_headers = None, addl_headers_path = None):
    fn = preprocess(hfile, cpp_args_file, fake_c_headers, addl_headers_path)
    ast = get_ast(fn)

    fdv = FuncDeclVisitor()
    fdv.visit(ast)
    os.unlink(fn)

    return fdv.func_decl_nodes

def get_instr_func_decls(decls, instr_hfiles):
    instr_hfiles = set(instr_hfiles)
    # ignore decls not in instrumentation header files
    out = [fn for fn in decls if fn['decl'].coord.file in instr_hfiles]
    return out

def generate_shells(fdvs, probes):
    # only generate recorder for functions that have probes

    def get_instr_code(f, ev):
        code = []

        args = [c_ast.ID(a) for a in ev['args']]
        
        code.append(c_ast.FuncCall(c_ast.ID("tracepoint"), c_ast.ExprList(args)))
        
        if f['origname'][-4:] == "_pre":
            code.append(c_ast.Return(c_ast.Constant("int", "0")))

        return code
    
    fnd = dict([(fn['origname'], fn) for fn in fdvs])
    events = probes['events']
    for ev in events:
        f = fnd[ev]
        #print(f['decl'], events[ev])
        f['shell'] = c_ast.FuncDef(f['decl'], None, 
                                   c_ast.Compound(get_instr_code(f, events[ev])))

def generate_output(fdvs, probes, outputfile, instr_headers):
    with open(outputfile, "w") as ofile:
        # write headers

        for ih in instr_headers:
            ofile.write(f'#include "{ih}"\n')

        tpheader = probes['output']
        try:
            p = tpheader.rindex(".")
            tpheader = tpheader[:p] + ".h"
        except ValueError:
            tpheader = tpheader + ".h"

        ofile.write(f'#include "{tpheader}"\n')
        cgen = c_generator.CGenerator()
        
        for f in fdvs:
            if 'shell' not in f:
                # error?
                print(f"WARNING: '{f['origname']}' does not have tracepoints defined.",file=sys.stderr)
            else:
                ofile.write(cgen.visit(f['shell']))
        
if __name__ == "__main__":
    p = argparse.ArgumentParser(description="Generate a API recorder given filter file and a probe file")

    p.add_argument("--fake-c-headers", help="Path to pycparser's fake C headers")
    p.add_argument("--cppargsfile", help="File that contains C preprocessor arguments, one per line")
    p.add_argument("-I", dest="include_dirs", action="append", help="Include directories for CPP")    
    p.add_argument("-o", dest="output", help="Output C file")
    p.add_argument("probeyaml", help="Probe file generated by gentracepoints.py")
    p.add_argument("instr_headers", nargs="+", help="Instrumentation headers generated by --pre and/or --post")
    
    args = p.parse_args()

    tpinfo = load_yaml(args.probeyaml)

    fdvs = []
    for hfile in args.instr_headers:
        fdecls = get_func_decls(hfile, args.cppargsfile,
                                args.fake_c_headers, args.include_dirs)
        fdvs.extend(get_instr_func_decls(fdecls, args.instr_headers))

    generate_shells(fdvs, tpinfo)

    if not args.output:
        args.output = "/dev/stdout"
    
    generate_output(fdvs, tpinfo, args.output, args.instr_headers)
