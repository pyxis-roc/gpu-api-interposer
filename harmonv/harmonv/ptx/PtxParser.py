# Generated from Ptx.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u0125")
        buf.write("\u0b6e\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4")
        buf.write("_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4e\te\4f\tf\4g\tg\4")
        buf.write("h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to\4p\tp\4")
        buf.write("q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4")
        buf.write("z\tz\4{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080")
        buf.write("\4\u0081\t\u0081\4\u0082\t\u0082\4\u0083\t\u0083\4\u0084")
        buf.write("\t\u0084\4\u0085\t\u0085\4\u0086\t\u0086\4\u0087\t\u0087")
        buf.write("\4\u0088\t\u0088\4\u0089\t\u0089\4\u008a\t\u008a\4\u008b")
        buf.write("\t\u008b\4\u008c\t\u008c\4\u008d\t\u008d\4\u008e\t\u008e")
        buf.write("\4\u008f\t\u008f\4\u0090\t\u0090\4\u0091\t\u0091\4\u0092")
        buf.write("\t\u0092\4\u0093\t\u0093\4\u0094\t\u0094\4\u0095\t\u0095")
        buf.write("\4\u0096\t\u0096\4\u0097\t\u0097\4\u0098\t\u0098\4\u0099")
        buf.write("\t\u0099\4\u009a\t\u009a\4\u009b\t\u009b\4\u009c\t\u009c")
        buf.write("\4\u009d\t\u009d\4\u009e\t\u009e\4\u009f\t\u009f\4\u00a0")
        buf.write("\t\u00a0\4\u00a1\t\u00a1\4\u00a2\t\u00a2\4\u00a3\t\u00a3")
        buf.write("\4\u00a4\t\u00a4\4\u00a5\t\u00a5\4\u00a6\t\u00a6\4\u00a7")
        buf.write("\t\u00a7\4\u00a8\t\u00a8\4\u00a9\t\u00a9\4\u00aa\t\u00aa")
        buf.write("\4\u00ab\t\u00ab\4\u00ac\t\u00ac\4\u00ad\t\u00ad\4\u00ae")
        buf.write("\t\u00ae\4\u00af\t\u00af\4\u00b0\t\u00b0\4\u00b1\t\u00b1")
        buf.write("\4\u00b2\t\u00b2\4\u00b3\t\u00b3\4\u00b4\t\u00b4\4\u00b5")
        buf.write("\t\u00b5\4\u00b6\t\u00b6\4\u00b7\t\u00b7\4\u00b8\t\u00b8")
        buf.write("\4\u00b9\t\u00b9\4\u00ba\t\u00ba\4\u00bb\t\u00bb\4\u00bc")
        buf.write("\t\u00bc\4\u00bd\t\u00bd\4\u00be\t\u00be\4\u00bf\t\u00bf")
        buf.write("\4\u00c0\t\u00c0\4\u00c1\t\u00c1\4\u00c2\t\u00c2\4\u00c3")
        buf.write("\t\u00c3\4\u00c4\t\u00c4\4\u00c5\t\u00c5\4\u00c6\t\u00c6")
        buf.write("\4\u00c7\t\u00c7\4\u00c8\t\u00c8\4\u00c9\t\u00c9\4\u00ca")
        buf.write("\t\u00ca\4\u00cb\t\u00cb\4\u00cc\t\u00cc\4\u00cd\t\u00cd")
        buf.write("\4\u00ce\t\u00ce\4\u00cf\t\u00cf\4\u00d0\t\u00d0\4\u00d1")
        buf.write("\t\u00d1\4\u00d2\t\u00d2\4\u00d3\t\u00d3\4\u00d4\t\u00d4")
        buf.write("\4\u00d5\t\u00d5\4\u00d6\t\u00d6\4\u00d7\t\u00d7\4\u00d8")
        buf.write("\t\u00d8\4\u00d9\t\u00d9\4\u00da\t\u00da\4\u00db\t\u00db")
        buf.write("\4\u00dc\t\u00dc\4\u00dd\t\u00dd\4\u00de\t\u00de\4\u00df")
        buf.write("\t\u00df\4\u00e0\t\u00e0\4\u00e1\t\u00e1\4\u00e2\t\u00e2")
        buf.write("\4\u00e3\t\u00e3\4\u00e4\t\u00e4\4\u00e5\t\u00e5\4\u00e6")
        buf.write("\t\u00e6\4\u00e7\t\u00e7\4\u00e8\t\u00e8\4\u00e9\t\u00e9")
        buf.write("\4\u00ea\t\u00ea\4\u00eb\t\u00eb\4\u00ec\t\u00ec\4\u00ed")
        buf.write("\t\u00ed\4\u00ee\t\u00ee\4\u00ef\t\u00ef\4\u00f0\t\u00f0")
        buf.write("\4\u00f1\t\u00f1\4\u00f2\t\u00f2\4\u00f3\t\u00f3\4\u00f4")
        buf.write("\t\u00f4\4\u00f5\t\u00f5\4\u00f6\t\u00f6\4\u00f7\t\u00f7")
        buf.write("\4\u00f8\t\u00f8\4\u00f9\t\u00f9\4\u00fa\t\u00fa\4\u00fb")
        buf.write("\t\u00fb\4\u00fc\t\u00fc\4\u00fd\t\u00fd\4\u00fe\t\u00fe")
        buf.write("\4\u00ff\t\u00ff\4\u0100\t\u0100\4\u0101\t\u0101\4\u0102")
        buf.write("\t\u0102\4\u0103\t\u0103\4\u0104\t\u0104\4\u0105\t\u0105")
        buf.write("\4\u0106\t\u0106\4\u0107\t\u0107\4\u0108\t\u0108\4\u0109")
        buf.write("\t\u0109\4\u010a\t\u010a\4\u010b\t\u010b\4\u010c\t\u010c")
        buf.write("\4\u010d\t\u010d\4\u010e\t\u010e\4\u010f\t\u010f\4\u0110")
        buf.write("\t\u0110\4\u0111\t\u0111\4\u0112\t\u0112\4\u0113\t\u0113")
        buf.write("\4\u0114\t\u0114\4\u0115\t\u0115\4\u0116\t\u0116\4\u0117")
        buf.write("\t\u0117\4\u0118\t\u0118\4\u0119\t\u0119\4\u011a\t\u011a")
        buf.write("\4\u011b\t\u011b\4\u011c\t\u011c\4\u011d\t\u011d\4\u011e")
        buf.write("\t\u011e\4\u011f\t\u011f\4\u0120\t\u0120\4\u0121\t\u0121")
        buf.write("\4\u0122\t\u0122\4\u0123\t\u0123\4\u0124\t\u0124\4\u0125")
        buf.write("\t\u0125\4\u0126\t\u0126\4\u0127\t\u0127\4\u0128\t\u0128")
        buf.write("\4\u0129\t\u0129\4\u012a\t\u012a\4\u012b\t\u012b\4\u012c")
        buf.write("\t\u012c\4\u012d\t\u012d\4\u012e\t\u012e\4\u012f\t\u012f")
        buf.write("\4\u0130\t\u0130\4\u0131\t\u0131\4\u0132\t\u0132\4\u0133")
        buf.write("\t\u0133\4\u0134\t\u0134\4\u0135\t\u0135\4\u0136\t\u0136")
        buf.write("\4\u0137\t\u0137\4\u0138\t\u0138\4\u0139\t\u0139\4\u013a")
        buf.write("\t\u013a\4\u013b\t\u013b\4\u013c\t\u013c\4\u013d\t\u013d")
        buf.write("\4\u013e\t\u013e\4\u013f\t\u013f\4\u0140\t\u0140\4\u0141")
        buf.write("\t\u0141\4\u0142\t\u0142\4\u0143\t\u0143\4\u0144\t\u0144")
        buf.write("\4\u0145\t\u0145\4\u0146\t\u0146\4\u0147\t\u0147\4\u0148")
        buf.write("\t\u0148\4\u0149\t\u0149\4\u014a\t\u014a\4\u014b\t\u014b")
        buf.write("\4\u014c\t\u014c\4\u014d\t\u014d\4\u014e\t\u014e\4\u014f")
        buf.write("\t\u014f\4\u0150\t\u0150\4\u0151\t\u0151\4\u0152\t\u0152")
        buf.write("\4\u0153\t\u0153\4\u0154\t\u0154\4\u0155\t\u0155\4\u0156")
        buf.write("\t\u0156\4\u0157\t\u0157\4\u0158\t\u0158\4\u0159\t\u0159")
        buf.write("\4\u015a\t\u015a\4\u015b\t\u015b\4\u015c\t\u015c\4\u015d")
        buf.write("\t\u015d\4\u015e\t\u015e\4\u015f\t\u015f\4\u0160\t\u0160")
        buf.write("\4\u0161\t\u0161\4\u0162\t\u0162\4\u0163\t\u0163\4\u0164")
        buf.write("\t\u0164\4\u0165\t\u0165\4\u0166\t\u0166\4\u0167\t\u0167")
        buf.write("\4\u0168\t\u0168\4\u0169\t\u0169\4\u016a\t\u016a\4\u016b")
        buf.write("\t\u016b\4\u016c\t\u016c\4\u016d\t\u016d\4\u016e\t\u016e")
        buf.write("\4\u016f\t\u016f\4\u0170\t\u0170\4\u0171\t\u0171\4\u0172")
        buf.write("\t\u0172\4\u0173\t\u0173\4\u0174\t\u0174\4\u0175\t\u0175")
        buf.write("\4\u0176\t\u0176\3\2\3\2\3\2\5\2\u02f0\n\2\3\2\6\2\u02f3")
        buf.write("\n\2\r\2\16\2\u02f4\3\2\3\2\3\3\3\3\3\3\3\4\3\4\3\4\3")
        buf.write("\5\3\5\3\5\3\6\3\6\3\6\7\6\u0305\n\6\f\6\16\6\u0308\13")
        buf.write("\6\3\7\3\7\3\7\5\7\u030d\n\7\3\b\3\b\3\b\3\t\3\t\3\t\5")
        buf.write("\t\u0315\n\t\3\t\3\t\3\t\5\t\u031a\n\t\3\n\3\n\3\13\3")
        buf.write("\13\5\13\u0320\n\13\3\f\3\f\3\f\5\f\u0325\n\f\3\f\3\f")
        buf.write("\3\f\6\f\u032a\n\f\r\f\16\f\u032b\3\f\3\f\5\f\u0330\n")
        buf.write("\f\3\r\3\r\3\16\5\16\u0335\n\16\3\16\3\16\3\16\3\16\5")
        buf.write("\16\u033b\n\16\3\16\5\16\u033e\n\16\3\16\5\16\u0341\n")
        buf.write("\16\3\16\3\16\3\17\3\17\3\20\3\20\3\20\7\20\u034a\n\20")
        buf.write("\f\20\16\20\u034d\13\20\3\21\3\21\5\21\u0351\n\21\3\21")
        buf.write("\3\21\3\21\5\21\u0356\n\21\3\21\5\21\u0359\n\21\3\21\5")
        buf.write("\21\u035c\n\21\3\21\5\21\u035f\n\21\3\21\5\21\u0362\n")
        buf.write("\21\3\22\3\22\3\23\3\23\3\23\3\24\3\24\3\24\5\24\u036c")
        buf.write("\n\24\3\25\3\25\5\25\u0370\n\25\3\26\3\26\7\26\u0374\n")
        buf.write("\26\f\26\16\26\u0377\13\26\3\26\3\26\7\26\u037b\n\26\f")
        buf.write("\26\16\26\u037e\13\26\3\27\3\27\3\30\3\30\3\31\3\31\3")
        buf.write("\31\3\32\3\32\3\33\3\33\3\34\3\34\3\35\3\35\3\36\5\36")
        buf.write("\u0390\n\36\3\36\3\36\3\36\5\36\u0395\n\36\3\36\5\36\u0398")
        buf.write("\n\36\3\36\3\36\3\36\5\36\u039d\n\36\3\36\5\36\u03a0\n")
        buf.write("\36\3\36\5\36\u03a3\n\36\3\37\3\37\3 \3 \3 \7 \u03aa\n")
        buf.write(" \f \16 \u03ad\13 \3!\3!\5!\u03b1\n!\3!\3!\3!\5!\u03b6")
        buf.write("\n!\3\"\3\"\3#\3#\3$\3$\3$\7$\u03bf\n$\f$\16$\u03c2\13")
        buf.write("$\3$\5$\u03c5\n$\3%\3%\5%\u03c9\n%\3%\3%\3%\5%\u03ce\n")
        buf.write("%\3&\3&\3\'\3\'\3(\3(\7(\u03d6\n(\f(\16(\u03d9\13(\3(")
        buf.write("\3(\3)\3)\3)\5)\u03e0\n)\3*\3*\3*\3*\3*\3+\3+\3+\7+\u03ea")
        buf.write("\n+\f+\16+\u03ed\13+\3,\3,\3,\3,\3-\3-\3-\3-\5-\u03f7")
        buf.write("\n-\3-\5-\u03fa\n-\3-\3-\3-\5-\u03ff\n-\3-\5-\u0402\n")
        buf.write("-\3.\3.\3.\7.\u0407\n.\f.\16.\u040a\13.\3/\3/\5/\u040e")
        buf.write("\n/\3/\3/\3/\5/\u0413\n/\3\60\3\60\3\61\3\61\3\62\6\62")
        buf.write("\u041a\n\62\r\62\16\62\u041b\3\63\3\63\3\63\3\63\3\63")
        buf.write("\3\63\5\63\u0424\n\63\3\64\3\64\3\64\3\65\3\65\3\65\3")
        buf.write("\65\3\65\3\65\5\65\u042f\n\65\5\65\u0431\n\65\3\66\3\66")
        buf.write("\3\66\3\66\3\66\3\66\5\66\u0439\n\66\5\66\u043b\n\66\3")
        buf.write("\67\3\67\3\67\38\38\38\39\39\39\39\3:\3:\3;\3;\3;\3;\5")
        buf.write(";\u044d\n;\3<\3<\3=\3=\3=\3=\3=\3=\7=\u0457\n=\f=\16=")
        buf.write("\u045a\13=\3>\3>\3>\3>\7>\u0460\n>\f>\16>\u0463\13>\3")
        buf.write(">\3>\3?\3?\3?\3?\3?\3?\3?\5?\u046e\n?\3?\3?\5?\u0472\n")
        buf.write("?\3@\3@\3@\3@\3@\3@\3@\3@\3@\5@\u047d\n@\3@\3@\5@\u0481")
        buf.write("\n@\3A\3A\3A\3A\3A\3B\3B\5B\u048a\nB\3C\3C\3C\3D\3D\3")
        buf.write("D\3E\3E\3F\3F\5F\u0496\nF\3F\3F\3F\3F\5F\u049c\nF\3F\3")
        buf.write("F\3F\3F\5F\u04a2\nF\3F\3F\5F\u04a6\nF\3G\3G\3G\3G\7G\u04ac")
        buf.write("\nG\fG\16G\u04af\13G\3H\3H\3H\3H\7H\u04b5\nH\fH\16H\u04b8")
        buf.write("\13H\3I\3I\3I\5I\u04bd\nI\3J\3J\3K\3K\5K\u04c3\nK\3K\6")
        buf.write("K\u04c6\nK\rK\16K\u04c7\3L\3L\3L\3L\3L\5L\u04cf\nL\3M")
        buf.write("\3M\5M\u04d3\nM\3N\3N\3O\3O\3O\3O\3O\3O\3O\3O\3O\5O\u04e0")
        buf.write("\nO\3P\3P\5P\u04e4\nP\3Q\3Q\3Q\5Q\u04e9\nQ\3R\3R\3R\3")
        buf.write("R\7R\u04ef\nR\fR\16R\u04f2\13R\5R\u04f4\nR\3R\3R\3S\3")
        buf.write("S\3S\5S\u04fb\nS\3T\3T\5T\u04ff\nT\3U\3U\3V\3V\3V\3V\3")
        buf.write("V\3V\3V\5V\u050a\nV\3W\3W\3X\3X\3Y\3Y\3Z\3Z\3[\3[\3\\")
        buf.write("\3\\\3]\3]\3^\3^\3_\3_\3`\3`\3a\3a\3b\5b\u0523\nb\3b\3")
        buf.write("b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3")
        buf.write("b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3")
        buf.write("b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3")
        buf.write("b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3")
        buf.write("b\3b\3b\3b\3b\3b\3b\5b\u0575\nb\3c\3c\5c\u0579\nc\3c\3")
        buf.write("c\3d\3d\3d\3d\3e\3e\5e\u0583\ne\3e\3e\5e\u0587\ne\3f\3")
        buf.write("f\3f\3f\3g\3g\3g\3g\3h\3h\3h\5h\u0594\nh\3h\3h\5h\u0598")
        buf.write("\nh\3h\5h\u059b\nh\3h\5h\u059e\nh\3h\5h\u05a1\nh\3h\3")
        buf.write("h\5h\u05a5\nh\3h\5h\u05a8\nh\3i\3i\3i\3i\3j\3j\3j\3j\3")
        buf.write("k\5k\u05b3\nk\3k\3k\3l\3l\3l\3l\3m\3m\3m\3m\3n\3n\3o\3")
        buf.write("o\3p\3p\3p\3p\3q\5q\u05c8\nq\3q\3q\3q\3r\3r\3r\3r\3r\3")
        buf.write("r\3r\3r\3r\5r\u05d6\nr\3s\3s\3s\3s\5s\u05dc\ns\3t\3t\3")
        buf.write("t\3t\3u\3u\3v\3v\3v\5v\u05e7\nv\3w\3w\3w\3w\3x\3x\3y\3")
        buf.write("y\3z\3z\3z\3z\3{\3{\3{\3{\3|\3|\3|\3|\3|\5|\u05fe\n|\3")
        buf.write("|\3|\5|\u0602\n|\3|\3|\3}\3}\3}\3}\3~\3~\3~\3~\3\177\3")
        buf.write("\177\3\177\3\177\3\177\5\177\u0613\n\177\3\177\3\177\5")
        buf.write("\177\u0617\n\177\3\177\3\177\3\u0080\3\u0080\3\u0080\3")
        buf.write("\u0080\3\u0081\3\u0081\3\u0082\3\u0082\3\u0082\3\u0082")
        buf.write("\3\u0083\3\u0083\3\u0083\3\u0083\3\u0084\3\u0084\3\u0085")
        buf.write("\3\u0085\3\u0085\3\u0085\3\u0086\3\u0086\3\u0086\3\u0086")
        buf.write("\3\u0087\5\u0087\u0634\n\u0087\3\u0087\3\u0087\3\u0088")
        buf.write("\3\u0088\3\u0088\3\u0088\3\u0089\3\u0089\3\u0089\3\u0089")
        buf.write("\3\u008a\5\u008a\u0641\n\u008a\3\u008b\3\u008b\3\u008b")
        buf.write("\3\u008b\3\u008b\5\u008b\u0648\n\u008b\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008d\3\u008d\3\u008e\3\u008e\3\u008e")
        buf.write("\3\u008e\3\u008f\3\u008f\3\u0090\3\u0090\3\u0090\3\u0090")
        buf.write("\3\u0090\3\u0090\7\u0090\u065c\n\u0090\f\u0090\16\u0090")
        buf.write("\u065f\13\u0090\3\u0090\3\u0090\3\u0090\5\u0090\u0664")
        buf.write("\n\u0090\3\u0090\3\u0090\3\u0090\3\u0090\3\u0090\3\u0090")
        buf.write("\7\u0090\u066c\n\u0090\f\u0090\16\u0090\u066f\13\u0090")
        buf.write("\3\u0090\3\u0090\5\u0090\u0673\n\u0090\3\u0090\3\u0090")
        buf.write("\3\u0090\3\u0090\5\u0090\u0679\n\u0090\3\u0091\3\u0091")
        buf.write("\5\u0091\u067d\n\u0091\3\u0092\3\u0092\3\u0093\3\u0093")
        buf.write("\3\u0094\3\u0094\3\u0094\3\u0094\3\u0095\3\u0095\3\u0096")
        buf.write("\3\u0096\3\u0096\3\u0096\3\u0097\3\u0097\3\u0097\3\u0097")
        buf.write("\3\u0098\3\u0098\3\u0099\3\u0099\3\u009a\3\u009a\3\u009a")
        buf.write("\3\u009a\3\u009b\3\u009b\3\u009c\3\u009c\3\u009c\3\u009c")
        buf.write("\3\u009c\3\u009c\3\u009d\3\u009d\3\u009d\3\u009d\3\u009e")
        buf.write("\3\u009e\5\u009e\u06a7\n\u009e\3\u009e\3\u009e\3\u009f")
        buf.write("\3\u009f\3\u00a0\3\u00a0\3\u00a0\3\u00a0\3\u00a1\3\u00a1")
        buf.write("\5\u00a1\u06b3\n\u00a1\3\u00a1\5\u00a1\u06b6\n\u00a1\3")
        buf.write("\u00a1\5\u00a1\u06b9\n\u00a1\3\u00a1\3\u00a1\3\u00a1\3")
        buf.write("\u00a1\5\u00a1\u06bf\n\u00a1\3\u00a1\5\u00a1\u06c2\n\u00a1")
        buf.write("\3\u00a1\5\u00a1\u06c5\n\u00a1\3\u00a2\3\u00a2\5\u00a2")
        buf.write("\u06c9\n\u00a2\3\u00a3\3\u00a3\3\u00a4\3\u00a4\5\u00a4")
        buf.write("\u06cf\n\u00a4\3\u00a5\3\u00a5\3\u00a6\3\u00a6\3\u00a7")
        buf.write("\3\u00a7\3\u00a7\3\u00a7\3\u00a8\5\u00a8\u06da\n\u00a8")
        buf.write("\3\u00a8\3\u00a8\3\u00a8\3\u00a9\3\u00a9\3\u00a9\3\u00a9")
        buf.write("\3\u00a9\5\u00a9\u06e4\n\u00a9\3\u00aa\3\u00aa\3\u00aa")
        buf.write("\3\u00aa\3\u00ab\3\u00ab\3\u00ab\5\u00ab\u06ed\n\u00ab")
        buf.write("\3\u00ab\3\u00ab\3\u00ab\5\u00ab\u06f2\n\u00ab\3\u00ab")
        buf.write("\3\u00ab\3\u00ab\5\u00ab\u06f7\n\u00ab\3\u00ab\3\u00ab")
        buf.write("\3\u00ab\5\u00ab\u06fc\n\u00ab\3\u00ac\3\u00ac\3\u00ac")
        buf.write("\3\u00ac\3\u00ad\3\u00ad\3\u00ad\3\u00ad\3\u00ae\3\u00ae")
        buf.write("\5\u00ae\u0708\n\u00ae\3\u00ae\3\u00ae\3\u00af\3\u00af")
        buf.write("\3\u00b0\3\u00b0\3\u00b1\3\u00b1\3\u00b1\3\u00b1\3\u00b2")
        buf.write("\3\u00b2\5\u00b2\u0716\n\u00b2\3\u00b2\5\u00b2\u0719\n")
        buf.write("\u00b2\3\u00b2\3\u00b2\5\u00b2\u071d\n\u00b2\3\u00b3\3")
        buf.write("\u00b3\3\u00b4\3\u00b4\3\u00b4\3\u00b4\3\u00b5\3\u00b5")
        buf.write("\3\u00b6\3\u00b6\3\u00b7\3\u00b7\3\u00b7\3\u00b7\3\u00b8")
        buf.write("\5\u00b8\u072e\n\u00b8\3\u00b8\5\u00b8\u0731\n\u00b8\3")
        buf.write("\u00b8\3\u00b8\5\u00b8\u0735\n\u00b8\3\u00b8\5\u00b8\u0738")
        buf.write("\n\u00b8\3\u00b8\3\u00b8\3\u00b8\3\u00b8\5\u00b8\u073e")
        buf.write("\n\u00b8\3\u00b8\3\u00b8\3\u00b8\5\u00b8\u0743\n\u00b8")
        buf.write("\3\u00b8\3\u00b8\5\u00b8\u0747\n\u00b8\3\u00b9\3\u00b9")
        buf.write("\3\u00b9\3\u00b9\3\u00b9\3\u00b9\3\u00ba\3\u00ba\3\u00ba")
        buf.write("\3\u00ba\3\u00bb\5\u00bb\u0754\n\u00bb\3\u00bb\3\u00bb")
        buf.write("\5\u00bb\u0758\n\u00bb\3\u00bb\3\u00bb\5\u00bb\u075c\n")
        buf.write("\u00bb\3\u00bc\3\u00bc\3\u00bc\3\u00bc\3\u00bc\3\u00bc")
        buf.write("\3\u00bd\3\u00bd\3\u00bd\3\u00bd\3\u00be\3\u00be\5\u00be")
        buf.write("\u076a\n\u00be\3\u00be\3\u00be\3\u00bf\3\u00bf\3\u00c0")
        buf.write("\3\u00c0\3\u00c0\3\u00c0\3\u00c1\3\u00c1\5\u00c1\u0776")
        buf.write("\n\u00c1\3\u00c1\3\u00c1\3\u00c1\3\u00c1\3\u00c1\5\u00c1")
        buf.write("\u077d\n\u00c1\3\u00c1\5\u00c1\u0780\n\u00c1\3\u00c1\3")
        buf.write("\u00c1\3\u00c1\5\u00c1\u0785\n\u00c1\3\u00c1\5\u00c1\u0788")
        buf.write("\n\u00c1\3\u00c1\3\u00c1\3\u00c1\5\u00c1\u078d\n\u00c1")
        buf.write("\3\u00c2\3\u00c2\3\u00c2\3\u00c2\3\u00c3\3\u00c3\3\u00c3")
        buf.write("\3\u00c3\3\u00c4\3\u00c4\5\u00c4\u0799\n\u00c4\3\u00c4")
        buf.write("\3\u00c4\3\u00c4\3\u00c4\3\u00c4\5\u00c4\u07a0\n\u00c4")
        buf.write("\3\u00c4\5\u00c4\u07a3\n\u00c4\3\u00c4\3\u00c4\3\u00c4")
        buf.write("\5\u00c4\u07a8\n\u00c4\3\u00c4\5\u00c4\u07ab\n\u00c4\3")
        buf.write("\u00c4\3\u00c4\3\u00c4\5\u00c4\u07b0\n\u00c4\3\u00c5\3")
        buf.write("\u00c5\3\u00c5\3\u00c5\3\u00c6\3\u00c6\3\u00c6\3\u00c6")
        buf.write("\3\u00c7\3\u00c7\3\u00c7\3\u00c7\3\u00c7\5\u00c7\u07bf")
        buf.write("\n\u00c7\3\u00c8\3\u00c8\3\u00c8\3\u00c8\3\u00c9\3\u00c9")
        buf.write("\3\u00c9\3\u00c9\3\u00ca\3\u00ca\5\u00ca\u07cb\n\u00ca")
        buf.write("\3\u00ca\3\u00ca\5\u00ca\u07cf\n\u00ca\3\u00cb\3\u00cb")
        buf.write("\3\u00cb\3\u00cb\3\u00cc\3\u00cc\3\u00cc\3\u00cd\3\u00cd")
        buf.write("\3\u00ce\3\u00ce\3\u00ce\3\u00ce\3\u00cf\3\u00cf\5\u00cf")
        buf.write("\u07e0\n\u00cf\3\u00cf\3\u00cf\5\u00cf\u07e4\n\u00cf\3")
        buf.write("\u00d0\3\u00d0\3\u00d0\3\u00d0\3\u00d1\3\u00d1\3\u00d1")
        buf.write("\3\u00d1\3\u00d2\3\u00d2\3\u00d3\3\u00d3\3\u00d4\3\u00d4")
        buf.write("\3\u00d4\3\u00d4\3\u00d5\5\u00d5\u07f7\n\u00d5\3\u00d5")
        buf.write("\3\u00d5\5\u00d5\u07fb\n\u00d5\3\u00d5\5\u00d5\u07fe\n")
        buf.write("\u00d5\3\u00d5\5\u00d5\u0801\n\u00d5\3\u00d5\3\u00d5\5")
        buf.write("\u00d5\u0805\n\u00d5\3\u00d5\5\u00d5\u0808\n\u00d5\3\u00d6")
        buf.write("\3\u00d6\3\u00d6\3\u00d6\3\u00d7\3\u00d7\3\u00d7\3\u00d7")
        buf.write("\3\u00d8\3\u00d8\3\u00d8\3\u00d9\3\u00d9\3\u00d9\3\u00d9")
        buf.write("\3\u00da\3\u00da\3\u00da\3\u00da\3\u00db\3\u00db\5\u00db")
        buf.write("\u081f\n\u00db\3\u00db\3\u00db\5\u00db\u0823\n\u00db\3")
        buf.write("\u00dc\3\u00dc\3\u00dc\3\u00dc\3\u00dd\3\u00dd\3\u00dd")
        buf.write("\3\u00dd\3\u00de\3\u00de\3\u00df\3\u00df\3\u00e0\3\u00e0")
        buf.write("\3\u00e0\3\u00e0\3\u00e1\3\u00e1\3\u00e2\3\u00e2\3\u00e3")
        buf.write("\3\u00e3\3\u00e3\3\u00e4\3\u00e4\3\u00e5\3\u00e5\3\u00e5")
        buf.write("\3\u00e5\3\u00e6\3\u00e6\3\u00e7\3\u00e7\3\u00e7\3\u00e7")
        buf.write("\3\u00e8\3\u00e8\3\u00e8\3\u00e8\3\u00e9\5\u00e9\u084d")
        buf.write("\n\u00e9\3\u00e9\3\u00e9\3\u00ea\3\u00ea\3\u00ea\3\u00ea")
        buf.write("\3\u00eb\3\u00eb\3\u00eb\3\u00eb\3\u00ec\3\u00ec\3\u00ed")
        buf.write("\3\u00ed\3\u00ed\3\u00ed\3\u00ee\3\u00ee\3\u00ee\3\u00ee")
        buf.write("\3\u00ef\3\u00ef\5\u00ef\u0865\n\u00ef\3\u00f0\3\u00f0")
        buf.write("\3\u00f0\3\u00f0\3\u00f0\3\u00f0\3\u00f0\3\u00f0\5\u00f0")
        buf.write("\u086f\n\u00f0\3\u00f1\3\u00f1\3\u00f1\3\u00f1\3\u00f2")
        buf.write("\3\u00f2\5\u00f2\u0877\n\u00f2\3\u00f2\3\u00f2\5\u00f2")
        buf.write("\u087b\n\u00f2\3\u00f2\3\u00f2\5\u00f2\u087f\n\u00f2\3")
        buf.write("\u00f2\3\u00f2\3\u00f2\3\u00f2\3\u00f2\3\u00f2\5\u00f2")
        buf.write("\u0887\n\u00f2\3\u00f3\3\u00f3\3\u00f4\3\u00f4\3\u00f4")
        buf.write("\3\u00f4\3\u00f5\5\u00f5\u0890\n\u00f5\3\u00f5\3\u00f5")
        buf.write("\3\u00f5\3\u00f6\3\u00f6\3\u00f6\3\u00f6\3\u00f6\3\u00f6")
        buf.write("\3\u00f7\3\u00f7\3\u00f7\3\u00f7\3\u00f8\3\u00f8\3\u00f9")
        buf.write("\3\u00f9\3\u00f9\3\u00f9\3\u00fa\3\u00fa\3\u00fb\3\u00fb")
        buf.write("\3\u00fc\3\u00fc\3\u00fc\3\u00fc\3\u00fd\3\u00fd\5\u00fd")
        buf.write("\u08af\n\u00fd\3\u00fd\3\u00fd\3\u00fd\5\u00fd\u08b4\n")
        buf.write("\u00fd\3\u00fe\3\u00fe\3\u00ff\3\u00ff\3\u00ff\3\u00ff")
        buf.write("\3\u0100\3\u0100\3\u0101\3\u0101\3\u0101\3\u0101\3\u0102")
        buf.write("\3\u0102\3\u0102\3\u0102\3\u0103\3\u0103\3\u0104\3\u0104")
        buf.write("\3\u0105\3\u0105\5\u0105\u08cc\n\u0105\3\u0106\3\u0106")
        buf.write("\3\u0106\3\u0106\3\u0107\3\u0107\5\u0107\u08d4\n\u0107")
        buf.write("\3\u0107\3\u0107\3\u0107\3\u0108\3\u0108\3\u0109\3\u0109")
        buf.write("\3\u0109\3\u0109\3\u010a\3\u010a\3\u010a\5\u010a\u08e2")
        buf.write("\n\u010a\3\u010a\3\u010a\3\u010a\3\u010b\3\u010b\3\u010b")
        buf.write("\3\u010b\3\u010b\3\u010b\3\u010b\5\u010b\u08ee\n\u010b")
        buf.write("\3\u010b\3\u010b\3\u010c\3\u010c\5\u010c\u08f4\n\u010c")
        buf.write("\3\u010d\3\u010d\3\u010d\3\u010d\3\u010e\3\u010e\5\u010e")
        buf.write("\u08fc\n\u010e\3\u010e\3\u010e\3\u010f\3\u010f\3\u0110")
        buf.write("\3\u0110\3\u0110\3\u0110\3\u0111\3\u0111\3\u0111\5\u0111")
        buf.write("\u0909\n\u0111\3\u0111\3\u0111\3\u0112\3\u0112\3\u0112")
        buf.write("\3\u0112\3\u0112\3\u0112\3\u0112\5\u0112\u0914\n\u0112")
        buf.write("\3\u0112\3\u0112\3\u0113\3\u0113\3\u0113\3\u0113\3\u0114")
        buf.write("\3\u0114\3\u0115\3\u0115\3\u0116\3\u0116\3\u0116\3\u0116")
        buf.write("\3\u0117\3\u0117\3\u0118\3\u0118\3\u0119\3\u0119\3\u0119")
        buf.write("\3\u0119\3\u011a\3\u011a\5\u011a\u092e\n\u011a\3\u011a")
        buf.write("\3\u011a\3\u011b\3\u011b\3\u011c\3\u011c\3\u011c\3\u011c")
        buf.write("\3\u011d\3\u011d\3\u011d\5\u011d\u093b\n\u011d\3\u011d")
        buf.write("\3\u011d\5\u011d\u093f\n\u011d\3\u011e\3\u011e\3\u011f")
        buf.write("\3\u011f\3\u011f\3\u011f\3\u0120\3\u0120\5\u0120\u0949")
        buf.write("\n\u0120\3\u0120\3\u0120\3\u0120\5\u0120\u094e\n\u0120")
        buf.write("\3\u0120\3\u0120\3\u0120\5\u0120\u0953\n\u0120\3\u0121")
        buf.write("\3\u0121\3\u0122\3\u0122\3\u0122\3\u0122\3\u0123\5\u0123")
        buf.write("\u095c\n\u0123\3\u0123\5\u0123\u095f\n\u0123\3\u0123\5")
        buf.write("\u0123\u0962\n\u0123\3\u0123\3\u0123\3\u0123\5\u0123\u0967")
        buf.write("\n\u0123\3\u0123\3\u0123\3\u0123\5\u0123\u096c\n\u0123")
        buf.write("\3\u0123\3\u0123\5\u0123\u0970\n\u0123\3\u0124\3\u0124")
        buf.write("\3\u0124\3\u0124\3\u0124\3\u0124\3\u0125\3\u0125\3\u0125")
        buf.write("\3\u0125\3\u0126\3\u0126\3\u0126\5\u0126\u097f\n\u0126")
        buf.write("\3\u0126\3\u0126\5\u0126\u0983\n\u0126\3\u0126\5\u0126")
        buf.write("\u0986\n\u0126\3\u0126\5\u0126\u0989\n\u0126\3\u0126\5")
        buf.write("\u0126\u098c\n\u0126\3\u0126\3\u0126\5\u0126\u0990\n\u0126")
        buf.write("\3\u0126\5\u0126\u0993\n\u0126\3\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0128\3\u0128\3\u0128\3\u0128\3\u0129\3\u0129")
        buf.write("\3\u0129\5\u0129\u09a0\n\u0129\3\u0129\3\u0129\5\u0129")
        buf.write("\u09a4\n\u0129\3\u012a\3\u012a\3\u012a\3\u012a\3\u012b")
        buf.write("\3\u012b\3\u012b\3\u012b\3\u012c\3\u012c\3\u012c\5\u012c")
        buf.write("\u09b1\n\u012c\3\u012c\5\u012c\u09b4\n\u012c\3\u012c\3")
        buf.write("\u012c\3\u012c\3\u012c\3\u012c\5\u012c\u09bb\n\u012c\3")
        buf.write("\u012c\5\u012c\u09be\n\u012c\3\u012c\3\u012c\5\u012c\u09c2")
        buf.write("\n\u012c\3\u012d\3\u012d\3\u012d\3\u012d\3\u012d\3\u012d")
        buf.write("\3\u012d\3\u012d\3\u012e\3\u012e\3\u012e\3\u012e\3\u012f")
        buf.write("\3\u012f\3\u012f\5\u012f\u09d3\n\u012f\3\u012f\5\u012f")
        buf.write("\u09d6\n\u012f\3\u012f\3\u012f\3\u012f\3\u012f\3\u012f")
        buf.write("\5\u012f\u09dd\n\u012f\3\u012f\5\u012f\u09e0\n\u012f\3")
        buf.write("\u012f\3\u012f\5\u012f\u09e4\n\u012f\3\u0130\3\u0130\3")
        buf.write("\u0130\3\u0130\3\u0130\3\u0130\3\u0130\3\u0130\3\u0131")
        buf.write("\3\u0131\3\u0131\3\u0131\3\u0132\3\u0132\3\u0132\5\u0132")
        buf.write("\u09f5\n\u0132\3\u0132\5\u0132\u09f8\n\u0132\3\u0132\3")
        buf.write("\u0132\3\u0132\3\u0132\3\u0132\5\u0132\u09ff\n\u0132\3")
        buf.write("\u0132\5\u0132\u0a02\n\u0132\3\u0132\3\u0132\5\u0132\u0a06")
        buf.write("\n\u0132\3\u0133\3\u0133\3\u0133\3\u0133\3\u0133\3\u0133")
        buf.write("\3\u0133\3\u0133\3\u0134\3\u0134\3\u0134\3\u0134\3\u0135")
        buf.write("\3\u0135\3\u0135\3\u0136\3\u0136\3\u0136\3\u0136\3\u0136")
        buf.write("\3\u0136\3\u0137\3\u0137\3\u0137\3\u0137\3\u0138\3\u0138")
        buf.write("\3\u0138\3\u0139\3\u0139\3\u0139\3\u0139\3\u013a\3\u013a")
        buf.write("\3\u013a\3\u013a\3\u013b\3\u013b\3\u013b\3\u013b\3\u013b")
        buf.write("\3\u013c\3\u013c\3\u013c\3\u013c\3\u013c\3\u013c\3\u013c")
        buf.write("\3\u013c\5\u013c\u0a39\n\u013c\3\u013c\3\u013c\3\u013d")
        buf.write("\3\u013d\3\u013d\3\u013d\3\u013e\3\u013e\5\u013e\u0a43")
        buf.write("\n\u013e\3\u013e\3\u013e\3\u013f\3\u013f\3\u013f\3\u013f")
        buf.write("\3\u013f\3\u013f\3\u0140\3\u0140\3\u0141\3\u0141\3\u0142")
        buf.write("\3\u0142\3\u0143\3\u0143\3\u0144\3\u0144\3\u0145\3\u0145")
        buf.write("\3\u0146\3\u0146\3\u0147\3\u0147\3\u0148\3\u0148\3\u0149")
        buf.write("\3\u0149\3\u014a\3\u014a\3\u014a\3\u014a\3\u014b\3\u014b")
        buf.write("\3\u014b\3\u014b\5\u014b\u0a69\n\u014b\3\u014c\3\u014c")
        buf.write("\3\u014c\5\u014c\u0a6e\n\u014c\3\u014c\3\u014c\3\u014d")
        buf.write("\3\u014d\3\u014d\3\u014d\3\u014e\3\u014e\3\u014f\3\u014f")
        buf.write("\3\u0150\3\u0150\3\u0151\3\u0151\5\u0151\u0a7e\n\u0151")
        buf.write("\3\u0152\3\u0152\3\u0152\3\u0152\3\u0153\3\u0153\3\u0153")
        buf.write("\3\u0153\3\u0153\3\u0153\3\u0154\3\u0154\3\u0154\3\u0154")
        buf.write("\3\u0154\3\u0154\3\u0154\3\u0154\3\u0155\3\u0155\3\u0155")
        buf.write("\3\u0155\3\u0155\3\u0155\3\u0155\3\u0155\3\u0155\3\u0155")
        buf.write("\3\u0156\3\u0156\3\u0157\3\u0157\3\u0158\3\u0158\5\u0158")
        buf.write("\u0aa2\n\u0158\3\u0158\5\u0158\u0aa5\n\u0158\3\u0158\3")
        buf.write("\u0158\5\u0158\u0aa9\n\u0158\3\u0158\3\u0158\3\u0158\3")
        buf.write("\u0158\5\u0158\u0aaf\n\u0158\3\u0158\3\u0158\3\u0158\5")
        buf.write("\u0158\u0ab4\n\u0158\3\u0158\3\u0158\3\u0158\5\u0158\u0ab9")
        buf.write("\n\u0158\7\u0158\u0abb\n\u0158\f\u0158\16\u0158\u0abe")
        buf.write("\13\u0158\3\u0158\3\u0158\5\u0158\u0ac2\n\u0158\3\u0159")
        buf.write("\3\u0159\3\u0159\3\u0159\3\u015a\3\u015a\3\u015a\3\u015a")
        buf.write("\3\u015a\3\u015a\3\u015b\3\u015b\3\u015b\3\u015b\3\u015b")
        buf.write("\3\u015b\3\u015b\3\u015b\3\u015c\3\u015c\3\u015c\3\u015c")
        buf.write("\3\u015c\3\u015c\3\u015c\3\u015c\3\u015c\3\u015c\3\u015d")
        buf.write("\3\u015d\3\u015e\3\u015e\3\u015f\3\u015f\3\u015f\3\u015f")
        buf.write("\3\u015f\3\u015f\5\u015f\u0aea\n\u015f\3\u0160\3\u0160")
        buf.write("\3\u0160\7\u0160\u0aef\n\u0160\f\u0160\16\u0160\u0af2")
        buf.write("\13\u0160\3\u0161\3\u0161\3\u0161\7\u0161\u0af7\n\u0161")
        buf.write("\f\u0161\16\u0161\u0afa\13\u0161\3\u0162\3\u0162\3\u0162")
        buf.write("\7\u0162\u0aff\n\u0162\f\u0162\16\u0162\u0b02\13\u0162")
        buf.write("\3\u0163\3\u0163\3\u0163\7\u0163\u0b07\n\u0163\f\u0163")
        buf.write("\16\u0163\u0b0a\13\u0163\3\u0164\3\u0164\3\u0164\7\u0164")
        buf.write("\u0b0f\n\u0164\f\u0164\16\u0164\u0b12\13\u0164\3\u0165")
        buf.write("\3\u0165\3\u0165\7\u0165\u0b17\n\u0165\f\u0165\16\u0165")
        buf.write("\u0b1a\13\u0165\3\u0166\3\u0166\3\u0166\3\u0166\7\u0166")
        buf.write("\u0b20\n\u0166\f\u0166\16\u0166\u0b23\13\u0166\3\u0167")
        buf.write("\3\u0167\3\u0168\3\u0168\3\u0168\3\u0168\7\u0168\u0b2b")
        buf.write("\n\u0168\f\u0168\16\u0168\u0b2e\13\u0168\3\u0169\3\u0169")
        buf.write("\3\u016a\3\u016a\3\u016a\7\u016a\u0b35\n\u016a\f\u016a")
        buf.write("\16\u016a\u0b38\13\u016a\3\u016b\3\u016b\3\u016b\7\u016b")
        buf.write("\u0b3d\n\u016b\f\u016b\16\u016b\u0b40\13\u016b\3\u016c")
        buf.write("\3\u016c\3\u016c\3\u016c\3\u016c\5\u016c\u0b47\n\u016c")
        buf.write("\3\u016d\3\u016d\3\u016d\3\u016d\3\u016d\3\u016d\5\u016d")
        buf.write("\u0b4f\n\u016d\3\u016e\3\u016e\3\u016f\3\u016f\3\u016f")
        buf.write("\3\u016f\3\u016f\3\u0170\3\u0170\3\u0170\5\u0170\u0b5b")
        buf.write("\n\u0170\3\u0171\3\u0171\3\u0171\3\u0171\3\u0172\3\u0172")
        buf.write("\3\u0172\5\u0172\u0b64\n\u0172\3\u0173\3\u0173\3\u0174")
        buf.write("\3\u0174\3\u0175\3\u0175\3\u0176\3\u0176\3\u0176\2\2\u0177")
        buf.write("\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62")
        buf.write("\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082")
        buf.write("\u0084\u0086\u0088\u008a\u008c\u008e\u0090\u0092\u0094")
        buf.write("\u0096\u0098\u009a\u009c\u009e\u00a0\u00a2\u00a4\u00a6")
        buf.write("\u00a8\u00aa\u00ac\u00ae\u00b0\u00b2\u00b4\u00b6\u00b8")
        buf.write("\u00ba\u00bc\u00be\u00c0\u00c2\u00c4\u00c6\u00c8\u00ca")
        buf.write("\u00cc\u00ce\u00d0\u00d2\u00d4\u00d6\u00d8\u00da\u00dc")
        buf.write("\u00de\u00e0\u00e2\u00e4\u00e6\u00e8\u00ea\u00ec\u00ee")
        buf.write("\u00f0\u00f2\u00f4\u00f6\u00f8\u00fa\u00fc\u00fe\u0100")
        buf.write("\u0102\u0104\u0106\u0108\u010a\u010c\u010e\u0110\u0112")
        buf.write("\u0114\u0116\u0118\u011a\u011c\u011e\u0120\u0122\u0124")
        buf.write("\u0126\u0128\u012a\u012c\u012e\u0130\u0132\u0134\u0136")
        buf.write("\u0138\u013a\u013c\u013e\u0140\u0142\u0144\u0146\u0148")
        buf.write("\u014a\u014c\u014e\u0150\u0152\u0154\u0156\u0158\u015a")
        buf.write("\u015c\u015e\u0160\u0162\u0164\u0166\u0168\u016a\u016c")
        buf.write("\u016e\u0170\u0172\u0174\u0176\u0178\u017a\u017c\u017e")
        buf.write("\u0180\u0182\u0184\u0186\u0188\u018a\u018c\u018e\u0190")
        buf.write("\u0192\u0194\u0196\u0198\u019a\u019c\u019e\u01a0\u01a2")
        buf.write("\u01a4\u01a6\u01a8\u01aa\u01ac\u01ae\u01b0\u01b2\u01b4")
        buf.write("\u01b6\u01b8\u01ba\u01bc\u01be\u01c0\u01c2\u01c4\u01c6")
        buf.write("\u01c8\u01ca\u01cc\u01ce\u01d0\u01d2\u01d4\u01d6\u01d8")
        buf.write("\u01da\u01dc\u01de\u01e0\u01e2\u01e4\u01e6\u01e8\u01ea")
        buf.write("\u01ec\u01ee\u01f0\u01f2\u01f4\u01f6\u01f8\u01fa\u01fc")
        buf.write("\u01fe\u0200\u0202\u0204\u0206\u0208\u020a\u020c\u020e")
        buf.write("\u0210\u0212\u0214\u0216\u0218\u021a\u021c\u021e\u0220")
        buf.write("\u0222\u0224\u0226\u0228\u022a\u022c\u022e\u0230\u0232")
        buf.write("\u0234\u0236\u0238\u023a\u023c\u023e\u0240\u0242\u0244")
        buf.write("\u0246\u0248\u024a\u024c\u024e\u0250\u0252\u0254\u0256")
        buf.write("\u0258\u025a\u025c\u025e\u0260\u0262\u0264\u0266\u0268")
        buf.write("\u026a\u026c\u026e\u0270\u0272\u0274\u0276\u0278\u027a")
        buf.write("\u027c\u027e\u0280\u0282\u0284\u0286\u0288\u028a\u028c")
        buf.write("\u028e\u0290\u0292\u0294\u0296\u0298\u029a\u029c\u029e")
        buf.write("\u02a0\u02a2\u02a4\u02a6\u02a8\u02aa\u02ac\u02ae\u02b0")
        buf.write("\u02b2\u02b4\u02b6\u02b8\u02ba\u02bc\u02be\u02c0\u02c2")
        buf.write("\u02c4\u02c6\u02c8\u02ca\u02cc\u02ce\u02d0\u02d2\u02d4")
        buf.write("\u02d6\u02d8\u02da\u02dc\u02de\u02e0\u02e2\u02e4\u02e6")
        buf.write("\u02e8\u02ea\2@\4\2\u0088\u0088\u00ec\u00ec\t\2\u008e")
        buf.write("\u0091\u00a1\u00a4\u00b3\u00b3\u00e8\u00e8\u00ea\u00eb")
        buf.write("\u0106\u0107\u0109\u010a\3\2\u008b\u008c\5\2\u0094\u0094")
        buf.write("\u0099\u0099\u00a0\u00a0\5\2\u0088\u0088\u00e2\u00e2\u00ec")
        buf.write("\u00ec\4\2\u00ae\u00ae\u00b6\u00b6\3\2\3R\3\2\u00a2\u00a4")
        buf.write("\4\2\u008f\u0091\u00a2\u00a4\4\2\u0090\u0090\u00a3\u00a3")
        buf.write("\6\2\u00a6\u00a6\u00a8\u00a8\u00aa\u00aa\u00ac\u00ac\4")
        buf.write("\2\u008f\u0091\u00a3\u00a4\5\2\u00b3\u00b3\u0107\u0107")
        buf.write("\u0109\u010a\4\2\u009d\u009d\u00dd\u00dd\f\2\u0082\u0082")
        buf.write("\u00b8\u00b8\u00c6\u00c6\u00ca\u00ca\u00d7\u00d7\u00ed")
        buf.write("\u00ed\u00f5\u00f5\u0100\u0100\u010e\u010e\u0115\u0115")
        buf.write("\7\2\u008f\u0090\u00a3\u00a3\u00ea\u00ea\u0107\u0107\u0109")
        buf.write("\u0109\4\2\u00b8\u00b8\u010e\u010e\4\2\u008f\u0090\u00a2")
        buf.write("\u00a3\4\2\u0107\u0107\u0109\u0109\4\2\u0107\u0107\u0109")
        buf.write("\u010a\4\2\u00e8\u00e8\u00ea\u00ea\6\2\u008e\u0091\u00a1")
        buf.write("\u00a4\u00e8\u00e8\u00ea\u00eb\6\2\u00a5\u00a5\u00a7\u00a7")
        buf.write("\u00a9\u00a9\u00ab\u00ab\6\2\u009d\u009d\u00cf\u00cf\u00dd")
        buf.write("\u00dd\u00f9\u00f9\3\2\u008f\u0090\5\2\u009d\u009d\u00cf")
        buf.write("\u00cf\u00dd\u00dd\7\2\u009d\u009d\u00b6\u00b6\u00cf\u00cf")
        buf.write("\u00dd\u00dd\u00f9\u00f9\7\2\u00cb\u00cb\u00f6\u00f6\u00f8")
        buf.write("\u00f8\u00fe\u00fe\u0103\u0103\b\2\u008e\u0091\u00a1\u00a4")
        buf.write("\u00e8\u00e8\u00ea\u00ea\u0106\u0107\u0109\u010a\5\2\u0085")
        buf.write("\u0085\u00d1\u00d1\u00d9\u00d9\4\2\u00d1\u00d1\u00d9\u00d9")
        buf.write("\5\2\u0097\u0097\u00de\u00de\u00f7\u00f7\t\2\u008f\u0091")
        buf.write("\u00a2\u00a4\u00b3\u00b3\u00e8\u00e8\u00ea\u00ea\u0107")
        buf.write("\u0107\u0109\u010a\4\2\u00cf\u00cf\u00dd\u00dd\3\2\u00d4")
        buf.write("\u00d5\6\2\u00b1\u00b2\u00e9\u00e9\u00f1\u00f2\u0108\u0108")
        buf.write("\n\2\u0082\u0082\u00b8\u00b8\u00c6\u00c6\u00ca\u00ca\u00d7")
        buf.write("\u00d7\u00f5\u00f5\u010e\u010e\u0115\u0115\b\2\u008f\u0091")
        buf.write("\u00a2\u00a4\u00e8\u00e8\u00ea\u00ea\u0107\u0107\u0109")
        buf.write("\u010a\n\2\u00bb\u00bb\u00c2\u00c4\u00cc\u00ce\u00d1\u00d3")
        buf.write("\u00d8\u00d9\u00db\u00dc\u00df\u00e0\u00ee\u00ef\5\2\u0090")
        buf.write("\u0090\u00a3\u00a3\u00ea\u00ea\5\2\u0082\u0082\u00b8\u00b8")
        buf.write("\u010e\u010e\6\2\u008f\u0091\u00a2\u00a4\u0107\u0107\u0109")
        buf.write("\u010a\6\2\u009d\u009d\u00b6\u00b6\u00cf\u00cf\u00dd\u00dd")
        buf.write("\6\2\u0083\u0083\u0086\u0086\u00f8\u00f8\u00fe\u00fe\3")
        buf.write("\2df\6\2\u00f6\u00f6\u00f8\u00f8\u00fe\u00fe\u0103\u0103")
        buf.write("\4\2\u0106\u0107\u0109\u010a\5\2\u0081\u0081\u0092\u0092")
        buf.write("\u00fa\u00fa\6\2\u0090\u0090\u00a3\u00a3\u00ea\u00ea\u0109")
        buf.write("\u0109\5\2\u0084\u0084\u00da\u00da\u00f4\u00f4\b\2\u009a")
        buf.write("\u009a\u00ba\u00ba\u00bf\u00bf\u00c1\u00c1\u00d6\u00d6")
        buf.write("\u00e5\u00e5\4\2\u00a3\u00a3\u00ea\u00ea\7\2\u0084\u0084")
        buf.write("\u00c0\u00c0\u00da\u00da\u00f4\u00f4\u00fb\u00fc\4\2\u00e6")
        buf.write("\u00e6\u0111\u0113\5\2\u008d\u008d\u010d\u010d\u010f\u010f")
        buf.write("\3\2\u0116\u011d\4\2YYuu\4\2Z[xy\3\2\\]\4\2qqww\4\2^^")
        buf.write("\u0123\u0124\4\2\u008f\u008f\u00a2\u00a2\2\u0b7e\2\u02ec")
        buf.write("\3\2\2\2\4\u02f8\3\2\2\2\6\u02fb\3\2\2\2\b\u02fe\3\2\2")
        buf.write("\2\n\u0301\3\2\2\2\f\u030c\3\2\2\2\16\u030e\3\2\2\2\20")
        buf.write("\u0319\3\2\2\2\22\u031b\3\2\2\2\24\u031f\3\2\2\2\26\u032f")
        buf.write("\3\2\2\2\30\u0331\3\2\2\2\32\u0334\3\2\2\2\34\u0344\3")
        buf.write("\2\2\2\36\u0346\3\2\2\2 \u034e\3\2\2\2\"\u0363\3\2\2\2")
        buf.write("$\u0365\3\2\2\2&\u036b\3\2\2\2(\u036f\3\2\2\2*\u0371\3")
        buf.write("\2\2\2,\u037f\3\2\2\2.\u0381\3\2\2\2\60\u0383\3\2\2\2")
        buf.write("\62\u0386\3\2\2\2\64\u0388\3\2\2\2\66\u038a\3\2\2\28\u038c")
        buf.write("\3\2\2\2:\u038f\3\2\2\2<\u03a4\3\2\2\2>\u03a6\3\2\2\2")
        buf.write("@\u03ae\3\2\2\2B\u03b7\3\2\2\2D\u03b9\3\2\2\2F\u03bb\3")
        buf.write("\2\2\2H\u03c6\3\2\2\2J\u03cf\3\2\2\2L\u03d1\3\2\2\2N\u03d3")
        buf.write("\3\2\2\2P\u03df\3\2\2\2R\u03e1\3\2\2\2T\u03e6\3\2\2\2")
        buf.write("V\u03ee\3\2\2\2X\u03f2\3\2\2\2Z\u0403\3\2\2\2\\\u040b")
        buf.write("\3\2\2\2^\u0414\3\2\2\2`\u0416\3\2\2\2b\u0419\3\2\2\2")
        buf.write("d\u0423\3\2\2\2f\u0425\3\2\2\2h\u0428\3\2\2\2j\u0432\3")
        buf.write("\2\2\2l\u043c\3\2\2\2n\u043f\3\2\2\2p\u0442\3\2\2\2r\u0446")
        buf.write("\3\2\2\2t\u044c\3\2\2\2v\u044e\3\2\2\2x\u0450\3\2\2\2")
        buf.write("z\u045b\3\2\2\2|\u0471\3\2\2\2~\u0473\3\2\2\2\u0080\u0482")
        buf.write("\3\2\2\2\u0082\u0489\3\2\2\2\u0084\u048b\3\2\2\2\u0086")
        buf.write("\u048e\3\2\2\2\u0088\u0491\3\2\2\2\u008a\u04a5\3\2\2\2")
        buf.write("\u008c\u04a7\3\2\2\2\u008e\u04b0\3\2\2\2\u0090\u04b9\3")
        buf.write("\2\2\2\u0092\u04be\3\2\2\2\u0094\u04c5\3\2\2\2\u0096\u04ce")
        buf.write("\3\2\2\2\u0098\u04d2\3\2\2\2\u009a\u04d4\3\2\2\2\u009c")
        buf.write("\u04d6\3\2\2\2\u009e\u04e3\3\2\2\2\u00a0\u04e8\3\2\2\2")
        buf.write("\u00a2\u04ea\3\2\2\2\u00a4\u04fa\3\2\2\2\u00a6\u04fe\3")
        buf.write("\2\2\2\u00a8\u0500\3\2\2\2\u00aa\u0509\3\2\2\2\u00ac\u050b")
        buf.write("\3\2\2\2\u00ae\u050d\3\2\2\2\u00b0\u050f\3\2\2\2\u00b2")
        buf.write("\u0511\3\2\2\2\u00b4\u0513\3\2\2\2\u00b6\u0515\3\2\2\2")
        buf.write("\u00b8\u0517\3\2\2\2\u00ba\u0519\3\2\2\2\u00bc\u051b\3")
        buf.write("\2\2\2\u00be\u051d\3\2\2\2\u00c0\u051f\3\2\2\2\u00c2\u0522")
        buf.write("\3\2\2\2\u00c4\u0576\3\2\2\2\u00c6\u057c\3\2\2\2\u00c8")
        buf.write("\u0586\3\2\2\2\u00ca\u0588\3\2\2\2\u00cc\u058c\3\2\2\2")
        buf.write("\u00ce\u05a7\3\2\2\2\u00d0\u05a9\3\2\2\2\u00d2\u05ad\3")
        buf.write("\2\2\2\u00d4\u05b2\3\2\2\2\u00d6\u05b6\3\2\2\2\u00d8\u05ba")
        buf.write("\3\2\2\2\u00da\u05be\3\2\2\2\u00dc\u05c0\3\2\2\2\u00de")
        buf.write("\u05c2\3\2\2\2\u00e0\u05c7\3\2\2\2\u00e2\u05cc\3\2\2\2")
        buf.write("\u00e4\u05db\3\2\2\2\u00e6\u05dd\3\2\2\2\u00e8\u05e1\3")
        buf.write("\2\2\2\u00ea\u05e3\3\2\2\2\u00ec\u05e8\3\2\2\2\u00ee\u05ec")
        buf.write("\3\2\2\2\u00f0\u05ee\3\2\2\2\u00f2\u05f0\3\2\2\2\u00f4")
        buf.write("\u05f4\3\2\2\2\u00f6\u05f8\3\2\2\2\u00f8\u0605\3\2\2\2")
        buf.write("\u00fa\u0609\3\2\2\2\u00fc\u060d\3\2\2\2\u00fe\u061a\3")
        buf.write("\2\2\2\u0100\u061e\3\2\2\2\u0102\u0620\3\2\2\2\u0104\u0624")
        buf.write("\3\2\2\2\u0106\u0628\3\2\2\2\u0108\u062a\3\2\2\2\u010a")
        buf.write("\u062e\3\2\2\2\u010c\u0633\3\2\2\2\u010e\u0637\3\2\2\2")
        buf.write("\u0110\u063b\3\2\2\2\u0112\u0640\3\2\2\2\u0114\u0647\3")
        buf.write("\2\2\2\u0116\u0649\3\2\2\2\u0118\u064d\3\2\2\2\u011a\u064f")
        buf.write("\3\2\2\2\u011c\u0653\3\2\2\2\u011e\u0655\3\2\2\2\u0120")
        buf.write("\u067c\3\2\2\2\u0122\u067e\3\2\2\2\u0124\u0680\3\2\2\2")
        buf.write("\u0126\u0682\3\2\2\2\u0128\u0686\3\2\2\2\u012a\u0688\3")
        buf.write("\2\2\2\u012c\u068c\3\2\2\2\u012e\u0690\3\2\2\2\u0130\u0692")
        buf.write("\3\2\2\2\u0132\u0694\3\2\2\2\u0134\u0698\3\2\2\2\u0136")
        buf.write("\u069a\3\2\2\2\u0138\u06a0\3\2\2\2\u013a\u06a4\3\2\2\2")
        buf.write("\u013c\u06aa\3\2\2\2\u013e\u06ac\3\2\2\2\u0140\u06b2\3")
        buf.write("\2\2\2\u0142\u06c8\3\2\2\2\u0144\u06ca\3\2\2\2\u0146\u06ce")
        buf.write("\3\2\2\2\u0148\u06d0\3\2\2\2\u014a\u06d2\3\2\2\2\u014c")
        buf.write("\u06d4\3\2\2\2\u014e\u06d9\3\2\2\2\u0150\u06de\3\2\2\2")
        buf.write("\u0152\u06e5\3\2\2\2\u0154\u06fb\3\2\2\2\u0156\u06fd\3")
        buf.write("\2\2\2\u0158\u0701\3\2\2\2\u015a\u0705\3\2\2\2\u015c\u070b")
        buf.write("\3\2\2\2\u015e\u070d\3\2\2\2\u0160\u070f\3\2\2\2\u0162")
        buf.write("\u0713\3\2\2\2\u0164\u071e\3\2\2\2\u0166\u0720\3\2\2\2")
        buf.write("\u0168\u0724\3\2\2\2\u016a\u0726\3\2\2\2\u016c\u0728\3")
        buf.write("\2\2\2\u016e\u0746\3\2\2\2\u0170\u0748\3\2\2\2\u0172\u074e")
        buf.write("\3\2\2\2\u0174\u075b\3\2\2\2\u0176\u075d\3\2\2\2\u0178")
        buf.write("\u0763\3\2\2\2\u017a\u0767\3\2\2\2\u017c\u076d\3\2\2\2")
        buf.write("\u017e\u076f\3\2\2\2\u0180\u078c\3\2\2\2\u0182\u078e\3")
        buf.write("\2\2\2\u0184\u0792\3\2\2\2\u0186\u07af\3\2\2\2\u0188\u07b1")
        buf.write("\3\2\2\2\u018a\u07b5\3\2\2\2\u018c\u07be\3\2\2\2\u018e")
        buf.write("\u07c0\3\2\2\2\u0190\u07c4\3\2\2\2\u0192\u07ce\3\2\2\2")
        buf.write("\u0194\u07d0\3\2\2\2\u0196\u07d4\3\2\2\2\u0198\u07d7\3")
        buf.write("\2\2\2\u019a\u07d9\3\2\2\2\u019c\u07e3\3\2\2\2\u019e\u07e5")
        buf.write("\3\2\2\2\u01a0\u07e9\3\2\2\2\u01a2\u07ed\3\2\2\2\u01a4")
        buf.write("\u07ef\3\2\2\2\u01a6\u07f1\3\2\2\2\u01a8\u0807\3\2\2\2")
        buf.write("\u01aa\u0809\3\2\2\2\u01ac\u080d\3\2\2\2\u01ae\u0811\3")
        buf.write("\2\2\2\u01b0\u0814\3\2\2\2\u01b2\u0818\3\2\2\2\u01b4\u0822")
        buf.write("\3\2\2\2\u01b6\u0824\3\2\2\2\u01b8\u0828\3\2\2\2\u01ba")
        buf.write("\u082c\3\2\2\2\u01bc\u082e\3\2\2\2\u01be\u0830\3\2\2\2")
        buf.write("\u01c0\u0834\3\2\2\2\u01c2\u0836\3\2\2\2\u01c4\u0838\3")
        buf.write("\2\2\2\u01c6\u083b\3\2\2\2\u01c8\u083d\3\2\2\2\u01ca\u0841")
        buf.write("\3\2\2\2\u01cc\u0843\3\2\2\2\u01ce\u0847\3\2\2\2\u01d0")
        buf.write("\u084c\3\2\2\2\u01d2\u0850\3\2\2\2\u01d4\u0854\3\2\2\2")
        buf.write("\u01d6\u0858\3\2\2\2\u01d8\u085a\3\2\2\2\u01da\u085e\3")
        buf.write("\2\2\2\u01dc\u0862\3\2\2\2\u01de\u0866\3\2\2\2\u01e0\u0870")
        buf.write("\3\2\2\2\u01e2\u0886\3\2\2\2\u01e4\u0888\3\2\2\2\u01e6")
        buf.write("\u088a\3\2\2\2\u01e8\u088f\3\2\2\2\u01ea\u0894\3\2\2\2")
        buf.write("\u01ec\u089a\3\2\2\2\u01ee\u089e\3\2\2\2\u01f0\u08a0\3")
        buf.write("\2\2\2\u01f2\u08a4\3\2\2\2\u01f4\u08a6\3\2\2\2\u01f6\u08a8")
        buf.write("\3\2\2\2\u01f8\u08b3\3\2\2\2\u01fa\u08b5\3\2\2\2\u01fc")
        buf.write("\u08b7\3\2\2\2\u01fe\u08bb\3\2\2\2\u0200\u08bd\3\2\2\2")
        buf.write("\u0202\u08c1\3\2\2\2\u0204\u08c5\3\2\2\2\u0206\u08c7\3")
        buf.write("\2\2\2\u0208\u08cb\3\2\2\2\u020a\u08cd\3\2\2\2\u020c\u08d1")
        buf.write("\3\2\2\2\u020e\u08d8\3\2\2\2\u0210\u08da\3\2\2\2\u0212")
        buf.write("\u08de\3\2\2\2\u0214\u08e6\3\2\2\2\u0216\u08f3\3\2\2\2")
        buf.write("\u0218\u08f5\3\2\2\2\u021a\u08f9\3\2\2\2\u021c\u08ff\3")
        buf.write("\2\2\2\u021e\u0901\3\2\2\2\u0220\u0905\3\2\2\2\u0222\u090c")
        buf.write("\3\2\2\2\u0224\u0917\3\2\2\2\u0226\u091b\3\2\2\2\u0228")
        buf.write("\u091d\3\2\2\2\u022a\u091f\3\2\2\2\u022c\u0923\3\2\2\2")
        buf.write("\u022e\u0925\3\2\2\2\u0230\u0927\3\2\2\2\u0232\u092b\3")
        buf.write("\2\2\2\u0234\u0931\3\2\2\2\u0236\u0933\3\2\2\2\u0238\u093e")
        buf.write("\3\2\2\2\u023a\u0940\3\2\2\2\u023c\u0942\3\2\2\2\u023e")
        buf.write("\u0952\3\2\2\2\u0240\u0954\3\2\2\2\u0242\u0956\3\2\2\2")
        buf.write("\u0244\u096f\3\2\2\2\u0246\u0971\3\2\2\2\u0248\u0977\3")
        buf.write("\2\2\2\u024a\u0992\3\2\2\2\u024c\u0994\3\2\2\2\u024e\u0998")
        buf.write("\3\2\2\2\u0250\u09a3\3\2\2\2\u0252\u09a5\3\2\2\2\u0254")
        buf.write("\u09a9\3\2\2\2\u0256\u09c1\3\2\2\2\u0258\u09c3\3\2\2\2")
        buf.write("\u025a\u09cb\3\2\2\2\u025c\u09e3\3\2\2\2\u025e\u09e5\3")
        buf.write("\2\2\2\u0260\u09ed\3\2\2\2\u0262\u0a05\3\2\2\2\u0264\u0a07")
        buf.write("\3\2\2\2\u0266\u0a0f\3\2\2\2\u0268\u0a13\3\2\2\2\u026a")
        buf.write("\u0a16\3\2\2\2\u026c\u0a1c\3\2\2\2\u026e\u0a20\3\2\2\2")
        buf.write("\u0270\u0a23\3\2\2\2\u0272\u0a27\3\2\2\2\u0274\u0a2b\3")
        buf.write("\2\2\2\u0276\u0a30\3\2\2\2\u0278\u0a3c\3\2\2\2\u027a\u0a42")
        buf.write("\3\2\2\2\u027c\u0a46\3\2\2\2\u027e\u0a4c\3\2\2\2\u0280")
        buf.write("\u0a4e\3\2\2\2\u0282\u0a50\3\2\2\2\u0284\u0a52\3\2\2\2")
        buf.write("\u0286\u0a54\3\2\2\2\u0288\u0a56\3\2\2\2\u028a\u0a58\3")
        buf.write("\2\2\2\u028c\u0a5a\3\2\2\2\u028e\u0a5c\3\2\2\2\u0290\u0a5e")
        buf.write("\3\2\2\2\u0292\u0a60\3\2\2\2\u0294\u0a68\3\2\2\2\u0296")
        buf.write("\u0a6a\3\2\2\2\u0298\u0a71\3\2\2\2\u029a\u0a75\3\2\2\2")
        buf.write("\u029c\u0a77\3\2\2\2\u029e\u0a79\3\2\2\2\u02a0\u0a7d\3")
        buf.write("\2\2\2\u02a2\u0a7f\3\2\2\2\u02a4\u0a83\3\2\2\2\u02a6\u0a89")
        buf.write("\3\2\2\2\u02a8\u0a91\3\2\2\2\u02aa\u0a9b\3\2\2\2\u02ac")
        buf.write("\u0a9d\3\2\2\2\u02ae\u0ac1\3\2\2\2\u02b0\u0ac3\3\2\2\2")
        buf.write("\u02b2\u0ac7\3\2\2\2\u02b4\u0acd\3\2\2\2\u02b6\u0ad5\3")
        buf.write("\2\2\2\u02b8\u0adf\3\2\2\2\u02ba\u0ae1\3\2\2\2\u02bc\u0ae3")
        buf.write("\3\2\2\2\u02be\u0aeb\3\2\2\2\u02c0\u0af3\3\2\2\2\u02c2")
        buf.write("\u0afb\3\2\2\2\u02c4\u0b03\3\2\2\2\u02c6\u0b0b\3\2\2\2")
        buf.write("\u02c8\u0b13\3\2\2\2\u02ca\u0b1b\3\2\2\2\u02cc\u0b24\3")
        buf.write("\2\2\2\u02ce\u0b26\3\2\2\2\u02d0\u0b2f\3\2\2\2\u02d2\u0b31")
        buf.write("\3\2\2\2\u02d4\u0b39\3\2\2\2\u02d6\u0b46\3\2\2\2\u02d8")
        buf.write("\u0b4e\3\2\2\2\u02da\u0b50\3\2\2\2\u02dc\u0b52\3\2\2\2")
        buf.write("\u02de\u0b5a\3\2\2\2\u02e0\u0b5c\3\2\2\2\u02e2\u0b63\3")
        buf.write("\2\2\2\u02e4\u0b65\3\2\2\2\u02e6\u0b67\3\2\2\2\u02e8\u0b69")
        buf.write("\3\2\2\2\u02ea\u0b6b\3\2\2\2\u02ec\u02ed\5\4\3\2\u02ed")
        buf.write("\u02ef\5\6\4\2\u02ee\u02f0\5\b\5\2\u02ef\u02ee\3\2\2\2")
        buf.write("\u02ef\u02f0\3\2\2\2\u02f0\u02f2\3\2\2\2\u02f1\u02f3\5")
        buf.write("\f\7\2\u02f2\u02f1\3\2\2\2\u02f3\u02f4\3\2\2\2\u02f4\u02f2")
        buf.write("\3\2\2\2\u02f4\u02f5\3\2\2\2\u02f5\u02f6\3\2\2\2\u02f6")
        buf.write("\u02f7\7\2\2\3\u02f7\3\3\2\2\2\u02f8\u02f9\7\u0089\2\2")
        buf.write("\u02f9\u02fa\5\u02e4\u0173\2\u02fa\5\3\2\2\2\u02fb\u02fc")
        buf.write("\7\u0096\2\2\u02fc\u02fd\5\n\6\2\u02fd\7\3\2\2\2\u02fe")
        buf.write("\u02ff\7\u0114\2\2\u02ff\u0300\5\u02e2\u0172\2\u0300\t")
        buf.write("\3\2\2\2\u0301\u0306\7\u0120\2\2\u0302\u0303\7|\2\2\u0303")
        buf.write("\u0305\7\u0120\2\2\u0304\u0302\3\2\2\2\u0305\u0308\3\2")
        buf.write("\2\2\u0306\u0304\3\2\2\2\u0306\u0307\3\2\2\2\u0307\13")
        buf.write("\3\2\2\2\u0308\u0306\3\2\2\2\u0309\u030d\5\16\b\2\u030a")
        buf.write("\u030d\5\20\t\2\u030b\u030d\5\22\n\2\u030c\u0309\3\2\2")
        buf.write("\2\u030c\u030a\3\2\2\2\u030c\u030b\3\2\2\2\u030d\r\3\2")
        buf.write("\2\2\u030e\u030f\7\u0120\2\2\u030f\u0310\7}\2\2\u0310")
        buf.write("\17\3\2\2\2\u0311\u0315\5\24\13\2\u0312\u0315\5\u00c0")
        buf.write("a\2\u0313\u0315\5\u0082B\2\u0314\u0311\3\2\2\2\u0314\u0312")
        buf.write("\3\2\2\2\u0314\u0313\3\2\2\2\u0315\u0316\3\2\2\2\u0316")
        buf.write("\u0317\7p\2\2\u0317\u031a\3\2\2\2\u0318\u031a\5p9\2\u0319")
        buf.write("\u0314\3\2\2\2\u0319\u0318\3\2\2\2\u031a\21\3\2\2\2\u031b")
        buf.write("\u031c\5\26\f\2\u031c\23\3\2\2\2\u031d\u0320\5P)\2\u031e")
        buf.write("\u0320\5\u0088E\2\u031f\u031d\3\2\2\2\u031f\u031e\3\2")
        buf.write("\2\2\u0320\25\3\2\2\2\u0321\u0330\5\30\r\2\u0322\u0324")
        buf.write("\58\35\2\u0323\u0325\7p\2\2\u0324\u0323\3\2\2\2\u0324")
        buf.write("\u0325\3\2\2\2\u0325\u0330\3\2\2\2\u0326\u0330\5t;\2\u0327")
        buf.write("\u0329\7s\2\2\u0328\u032a\5\f\7\2\u0329\u0328\3\2\2\2")
        buf.write("\u032a\u032b\3\2\2\2\u032b\u0329\3\2\2\2\u032b\u032c\3")
        buf.write("\2\2\2\u032c\u032d\3\2\2\2\u032d\u032e\7~\2\2\u032e\u0330")
        buf.write("\3\2\2\2\u032f\u0321\3\2\2\2\u032f\u0322\3\2\2\2\u032f")
        buf.write("\u0326\3\2\2\2\u032f\u0327\3\2\2\2\u0330\27\3\2\2\2\u0331")
        buf.write("\u0332\5\32\16\2\u0332\31\3\2\2\2\u0333\u0335\t\2\2\2")
        buf.write("\u0334\u0333\3\2\2\2\u0334\u0335\3\2\2\2\u0335\u0336\3")
        buf.write("\2\2\2\u0336\u0337\7\u00f0\2\2\u0337\u033d\5\34\17\2\u0338")
        buf.write("\u033a\7r\2\2\u0339\u033b\5\36\20\2\u033a\u0339\3\2\2")
        buf.write("\2\u033a\u033b\3\2\2\2\u033b\u033c\3\2\2\2\u033c\u033e")
        buf.write("\7{\2\2\u033d\u0338\3\2\2\2\u033d\u033e\3\2\2\2\u033e")
        buf.write("\u0340\3\2\2\2\u033f\u0341\5b\62\2\u0340\u033f\3\2\2\2")
        buf.write("\u0340\u0341\3\2\2\2\u0341\u0342\3\2\2\2\u0342\u0343\5")
        buf.write("*\26\2\u0343\33\3\2\2\2\u0344\u0345\7\u0120\2\2\u0345")
        buf.write("\35\3\2\2\2\u0346\u034b\5 \21\2\u0347\u0348\7|\2\2\u0348")
        buf.write("\u034a\5 \21\2\u0349\u0347\3\2\2\2\u034a\u034d\3\2\2\2")
        buf.write("\u034b\u0349\3\2\2\2\u034b\u034c\3\2\2\2\u034c\37\3\2")
        buf.write("\2\2\u034d\u034b\3\2\2\2\u034e\u0350\5\"\22\2\u034f\u0351")
        buf.write("\5$\23\2\u0350\u034f\3\2\2\2\u0350\u0351\3\2\2\2\u0351")
        buf.write("\u0352\3\2\2\2\u0352\u0353\5(\25\2\u0353\u0355\7\u0120")
        buf.write("\2\2\u0354\u0356\5\u0092J\2\u0355\u0354\3\2\2\2\u0355")
        buf.write("\u0356\3\2\2\2\u0356\u0358\3\2\2\2\u0357\u0359\7\u0120")
        buf.write("\2\2\u0358\u0357\3\2\2\2\u0358\u0359\3\2\2\2\u0359\u035b")
        buf.write("\3\2\2\2\u035a\u035c\5(\25\2\u035b\u035a\3\2\2\2\u035b")
        buf.write("\u035c\3\2\2\2\u035c\u035e\3\2\2\2\u035d\u035f\5$\23\2")
        buf.write("\u035e\u035d\3\2\2\2\u035e\u035f\3\2\2\2\u035f\u0361\3")
        buf.write("\2\2\2\u0360\u0362\5\u0092J\2\u0361\u0360\3\2\2\2\u0361")
        buf.write("\u0362\3\2\2\2\u0362!\3\2\2\2\u0363\u0364\7\u00b6\2\2")
        buf.write("\u0364#\3\2\2\2\u0365\u0366\7\u0110\2\2\u0366\u0367\5")
        buf.write("&\24\2\u0367%\3\2\2\2\u0368\u036c\5\u02e6\u0174\2\u0369")
        buf.write("\u036c\5\u02e8\u0175\2\u036a\u036c\5\u02ea\u0176\2\u036b")
        buf.write("\u0368\3\2\2\2\u036b\u0369\3\2\2\2\u036b\u036a\3\2\2\2")
        buf.write("\u036c\'\3\2\2\2\u036d\u0370\5,\27\2\u036e\u0370\5\64")
        buf.write("\33\2\u036f\u036d\3\2\2\2\u036f\u036e\3\2\2\2\u0370)\3")
        buf.write("\2\2\2\u0371\u0375\7s\2\2\u0372\u0374\5\f\7\2\u0373\u0372")
        buf.write("\3\2\2\2\u0374\u0377\3\2\2\2\u0375\u0373\3\2\2\2\u0375")
        buf.write("\u0376\3\2\2\2\u0376\u0378\3\2\2\2\u0377\u0375\3\2\2\2")
        buf.write("\u0378\u037c\7~\2\2\u0379\u037b\5\f\7\2\u037a\u0379\3")
        buf.write("\2\2\2\u037b\u037e\3\2\2\2\u037c\u037a\3\2\2\2\u037c\u037d")
        buf.write("\3\2\2\2\u037d+\3\2\2\2\u037e\u037c\3\2\2\2\u037f\u0380")
        buf.write("\5.\30\2\u0380-\3\2\2\2\u0381\u0382\t\3\2\2\u0382/\3\2")
        buf.write("\2\2\u0383\u0384\5\62\32\2\u0384\u0385\5,\27\2\u0385\61")
        buf.write("\3\2\2\2\u0386\u0387\t\4\2\2\u0387\63\3\2\2\2\u0388\u0389")
        buf.write("\5\66\34\2\u0389\65\3\2\2\2\u038a\u038b\t\5\2\2\u038b")
        buf.write("\67\3\2\2\2\u038c\u038d\5:\36\2\u038d9\3\2\2\2\u038e\u0390")
        buf.write("\t\6\2\2\u038f\u038e\3\2\2\2\u038f\u0390\3\2\2\2\u0390")
        buf.write("\u0391\3\2\2\2\u0391\u0397\7\u00e1\2\2\u0392\u0394\7r")
        buf.write("\2\2\u0393\u0395\5> \2\u0394\u0393\3\2\2\2\u0394\u0395")
        buf.write("\3\2\2\2\u0395\u0396\3\2\2\2\u0396\u0398\7{\2\2\u0397")
        buf.write("\u0392\3\2\2\2\u0397\u0398\3\2\2\2\u0398\u0399\3\2\2\2")
        buf.write("\u0399\u039f\5<\37\2\u039a\u039c\7r\2\2\u039b\u039d\5")
        buf.write("F$\2\u039c\u039b\3\2\2\2\u039c\u039d\3\2\2\2\u039d\u039e")
        buf.write("\3\2\2\2\u039e\u03a0\7{\2\2\u039f\u039a\3\2\2\2\u039f")
        buf.write("\u03a0\3\2\2\2\u03a0\u03a2\3\2\2\2\u03a1\u03a3\5N(\2\u03a2")
        buf.write("\u03a1\3\2\2\2\u03a2\u03a3\3\2\2\2\u03a3;\3\2\2\2\u03a4")
        buf.write("\u03a5\7\u0120\2\2\u03a5=\3\2\2\2\u03a6\u03ab\5@!\2\u03a7")
        buf.write("\u03a8\7|\2\2\u03a8\u03aa\5@!\2\u03a9\u03a7\3\2\2\2\u03aa")
        buf.write("\u03ad\3\2\2\2\u03ab\u03a9\3\2\2\2\u03ab\u03ac\3\2\2\2")
        buf.write("\u03ac?\3\2\2\2\u03ad\u03ab\3\2\2\2\u03ae\u03b0\5B\"\2")
        buf.write("\u03af\u03b1\5$\23\2\u03b0\u03af\3\2\2\2\u03b0\u03b1\3")
        buf.write("\2\2\2\u03b1\u03b2\3\2\2\2\u03b2\u03b3\5D#\2\u03b3\u03b5")
        buf.write("\7\u0120\2\2\u03b4\u03b6\5\u0092J\2\u03b5\u03b4\3\2\2")
        buf.write("\2\u03b5\u03b6\3\2\2\2\u03b6A\3\2\2\2\u03b7\u03b8\t\7")
        buf.write("\2\2\u03b8C\3\2\2\2\u03b9\u03ba\5,\27\2\u03baE\3\2\2\2")
        buf.write("\u03bb\u03c0\5H%\2\u03bc\u03bd\7|\2\2\u03bd\u03bf\5H%")
        buf.write("\2\u03be\u03bc\3\2\2\2\u03bf\u03c2\3\2\2\2\u03c0\u03be")
        buf.write("\3\2\2\2\u03c0\u03c1\3\2\2\2\u03c1\u03c4\3\2\2\2\u03c2")
        buf.write("\u03c0\3\2\2\2\u03c3\u03c5\7z\2\2\u03c4\u03c3\3\2\2\2")
        buf.write("\u03c4\u03c5\3\2\2\2\u03c5G\3\2\2\2\u03c6\u03c8\5J&\2")
        buf.write("\u03c7\u03c9\5$\23\2\u03c8\u03c7\3\2\2\2\u03c8\u03c9\3")
        buf.write("\2\2\2\u03c9\u03ca\3\2\2\2\u03ca\u03cb\5L\'\2\u03cb\u03cd")
        buf.write("\7\u0120\2\2\u03cc\u03ce\5\u0092J\2\u03cd\u03cc\3\2\2")
        buf.write("\2\u03cd\u03ce\3\2\2\2\u03ceI\3\2\2\2\u03cf\u03d0\t\7")
        buf.write("\2\2\u03d0K\3\2\2\2\u03d1\u03d2\5,\27\2\u03d2M\3\2\2\2")
        buf.write("\u03d3\u03d7\7s\2\2\u03d4\u03d6\5\f\7\2\u03d5\u03d4\3")
        buf.write("\2\2\2\u03d6\u03d9\3\2\2\2\u03d7\u03d5\3\2\2\2\u03d7\u03d8")
        buf.write("\3\2\2\2\u03d8\u03da\3\2\2\2\u03d9\u03d7\3\2\2\2\u03da")
        buf.write("\u03db\7~\2\2\u03dbO\3\2\2\2\u03dc\u03e0\5R*\2\u03dd\u03e0")
        buf.write("\5X-\2\u03de\u03e0\5V,\2\u03df\u03dc\3\2\2\2\u03df\u03dd")
        buf.write("\3\2\2\2\u03df\u03de\3\2\2\2\u03e0Q\3\2\2\2\u03e1\u03e2")
        buf.write("\5\16\b\2\u03e2\u03e3\7\u0104\2\2\u03e3\u03e4\5T+\2\u03e4")
        buf.write("\u03e5\7p\2\2\u03e5S\3\2\2\2\u03e6\u03eb\5\u02ac\u0157")
        buf.write("\2\u03e7\u03e8\7|\2\2\u03e8\u03ea\5\u02ac\u0157\2\u03e9")
        buf.write("\u03e7\3\2\2\2\u03ea\u03ed\3\2\2\2\u03eb\u03e9\3\2\2\2")
        buf.write("\u03eb\u03ec\3\2\2\2\u03ecU\3\2\2\2\u03ed\u03eb\3\2\2")
        buf.write("\2\u03ee\u03ef\5\16\b\2\u03ef\u03f0\7\u0101\2\2\u03f0")
        buf.write("\u03f1\5T+\2\u03f1W\3\2\2\2\u03f2\u03f3\5\16\b\2\u03f3")
        buf.write("\u03f9\7\u0102\2\2\u03f4\u03f6\7r\2\2\u03f5\u03f7\5Z.")
        buf.write("\2\u03f6\u03f5\3\2\2\2\u03f6\u03f7\3\2\2\2\u03f7\u03f8")
        buf.write("\3\2\2\2\u03f8\u03fa\7{\2\2\u03f9\u03f4\3\2\2\2\u03f9")
        buf.write("\u03fa\3\2\2\2\u03fa\u03fb\3\2\2\2\u03fb\u0401\7\u0121")
        buf.write("\2\2\u03fc\u03fe\7r\2\2\u03fd\u03ff\5Z.\2\u03fe\u03fd")
        buf.write("\3\2\2\2\u03fe\u03ff\3\2\2\2\u03ff\u0400\3\2\2\2\u0400")
        buf.write("\u0402\7{\2\2\u0401\u03fc\3\2\2\2\u0401\u0402\3\2\2\2")
        buf.write("\u0402Y\3\2\2\2\u0403\u0408\5\\/\2\u0404\u0405\7|\2\2")
        buf.write("\u0405\u0407\5\\/\2\u0406\u0404\3\2\2\2\u0407\u040a\3")
        buf.write("\2\2\2\u0408\u0406\3\2\2\2\u0408\u0409\3\2\2\2\u0409[")
        buf.write("\3\2\2\2\u040a\u0408\3\2\2\2\u040b\u040d\5^\60\2\u040c")
        buf.write("\u040e\5$\23\2\u040d\u040c\3\2\2\2\u040d\u040e\3\2\2\2")
        buf.write("\u040e\u040f\3\2\2\2\u040f\u0410\5`\61\2\u0410\u0412\7")
        buf.write("\u0121\2\2\u0411\u0413\5\u0092J\2\u0412\u0411\3\2\2\2")
        buf.write("\u0412\u0413\3\2\2\2\u0413]\3\2\2\2\u0414\u0415\t\7\2")
        buf.write("\2\u0415_\3\2\2\2\u0416\u0417\5,\27\2\u0417a\3\2\2\2\u0418")
        buf.write("\u041a\5d\63\2\u0419\u0418\3\2\2\2\u041a\u041b\3\2\2\2")
        buf.write("\u041b\u0419\3\2\2\2\u041b\u041c\3\2\2\2\u041cc\3\2\2")
        buf.write("\2\u041d\u0424\5f\64\2\u041e\u0424\5h\65\2\u041f\u0424")
        buf.write("\5j\66\2\u0420\u0424\5l\67\2\u0421\u0424\5n8\2\u0422\u0424")
        buf.write("\5p9\2\u0423\u041d\3\2\2\2\u0423\u041e\3\2\2\2\u0423\u041f")
        buf.write("\3\2\2\2\u0423\u0420\3\2\2\2\u0423\u0421\3\2\2\2\u0423")
        buf.write("\u0422\3\2\2\2\u0424e\3\2\2\2\u0425\u0426\7\u00c8\2\2")
        buf.write("\u0426\u0427\5\u02e2\u0172\2\u0427g\3\2\2\2\u0428\u0429")
        buf.write("\7\u00c7\2\2\u0429\u0430\5\u02e2\u0172\2\u042a\u042b\7")
        buf.write("|\2\2\u042b\u042e\5\u02e2\u0172\2\u042c\u042d\7|\2\2\u042d")
        buf.write("\u042f\5\u02e2\u0172\2\u042e\u042c\3\2\2\2\u042e\u042f")
        buf.write("\3\2\2\2\u042f\u0431\3\2\2\2\u0430\u042a\3\2\2\2\u0430")
        buf.write("\u0431\3\2\2\2\u0431i\3\2\2\2\u0432\u0433\7\u00ad\2\2")
        buf.write("\u0433\u043a\5\u02e2\u0172\2\u0434\u0435\7|\2\2\u0435")
        buf.write("\u0438\5\u02e2\u0172\2\u0436\u0437\7|\2\2\u0437\u0439")
        buf.write("\5\u02e2\u0172\2\u0438\u0436\3\2\2\2\u0438\u0439\3\2\2")
        buf.write("\2\u0439\u043b\3\2\2\2\u043a\u0434\3\2\2\2\u043a\u043b")
        buf.write("\3\2\2\2\u043bk\3\2\2\2\u043c\u043d\7\u00c5\2\2\u043d")
        buf.write("\u043e\5\u02e2\u0172\2\u043em\3\2\2\2\u043f\u0440\7\u00c5")
        buf.write("\2\2\u0440\u0441\5\u02e2\u0172\2\u0441o\3\2\2\2\u0442")
        buf.write("\u0443\7\u00b4\2\2\u0443\u0444\5r:\2\u0444\u0445\7p\2")
        buf.write("\2\u0445q\3\2\2\2\u0446\u0447\7\u00bd\2\2\u0447s\3\2\2")
        buf.write("\2\u0448\u044d\5v<\2\u0449\u044d\5x=\2\u044a\u044d\5z")
        buf.write(">\2\u044b\u044d\5\u0080A\2\u044c\u0448\3\2\2\2\u044c\u0449")
        buf.write("\3\2\2\2\u044c\u044a\3\2\2\2\u044c\u044b\3\2\2\2\u044d")
        buf.write("u\3\2\2\2\u044e\u044f\7\u00f3\2\2\u044fw\3\2\2\2\u0450")
        buf.write("\u0451\7\u00e7\2\2\u0451\u0452\5\u02e2\u0172\2\u0452\u0453")
        buf.write("\7\u00be\2\2\u0453\u0458\3\2\2\2\u0454\u0455\7|\2\2\u0455")
        buf.write("\u0457\5\u02e2\u0172\2\u0456\u0454\3\2\2\2\u0457\u045a")
        buf.write("\3\2\2\2\u0458\u0456\3\2\2\2\u0458\u0459\3\2\2\2\u0459")
        buf.write("y\3\2\2\2\u045a\u0458\3\2\2\2\u045b\u045c\7\u009e\2\2")
        buf.write("\u045c\u045d\5|?\2\u045d\u0461\7s\2\2\u045e\u0460\5~@")
        buf.write("\2\u045f\u045e\3\2\2\2\u0460\u0463\3\2\2\2\u0461\u045f")
        buf.write("\3\2\2\2\u0461\u0462\3\2\2\2\u0462\u0464\3\2\2\2\u0463")
        buf.write("\u0461\3\2\2\2\u0464\u0465\7~\2\2\u0465{\3\2\2\2\u0466")
        buf.write("\u0472\7\u0120\2\2\u0467\u0472\7g\2\2\u0468\u0472\7h\2")
        buf.write("\2\u0469\u0472\7i\2\2\u046a\u046d\7j\2\2\u046b\u046c\7")
        buf.write("q\2\2\u046c\u046e\5\u02e2\u0172\2\u046d\u046b\3\2\2\2")
        buf.write("\u046d\u046e\3\2\2\2\u046e\u0472\3\2\2\2\u046f\u0472\7")
        buf.write("k\2\2\u0470\u0472\7l\2\2\u0471\u0466\3\2\2\2\u0471\u0467")
        buf.write("\3\2\2\2\u0471\u0468\3\2\2\2\u0471\u0469\3\2\2\2\u0471")
        buf.write("\u046a\3\2\2\2\u0471\u046f\3\2\2\2\u0471\u0470\3\2\2\2")
        buf.write("\u0472}\3\2\2\2\u0473\u0480\5\u00a4S\2\u0474\u0481\5\u02e2")
        buf.write("\u0172\2\u0475\u0481\7\u0120\2\2\u0476\u0481\7g\2\2\u0477")
        buf.write("\u0481\7h\2\2\u0478\u0481\7i\2\2\u0479\u047c\7j\2\2\u047a")
        buf.write("\u047b\7q\2\2\u047b\u047d\5\u02e2\u0172\2\u047c\u047a")
        buf.write("\3\2\2\2\u047c\u047d\3\2\2\2\u047d\u0481\3\2\2\2\u047e")
        buf.write("\u0481\7k\2\2\u047f\u0481\7l\2\2\u0480\u0474\3\2\2\2\u0480")
        buf.write("\u0475\3\2\2\2\u0480\u0476\3\2\2\2\u0480\u0477\3\2\2\2")
        buf.write("\u0480\u0478\3\2\2\2\u0480\u0479\3\2\2\2\u0480\u047e\3")
        buf.write("\2\2\2\u0480\u047f\3\2\2\2\u0481\177\3\2\2\2\u0482\u0483")
        buf.write("\7\u00d0\2\2\u0483\u0484\5\u02e2\u0172\2\u0484\u0485\5")
        buf.write("\u02e2\u0172\2\u0485\u0486\5\u02e2\u0172\2\u0486\u0081")
        buf.write("\3\2\2\2\u0487\u048a\5\u0084C\2\u0488\u048a\5\u0086D\2")
        buf.write("\u0489\u0487\3\2\2\2\u0489\u0488\3\2\2\2\u048a\u0083\3")
        buf.write("\2\2\2\u048b\u048c\7\u00ec\2\2\u048c\u048d\5\u0088E\2")
        buf.write("\u048d\u0085\3\2\2\2\u048e\u048f\7\u0088\2\2\u048f\u0490")
        buf.write("\5\u0088E\2\u0490\u0087\3\2\2\2\u0491\u0492\5\u008aF\2")
        buf.write("\u0492\u0089\3\2\2\2\u0493\u0495\5\u00a8U\2\u0494\u0496")
        buf.write("\5$\23\2\u0495\u0494\3\2\2\2\u0495\u0496\3\2\2\2\u0496")
        buf.write("\u0497\3\2\2\2\u0497\u0498\5\u008cG\2\u0498\u04a6\3\2")
        buf.write("\2\2\u0499\u049b\5\u00acW\2\u049a\u049c\5$\23\2\u049b")
        buf.write("\u049a\3\2\2\2\u049b\u049c\3\2\2\2\u049c\u049d\3\2\2\2")
        buf.write("\u049d\u049e\5\u008eH\2\u049e\u04a6\3\2\2\2\u049f\u04a1")
        buf.write("\5\u00aeX\2\u04a0\u04a2\5$\23\2\u04a1\u04a0\3\2\2\2\u04a1")
        buf.write("\u04a2\3\2\2\2\u04a2\u04a3\3\2\2\2\u04a3\u04a4\5\u008e")
        buf.write("H\2\u04a4\u04a6\3\2\2\2\u04a5\u0493\3\2\2\2\u04a5\u0499")
        buf.write("\3\2\2\2\u04a5\u049f\3\2\2\2\u04a6\u008b\3\2\2\2\u04a7")
        buf.write("\u04a8\5\u00a4S\2\u04a8\u04ad\5\u0090I\2\u04a9\u04aa\7")
        buf.write("|\2\2\u04aa\u04ac\5\u0090I\2\u04ab\u04a9\3\2\2\2\u04ac")
        buf.write("\u04af\3\2\2\2\u04ad\u04ab\3\2\2\2\u04ad\u04ae\3\2\2\2")
        buf.write("\u04ae\u008d\3\2\2\2\u04af\u04ad\3\2\2\2\u04b0\u04b1\5")
        buf.write("\u00a4S\2\u04b1\u04b6\5\u009cO\2\u04b2\u04b3\7|\2\2\u04b3")
        buf.write("\u04b5\5\u009cO\2\u04b4\u04b2\3\2\2\2\u04b5\u04b8\3\2")
        buf.write("\2\2\u04b6\u04b4\3\2\2\2\u04b6\u04b7\3\2\2\2\u04b7\u008f")
        buf.write("\3\2\2\2\u04b8\u04b6\3\2\2\2\u04b9\u04bc\5\u0098M\2\u04ba")
        buf.write("\u04bd\5\u0092J\2\u04bb\u04bd\5\u0096L\2\u04bc\u04ba\3")
        buf.write("\2\2\2\u04bc\u04bb\3\2\2\2\u04bc\u04bd\3\2\2\2\u04bd\u0091")
        buf.write("\3\2\2\2\u04be\u04bf\5\u0094K\2\u04bf\u0093\3\2\2\2\u04c0")
        buf.write("\u04c2\7t\2\2\u04c1\u04c3\5\u02e2\u0172\2\u04c2\u04c1")
        buf.write("\3\2\2\2\u04c2\u04c3\3\2\2\2\u04c3\u04c4\3\2\2\2\u04c4")
        buf.write("\u04c6\7\177\2\2\u04c5\u04c0\3\2\2\2\u04c6\u04c7\3\2\2")
        buf.write("\2\u04c7\u04c5\3\2\2\2\u04c7\u04c8\3\2\2\2\u04c8\u0095")
        buf.write("\3\2\2\2\u04c9\u04ca\7y\2\2\u04ca\u04cb\5\u02e2\u0172")
        buf.write("\2\u04cb\u04cc\7x\2\2\u04cc\u04cf\3\2\2\2\u04cd\u04cf")
        buf.write("\5\u02e2\u0172\2\u04ce\u04c9\3\2\2\2\u04ce\u04cd\3\2\2")
        buf.write("\2\u04cf\u0097\3\2\2\2\u04d0\u04d3\7\u0120\2\2\u04d1\u04d3")
        buf.write("\5\u009aN\2\u04d2\u04d0\3\2\2\2\u04d2\u04d1\3\2\2\2\u04d3")
        buf.write("\u0099\3\2\2\2\u04d4\u04d5\t\b\2\2\u04d5\u009b\3\2\2\2")
        buf.write("\u04d6\u04df\5\u0098M\2\u04d7\u04d8\5\u0092J\2\u04d8\u04d9")
        buf.write("\5\u009eP\2\u04d9\u04e0\3\2\2\2\u04da\u04db\7y\2\2\u04db")
        buf.write("\u04dc\5\u02e2\u0172\2\u04dc\u04dd\7x\2\2\u04dd\u04e0")
        buf.write("\3\2\2\2\u04de\u04e0\3\2\2\2\u04df\u04d7\3\2\2\2\u04df")
        buf.write("\u04da\3\2\2\2\u04df\u04de\3\2\2\2\u04e0\u009d\3\2\2\2")
        buf.write("\u04e1\u04e2\7o\2\2\u04e2\u04e4\5\u00a0Q\2\u04e3\u04e1")
        buf.write("\3\2\2\2\u04e3\u04e4\3\2\2\2\u04e4\u009f\3\2\2\2\u04e5")
        buf.write("\u04e9\5\u00a2R\2\u04e6\u04e9\5\u02b8\u015d\2\u04e7\u04e9")
        buf.write("\5\u0098M\2\u04e8\u04e5\3\2\2\2\u04e8\u04e6\3\2\2\2\u04e8")
        buf.write("\u04e7\3\2\2\2\u04e9\u00a1\3\2\2\2\u04ea\u04f3\7s\2\2")
        buf.write("\u04eb\u04f0\5\u00a0Q\2\u04ec\u04ed\7|\2\2\u04ed\u04ef")
        buf.write("\5\u00a0Q\2\u04ee\u04ec\3\2\2\2\u04ef\u04f2\3\2\2\2\u04f0")
        buf.write("\u04ee\3\2\2\2\u04f0\u04f1\3\2\2\2\u04f1\u04f4\3\2\2\2")
        buf.write("\u04f2\u04f0\3\2\2\2\u04f3\u04eb\3\2\2\2\u04f3\u04f4\3")
        buf.write("\2\2\2\u04f4\u04f5\3\2\2\2\u04f5\u04f6\7~\2\2\u04f6\u00a3")
        buf.write("\3\2\2\2\u04f7\u04fb\5,\27\2\u04f8\u04fb\5\60\31\2\u04f9")
        buf.write("\u04fb\5\64\33\2\u04fa\u04f7\3\2\2\2\u04fa\u04f8\3\2\2")
        buf.write("\2\u04fa\u04f9\3\2\2\2\u04fb\u00a5\3\2\2\2\u04fc\u04ff")
        buf.write("\5\u02ac\u0157\2\u04fd\u04ff\5\u0092J\2\u04fe\u04fc\3")
        buf.write("\2\2\2\u04fe\u04fd\3\2\2\2\u04ff\u00a7\3\2\2\2\u0500\u0501")
        buf.write("\5\u00aaV\2\u0501\u00a9\3\2\2\2\u0502\u050a\5$\23\2\u0503")
        buf.write("\u050a\5\u00b4[\2\u0504\u050a\5\u00b6\\\2\u0505\u050a")
        buf.write("\5\u00b8]\2\u0506\u050a\5\u00ba^\2\u0507\u050a\5\u00bc")
        buf.write("_\2\u0508\u050a\5\u00be`\2\u0509\u0502\3\2\2\2\u0509\u0503")
        buf.write("\3\2\2\2\u0509\u0504\3\2\2\2\u0509\u0505\3\2\2\2\u0509")
        buf.write("\u0506\3\2\2\2\u0509\u0507\3\2\2\2\u0509\u0508\3\2\2\2")
        buf.write("\u050a\u00ab\3\2\2\2\u050b\u050c\5\u00b2Z\2\u050c\u00ad")
        buf.write("\3\2\2\2\u050d\u050e\5\u00b0Y\2\u050e\u00af\3\2\2\2\u050f")
        buf.write("\u0510\7\u00f9\2\2\u0510\u00b1\3\2\2\2\u0511\u0512\7\u00dd")
        buf.write("\2\2\u0512\u00b3\3\2\2\2\u0513\u0514\7\u00cf\2\2\u0514")
        buf.write("\u00b5\3\2\2\2\u0515\u0516\7\u00b6\2\2\u0516\u00b7\3\2")
        buf.write("\2\2\u0517\u0518\7\u00ae\2\2\u0518\u00b9\3\2\2\2\u0519")
        buf.write("\u051a\7\u009d\2\2\u051a\u00bb\3\2\2\2\u051b\u051c\7\u009b")
        buf.write("\2\2\u051c\u00bd\3\2\2\2\u051d\u051e\7\u0095\2\2\u051e")
        buf.write("\u00bf\3\2\2\2\u051f\u0520\5\u00c2b\2\u0520\u00c1\3\2")
        buf.write("\2\2\u0521\u0523\5\u00c4c\2\u0522\u0521\3\2\2\2\u0522")
        buf.write("\u0523\3\2\2\2\u0523\u0574\3\2\2\2\u0524\u0575\5\u00c6")
        buf.write("d\2\u0525\u0575\5\u00ccg\2\u0526\u0575\5\u00d2j\2\u0527")
        buf.write("\u0575\5\u00d8m\2\u0528\u0575\5\u00dep\2\u0529\u0575\5")
        buf.write("\u00e4s\2\u052a\u0575\5\u00fe\u0080\2\u052b\u0575\5\u0104")
        buf.write("\u0083\2\u052c\u0575\5\u010a\u0086\2\u052d\u0575\5\u0110")
        buf.write("\u0089\2\u052e\u0575\5\u0116\u008c\2\u052f\u0575\5\u011c")
        buf.write("\u008f\2\u0530\u0575\5\u011e\u0090\2\u0531\u0575\5\u0126")
        buf.write("\u0094\2\u0532\u0575\5\u012c\u0097\2\u0533\u0575\5\u0132")
        buf.write("\u009a\2\u0534\u0575\5\u0138\u009d\2\u0535\u0575\5\u013e")
        buf.write("\u00a0\2\u0536\u0575\5\u014c\u00a7\2\u0537\u0575\5\u0152")
        buf.write("\u00aa\2\u0538\u0575\5\u0158\u00ad\2\u0539\u0575\5\u015e")
        buf.write("\u00b0\2\u053a\u0575\5\u0160\u00b1\2\u053b\u0575\5\u0166")
        buf.write("\u00b4\2\u053c\u0575\5\u016c\u00b7\2\u053d\u0575\5\u0172")
        buf.write("\u00ba\2\u053e\u0575\5\u0178\u00bd\2\u053f\u0575\5\u017e")
        buf.write("\u00c0\2\u0540\u0575\5\u0184\u00c3\2\u0541\u0575\5\u018a")
        buf.write("\u00c6\2\u0542\u0575\5\u0190\u00c9\2\u0543\u0575\5\u0196")
        buf.write("\u00cc\2\u0544\u0575\5\u019a\u00ce\2\u0545\u0575\5\u01a0")
        buf.write("\u00d1\2\u0546\u0575\5\u01a6\u00d4\2\u0547\u0575\5\u01ac")
        buf.write("\u00d7\2\u0548\u0575\5\u01b2\u00da\2\u0549\u0575\5\u01b8")
        buf.write("\u00dd\2\u054a\u0575\5\u01be\u00e0\2\u054b\u0575\5\u01c4")
        buf.write("\u00e3\2\u054c\u0575\5\u01c8\u00e5\2\u054d\u0575\5\u01ce")
        buf.write("\u00e8\2\u054e\u0575\5\u01d4\u00eb\2\u054f\u0575\5\u01da")
        buf.write("\u00ee\2\u0550\u0575\5\u01e0\u00f1\2\u0551\u0575\5\u01e6")
        buf.write("\u00f4\2\u0552\u0575\5\u01ec\u00f7\2\u0553\u0575\5\u01f2")
        buf.write("\u00fa\2\u0554\u0575\5\u01f6\u00fc\2\u0555\u0575\5\u01fc")
        buf.write("\u00ff\2\u0556\u0575\5\u0202\u0102\2\u0557\u0575\5\u0208")
        buf.write("\u0105\2\u0558\u0575\5\u0216\u010c\2\u0559\u0575\5\u0224")
        buf.write("\u0113\2\u055a\u0575\5\u022a\u0116\2\u055b\u0575\5\u0230")
        buf.write("\u0119\2\u055c\u0575\5\u0236\u011c\2\u055d\u0575\5\u023c")
        buf.write("\u011f\2\u055e\u0575\5\u0242\u0122\2\u055f\u0575\5\u0248")
        buf.write("\u0125\2\u0560\u0575\5\u024e\u0128\2\u0561\u0575\5\u0254")
        buf.write("\u012b\2\u0562\u0575\5\u025a\u012e\2\u0563\u0575\5\u0260")
        buf.write("\u0131\2\u0564\u0575\5\u0266\u0134\2\u0565\u0575\5\u026c")
        buf.write("\u0137\2\u0566\u0575\5\u0272\u013a\2\u0567\u0575\5\u0278")
        buf.write("\u013d\2\u0568\u0575\5\u027e\u0140\2\u0569\u0575\5\u0280")
        buf.write("\u0141\2\u056a\u0575\5\u0282\u0142\2\u056b\u0575\5\u0284")
        buf.write("\u0143\2\u056c\u0575\5\u0286\u0144\2\u056d\u0575\5\u0288")
        buf.write("\u0145\2\u056e\u0575\5\u028a\u0146\2\u056f\u0575\5\u028c")
        buf.write("\u0147\2\u0570\u0575\5\u028e\u0148\2\u0571\u0575\5\u0290")
        buf.write("\u0149\2\u0572\u0575\5\u0292\u014a\2\u0573\u0575\5\u0298")
        buf.write("\u014d\2\u0574\u0524\3\2\2\2\u0574\u0525\3\2\2\2\u0574")
        buf.write("\u0526\3\2\2\2\u0574\u0527\3\2\2\2\u0574\u0528\3\2\2\2")
        buf.write("\u0574\u0529\3\2\2\2\u0574\u052a\3\2\2\2\u0574\u052b\3")
        buf.write("\2\2\2\u0574\u052c\3\2\2\2\u0574\u052d\3\2\2\2\u0574\u052e")
        buf.write("\3\2\2\2\u0574\u052f\3\2\2\2\u0574\u0530\3\2\2\2\u0574")
        buf.write("\u0531\3\2\2\2\u0574\u0532\3\2\2\2\u0574\u0533\3\2\2\2")
        buf.write("\u0574\u0534\3\2\2\2\u0574\u0535\3\2\2\2\u0574\u0536\3")
        buf.write("\2\2\2\u0574\u0537\3\2\2\2\u0574\u0538\3\2\2\2\u0574\u0539")
        buf.write("\3\2\2\2\u0574\u053a\3\2\2\2\u0574\u053b\3\2\2\2\u0574")
        buf.write("\u053c\3\2\2\2\u0574\u053d\3\2\2\2\u0574\u053e\3\2\2\2")
        buf.write("\u0574\u053f\3\2\2\2\u0574\u0540\3\2\2\2\u0574\u0541\3")
        buf.write("\2\2\2\u0574\u0542\3\2\2\2\u0574\u0543\3\2\2\2\u0574\u0544")
        buf.write("\3\2\2\2\u0574\u0545\3\2\2\2\u0574\u0546\3\2\2\2\u0574")
        buf.write("\u0547\3\2\2\2\u0574\u0548\3\2\2\2\u0574\u0549\3\2\2\2")
        buf.write("\u0574\u054a\3\2\2\2\u0574\u054b\3\2\2\2\u0574\u054c\3")
        buf.write("\2\2\2\u0574\u054d\3\2\2\2\u0574\u054e\3\2\2\2\u0574\u054f")
        buf.write("\3\2\2\2\u0574\u0550\3\2\2\2\u0574\u0551\3\2\2\2\u0574")
        buf.write("\u0552\3\2\2\2\u0574\u0553\3\2\2\2\u0574\u0554\3\2\2\2")
        buf.write("\u0574\u0555\3\2\2\2\u0574\u0556\3\2\2\2\u0574\u0557\3")
        buf.write("\2\2\2\u0574\u0558\3\2\2\2\u0574\u0559\3\2\2\2\u0574\u055a")
        buf.write("\3\2\2\2\u0574\u055b\3\2\2\2\u0574\u055c\3\2\2\2\u0574")
        buf.write("\u055d\3\2\2\2\u0574\u055e\3\2\2\2\u0574\u055f\3\2\2\2")
        buf.write("\u0574\u0560\3\2\2\2\u0574\u0561\3\2\2\2\u0574\u0562\3")
        buf.write("\2\2\2\u0574\u0563\3\2\2\2\u0574\u0564\3\2\2\2\u0574\u0565")
        buf.write("\3\2\2\2\u0574\u0566\3\2\2\2\u0574\u0567\3\2\2\2\u0574")
        buf.write("\u0568\3\2\2\2\u0574\u0569\3\2\2\2\u0574\u056a\3\2\2\2")
        buf.write("\u0574\u056b\3\2\2\2\u0574\u056c\3\2\2\2\u0574\u056d\3")
        buf.write("\2\2\2\u0574\u056e\3\2\2\2\u0574\u056f\3\2\2\2\u0574\u0570")
        buf.write("\3\2\2\2\u0574\u0571\3\2\2\2\u0574\u0572\3\2\2\2\u0574")
        buf.write("\u0573\3\2\2\2\u0575\u00c3\3\2\2\2\u0576\u0578\7\u0122")
        buf.write("\2\2\u0577\u0579\7v\2\2\u0578\u0577\3\2\2\2\u0578\u0579")
        buf.write("\3\2\2\2\u0579\u057a\3\2\2\2\u057a\u057b\7\u0120\2\2\u057b")
        buf.write("\u00c5\3\2\2\2\u057c\u057d\7\3\2\2\u057d\u057e\5\u00c8")
        buf.write("e\2\u057e\u057f\5\u00caf\2\u057f\u00c7\3\2\2\2\u0580\u0587")
        buf.write("\t\t\2\2\u0581\u0583\7\u00e4\2\2\u0582\u0581\3\2\2\2\u0582")
        buf.write("\u0583\3\2\2\2\u0583\u0584\3\2\2\2\u0584\u0587\7\u00ea")
        buf.write("\2\2\u0585\u0587\7\u00e8\2\2\u0586\u0580\3\2\2\2\u0586")
        buf.write("\u0582\3\2\2\2\u0586\u0585\3\2\2\2\u0587\u00c9\3\2\2\2")
        buf.write("\u0588\u0589\5\u029e\u0150\2\u0589\u058a\7|\2\2\u058a")
        buf.write("\u058b\5\u02a0\u0151\2\u058b\u00cb\3\2\2\2\u058c\u058d")
        buf.write("\7\4\2\2\u058d\u058e\5\u00ceh\2\u058e\u058f\5\u00d0i\2")
        buf.write("\u058f\u00cd\3\2\2\2\u0590\u0591\7\u009f\2\2\u0591\u0594")
        buf.write("\7\u00a3\2\2\u0592\u0594\t\n\2\2\u0593\u0590\3\2\2\2\u0593")
        buf.write("\u0592\3\2\2\2\u0594\u0598\3\2\2\2\u0595\u0596\7\u00ff")
        buf.write("\2\2\u0596\u0598\t\13\2\2\u0597\u0593\3\2\2\2\u0597\u0595")
        buf.write("\3\2\2\2\u0598\u05a8\3\2\2\2\u0599\u059b\t\f\2\2\u059a")
        buf.write("\u0599\3\2\2\2\u059a\u059b\3\2\2\2\u059b\u059d\3\2\2\2")
        buf.write("\u059c\u059e\7\u00e4\2\2\u059d\u059c\3\2\2\2\u059d\u059e")
        buf.write("\3\2\2\2\u059e\u05a0\3\2\2\2\u059f\u05a1\7\u009f\2\2\u05a0")
        buf.write("\u059f\3\2\2\2\u05a0\u05a1\3\2\2\2\u05a1\u05a2\3\2\2\2")
        buf.write("\u05a2\u05a8\7\u00ea\2\2\u05a3\u05a5\t\f\2\2\u05a4\u05a3")
        buf.write("\3\2\2\2\u05a4\u05a5\3\2\2\2\u05a5\u05a6\3\2\2\2\u05a6")
        buf.write("\u05a8\7\u00e8\2\2\u05a7\u0597\3\2\2\2\u05a7\u059a\3\2")
        buf.write("\2\2\u05a7\u05a4\3\2\2\2\u05a8\u00cf\3\2\2\2\u05a9\u05aa")
        buf.write("\5\u029e\u0150\2\u05aa\u05ab\7|\2\2\u05ab\u05ac\5\u02a2")
        buf.write("\u0152\2\u05ac\u00d1\3\2\2\2\u05ad\u05ae\7\5\2\2\u05ae")
        buf.write("\u05af\5\u00d4k\2\u05af\u05b0\5\u00d6l\2\u05b0\u00d3\3")
        buf.write("\2\2\2\u05b1\u05b3\7\u00ff\2\2\u05b2\u05b1\3\2\2\2\u05b2")
        buf.write("\u05b3\3\2\2\2\u05b3\u05b4\3\2\2\2\u05b4\u05b5\t\r\2\2")
        buf.write("\u05b5\u00d5\3\2\2\2\u05b6\u05b7\5\u029e\u0150\2\u05b7")
        buf.write("\u05b8\7|\2\2\u05b8\u05b9\5\u02a2\u0152\2\u05b9\u00d7")
        buf.write("\3\2\2\2\u05ba\u05bb\7\6\2\2\u05bb\u05bc\5\u00dan\2\u05bc")
        buf.write("\u05bd\5\u00dco\2\u05bd\u00d9\3\2\2\2\u05be\u05bf\t\16")
        buf.write("\2\2\u05bf\u00db\3\2\2\2\u05c0\u05c1\5\u02b2\u015a\2\u05c1")
        buf.write("\u00dd\3\2\2\2\u05c2\u05c3\7\7\2\2\u05c3\u05c4\5\u00e0")
        buf.write("q\2\u05c4\u05c5\5\u00e2r\2\u05c5\u00df\3\2\2\2\u05c6\u05c8")
        buf.write("\t\17\2\2\u05c7\u05c6\3\2\2\2\u05c7\u05c8\3\2\2\2\u05c8")
        buf.write("\u05c9\3\2\2\2\u05c9\u05ca\t\20\2\2\u05ca\u05cb\t\21\2")
        buf.write("\2\u05cb\u00e1\3\2\2\2\u05cc\u05cd\5\u02ac\u0157\2\u05cd")
        buf.write("\u05ce\7|\2\2\u05ce\u05cf\7t\2\2\u05cf\u05d0\5\u02ac\u0157")
        buf.write("\2\u05d0\u05d1\7\177\2\2\u05d1\u05d2\7|\2\2\u05d2\u05d5")
        buf.write("\5\u02ac\u0157\2\u05d3\u05d4\7|\2\2\u05d4\u05d6\5\u02ac")
        buf.write("\u0157\2\u05d5\u05d3\3\2\2\2\u05d5\u05d6\3\2\2\2\u05d6")
        buf.write("\u00e3\3\2\2\2\u05d7\u05dc\5\u00e6t\2\u05d8\u05dc\5\u00ec")
        buf.write("w\2\u05d9\u05dc\5\u00f2z\2\u05da\u05dc\5\u00f8}\2\u05db")
        buf.write("\u05d7\3\2\2\2\u05db\u05d8\3\2\2\2\u05db\u05d9\3\2\2\2")
        buf.write("\u05db\u05da\3\2\2\2\u05dc\u00e5\3\2\2\2\u05dd\u05de\7")
        buf.write("\b\2\2\u05de\u05df\5\u00e8u\2\u05df\u05e0\5\u00eav\2\u05e0")
        buf.write("\u00e7\3\2\2\2\u05e1\u05e2\7\u0098\2\2\u05e2\u00e9\3\2")
        buf.write("\2\2\u05e3\u05e6\5\u02ac\u0157\2\u05e4\u05e5\7|\2\2\u05e5")
        buf.write("\u05e7\5\u02ac\u0157\2\u05e6\u05e4\3\2\2\2\u05e6\u05e7")
        buf.write("\3\2\2\2\u05e7\u00eb\3\2\2\2\u05e8\u05e9\7\b\2\2\u05e9")
        buf.write("\u05ea\5\u00eex\2\u05ea\u05eb\5\u00f0y\2\u05eb\u00ed\3")
        buf.write("\2\2\2\u05ec\u05ed\7\u010b\2\2\u05ed\u00ef\3\2\2\2\u05ee")
        buf.write("\u05ef\5\u02b0\u0159\2\u05ef\u00f1\3\2\2\2\u05f0\u05f1")
        buf.write("\7\b\2\2\u05f1\u05f2\5\u00f4{\2\u05f2\u05f3\5\u00f6|\2")
        buf.write("\u05f3\u00f3\3\2\2\2\u05f4\u05f5\7\u00af\2\2\u05f5\u05f6")
        buf.write("\7\u00b5\2\2\u05f6\u05f7\7\u0090\2\2\u05f7\u00f5\3\2\2")
        buf.write("\2\u05f8\u05f9\5\u02ac\u0157\2\u05f9\u05fa\7|\2\2\u05fa")
        buf.write("\u05fd\5\u02ac\u0157\2\u05fb\u05fc\7|\2\2\u05fc\u05fe")
        buf.write("\5\u02ac\u0157\2\u05fd\u05fb\3\2\2\2\u05fd\u05fe\3\2\2")
        buf.write("\2\u05fe\u05ff\3\2\2\2\u05ff\u0601\7|\2\2\u0600\u0602")
        buf.write("\7v\2\2\u0601\u0600\3\2\2\2\u0601\u0602\3\2\2\2\u0602")
        buf.write("\u0603\3\2\2\2\u0603\u0604\5\u02ac\u0157\2\u0604\u00f7")
        buf.write("\3\2\2\2\u0605\u0606\7\b\2\2\u0606\u0607\5\u00fa~\2\u0607")
        buf.write("\u0608\5\u00fc\177\2\u0608\u00f9\3\2\2\2\u0609\u060a\7")
        buf.write("\u00af\2\2\u060a\u060b\t\22\2\2\u060b\u060c\7\u00b3\2")
        buf.write("\2\u060c\u00fb\3\2\2\2\u060d\u060e\5\u02ac\u0157\2\u060e")
        buf.write("\u060f\7|\2\2\u060f\u0612\5\u02ac\u0157\2\u0610\u0611")
        buf.write("\7|\2\2\u0611\u0613\5\u02ac\u0157\2\u0612\u0610\3\2\2")
        buf.write("\2\u0612\u0613\3\2\2\2\u0613\u0614\3\2\2\2\u0614\u0616")
        buf.write("\7|\2\2\u0615\u0617\7v\2\2\u0616\u0615\3\2\2\2\u0616\u0617")
        buf.write("\3\2\2\2\u0617\u0618\3\2\2\2\u0618\u0619\5\u02ac\u0157")
        buf.write("\2\u0619\u00fd\3\2\2\2\u061a\u061b\7\t\2\2\u061b\u061c")
        buf.write("\5\u0100\u0081\2\u061c\u061d\5\u0102\u0082\2\u061d\u00ff")
        buf.write("\3\2\2\2\u061e\u061f\t\23\2\2\u061f\u0101\3\2\2\2\u0620")
        buf.write("\u0621\5\u029e\u0150\2\u0621\u0622\7|\2\2\u0622\u0623")
        buf.write("\5\u02a4\u0153\2\u0623\u0103\3\2\2\2\u0624\u0625\7\n\2")
        buf.write("\2\u0625\u0626\5\u0106\u0084\2\u0626\u0627\5\u0108\u0085")
        buf.write("\2\u0627\u0105\3\2\2\2\u0628\u0629\t\24\2\2\u0629\u0107")
        buf.write("\3\2\2\2\u062a\u062b\5\u029e\u0150\2\u062b\u062c\7|\2")
        buf.write("\2\u062c\u062d\5\u02a6\u0154\2\u062d\u0109\3\2\2\2\u062e")
        buf.write("\u062f\7\13\2\2\u062f\u0630\5\u010c\u0087\2\u0630\u0631")
        buf.write("\5\u010e\u0088\2\u0631\u010b\3\2\2\2\u0632\u0634\7\u009c")
        buf.write("\2\2\u0633\u0632\3\2\2\2\u0633\u0634\3\2\2\2\u0634\u0635")
        buf.write("\3\2\2\2\u0635\u0636\t\23\2\2\u0636\u010d\3\2\2\2\u0637")
        buf.write("\u0638\5\u029e\u0150\2\u0638\u0639\7|\2\2\u0639\u063a")
        buf.write("\5\u02a0\u0151\2\u063a\u010f\3\2\2\2\u063b\u063c\7\f\2")
        buf.write("\2\u063c\u063d\5\u0112\u008a\2\u063d\u063e\5\u0114\u008b")
        buf.write("\2\u063e\u0111\3\2\2\2\u063f\u0641\7\u008d\2\2\u0640\u063f")
        buf.write("\3\2\2\2\u0640\u0641\3\2\2\2\u0641\u0113\3\2\2\2\u0642")
        buf.write("\u0648\5\u02aa\u0156\2\u0643\u0644\5\u029e\u0150\2\u0644")
        buf.write("\u0645\7|\2\2\u0645\u0646\5\u02aa\u0156\2\u0646\u0648")
        buf.write("\3\2\2\2\u0647\u0642\3\2\2\2\u0647\u0643\3\2\2\2\u0648")
        buf.write("\u0115\3\2\2\2\u0649\u064a\7\r\2\2\u064a\u064b\5\u0118")
        buf.write("\u008d\2\u064b\u064c\5\u011a\u008e\2\u064c\u0117\3\2\2")
        buf.write("\2\u064d\u064e\t\24\2\2\u064e\u0119\3\2\2\2\u064f\u0650")
        buf.write("\5\u029e\u0150\2\u0650\u0651\7|\2\2\u0651\u0652\5\u02a0")
        buf.write("\u0151\2\u0652\u011b\3\2\2\2\u0653\u0654\7\16\2\2\u0654")
        buf.write("\u011d\3\2\2\2\u0655\u0656\7\17\2\2\u0656\u0663\5\u0120")
        buf.write("\u0091\2\u0657\u0658\7r\2\2\u0658\u065d\5\u02ac\u0157")
        buf.write("\2\u0659\u065a\7|\2\2\u065a\u065c\5\u02ac\u0157\2\u065b")
        buf.write("\u0659\3\2\2\2\u065c\u065f\3\2\2\2\u065d\u065b\3\2\2\2")
        buf.write("\u065d\u065e\3\2\2\2\u065e\u0660\3\2\2\2\u065f\u065d\3")
        buf.write("\2\2\2\u0660\u0661\7{\2\2\u0661\u0662\7|\2\2\u0662\u0664")
        buf.write("\3\2\2\2\u0663\u0657\3\2\2\2\u0663\u0664\3\2\2\2\u0664")
        buf.write("\u0665\3\2\2\2\u0665\u0672\5<\37\2\u0666\u0667\7|\2\2")
        buf.write("\u0667\u0668\7r\2\2\u0668\u066d\5\u02ac\u0157\2\u0669")
        buf.write("\u066a\7|\2\2\u066a\u066c\5\u02ac\u0157\2\u066b\u0669")
        buf.write("\3\2\2\2\u066c\u066f\3\2\2\2\u066d\u066b\3\2\2\2\u066d")
        buf.write("\u066e\3\2\2\2\u066e\u0670\3\2\2\2\u066f\u066d\3\2\2\2")
        buf.write("\u0670\u0671\7{\2\2\u0671\u0673\3\2\2\2\u0672\u0666\3")
        buf.write("\2\2\2\u0672\u0673\3\2\2\2\u0673\u0678\3\2\2\2\u0674\u0675")
        buf.write("\7|\2\2\u0675\u0679\5\u0122\u0092\2\u0676\u0677\7|\2\2")
        buf.write("\u0677\u0679\5\u0124\u0093\2\u0678\u0674\3\2\2\2\u0678")
        buf.write("\u0676\3\2\2\2\u0678\u0679\3\2\2\2\u0679\u011f\3\2\2\2")
        buf.write("\u067a\u067d\7\u008d\2\2\u067b\u067d\3\2\2\2\u067c\u067a")
        buf.write("\3\2\2\2\u067c\u067b\3\2\2\2\u067d\u0121\3\2\2\2\u067e")
        buf.write("\u067f\7\u0120\2\2\u067f\u0123\3\2\2\2\u0680\u0681\7\u0120")
        buf.write("\2\2\u0681\u0125\3\2\2\2\u0682\u0683\7\20\2\2\u0683\u0684")
        buf.write("\5\u0128\u0095\2\u0684\u0685\5\u012a\u0096\2\u0685\u0127")
        buf.write("\3\2\2\2\u0686\u0687\t\24\2\2\u0687\u0129\3\2\2\2\u0688")
        buf.write("\u0689\5\u029e\u0150\2\u0689\u068a\7|\2\2\u068a\u068b")
        buf.write("\5\u02a0\u0151\2\u068b\u012b\3\2\2\2\u068c\u068d\7\21")
        buf.write("\2\2\u068d\u068e\5\u012e\u0098\2\u068e\u068f\5\u0130\u0099")
        buf.write("\2\u068f\u012d\3\2\2\2\u0690\u0691\t\25\2\2\u0691\u012f")
        buf.write("\3\2\2\2\u0692\u0693\5\u02b0\u0159\2\u0693\u0131\3\2\2")
        buf.write("\2\u0694\u0695\7\22\2\2\u0695\u0696\5\u0134\u009b\2\u0696")
        buf.write("\u0697\5\u0136\u009c\2\u0697\u0133\3\2\2\2\u0698\u0699")
        buf.write("\t\26\2\2\u0699\u0135\3\2\2\2\u069a\u069b\5\u029e\u0150")
        buf.write("\2\u069b\u069c\7|\2\2\u069c\u069d\5\u029e\u0150\2\u069d")
        buf.write("\u069e\7|\2\2\u069e\u069f\5\u029e\u0150\2\u069f\u0137")
        buf.write("\3\2\2\2\u06a0\u06a1\7\23\2\2\u06a1\u06a2\5\u013a\u009e")
        buf.write("\2\u06a2\u06a3\5\u013c\u009f\2\u06a3\u0139\3\2\2\2\u06a4")
        buf.write("\u06a6\7\u010c\2\2\u06a5\u06a7\7\u00e4\2\2\u06a6\u06a5")
        buf.write("\3\2\2\2\u06a6\u06a7\3\2\2\2\u06a7\u06a8\3\2\2\2\u06a8")
        buf.write("\u06a9\7\u00ea\2\2\u06a9\u013b\3\2\2\2\u06aa\u06ab\5\u02b0")
        buf.write("\u0159\2\u06ab\u013d\3\2\2\2\u06ac\u06ad\7\24\2\2\u06ad")
        buf.write("\u06ae\5\u0140\u00a1\2\u06ae\u06af\5\u014a\u00a6\2\u06af")
        buf.write("\u013f\3\2\2\2\u06b0\u06b3\5\u0142\u00a2\2\u06b1\u06b3")
        buf.write("\5\u0146\u00a4\2\u06b2\u06b0\3\2\2\2\u06b2\u06b1\3\2\2")
        buf.write("\2\u06b3\u06b5\3\2\2\2\u06b4\u06b6\7\u00e4\2\2\u06b5\u06b4")
        buf.write("\3\2\2\2\u06b5\u06b6\3\2\2\2\u06b6\u06b8\3\2\2\2\u06b7")
        buf.write("\u06b9\7\u009f\2\2\u06b8\u06b7\3\2\2\2\u06b8\u06b9\3\2")
        buf.write("\2\2\u06b9\u06ba\3\2\2\2\u06ba\u06bb\t\27\2\2\u06bb\u06be")
        buf.write("\t\27\2\2\u06bc\u06bf\5\u0142\u00a2\2\u06bd\u06bf\5\u0146")
        buf.write("\u00a4\2\u06be\u06bc\3\2\2\2\u06be\u06bd\3\2\2\2\u06bf")
        buf.write("\u06c1\3\2\2\2\u06c0\u06c2\7\u00e4\2\2\u06c1\u06c0\3\2")
        buf.write("\2\2\u06c1\u06c2\3\2\2\2\u06c2\u06c4\3\2\2\2\u06c3\u06c5")
        buf.write("\7\u009f\2\2\u06c4\u06c3\3\2\2\2\u06c4\u06c5\3\2\2\2\u06c5")
        buf.write("\u0141\3\2\2\2\u06c6\u06c9\5\u0144\u00a3\2\u06c7\u06c9")
        buf.write("\3\2\2\2\u06c8\u06c6\3\2\2\2\u06c8\u06c7\3\2\2\2\u06c9")
        buf.write("\u0143\3\2\2\2\u06ca\u06cb\t\30\2\2\u06cb\u0145\3\2\2")
        buf.write("\2\u06cc\u06cf\5\u0148\u00a5\2\u06cd\u06cf\3\2\2\2\u06ce")
        buf.write("\u06cc\3\2\2\2\u06ce\u06cd\3\2\2\2\u06cf\u0147\3\2\2\2")
        buf.write("\u06d0\u06d1\t\f\2\2\u06d1\u0149\3\2\2\2\u06d2\u06d3\5")
        buf.write("\u02b0\u0159\2\u06d3\u014b\3\2\2\2\u06d4\u06d5\7\25\2")
        buf.write("\2\u06d5\u06d6\5\u014e\u00a8\2\u06d6\u06d7\5\u0150\u00a9")
        buf.write("\2\u06d7\u014d\3\2\2\2\u06d8\u06da\7\u0093\2\2\u06d9\u06d8")
        buf.write("\3\2\2\2\u06d9\u06da\3\2\2\2\u06da\u06db\3\2\2\2\u06db")
        buf.write("\u06dc\t\31\2\2\u06dc\u06dd\t\32\2\2\u06dd\u014f\3\2\2")
        buf.write("\2\u06de\u06df\5\u02ac\u0157\2\u06df\u06e0\7|\2\2\u06e0")
        buf.write("\u06e3\5\u02ac\u0157\2\u06e1\u06e2\7q\2\2\u06e2\u06e4")
        buf.write("\5\u02e2\u0172\2\u06e3\u06e1\3\2\2\2\u06e3\u06e4\3\2\2")
        buf.write("\2\u06e4\u0151\3\2\2\2\u06e5\u06e6\7\26\2\2\u06e6\u06e7")
        buf.write("\5\u0154\u00ab\2\u06e7\u06e8\5\u0156\u00ac\2\u06e8\u0153")
        buf.write("\3\2\2\2\u06e9\u06fc\t\n\2\2\u06ea\u06ec\7\u010c\2\2\u06eb")
        buf.write("\u06ed\7\u00e4\2\2\u06ec\u06eb\3\2\2\2\u06ec\u06ed\3\2")
        buf.write("\2\2\u06ed\u06ee\3\2\2\2\u06ee\u06fc\7\u00ea\2\2\u06ef")
        buf.write("\u06f1\7\u00e3\2\2\u06f0\u06f2\7\u00e4\2\2\u06f1\u06f0")
        buf.write("\3\2\2\2\u06f1\u06f2\3\2\2\2\u06f2\u06f3\3\2\2\2\u06f3")
        buf.write("\u06fc\7\u00ea\2\2\u06f4\u06f6\t\f\2\2\u06f5\u06f7\7\u00e4")
        buf.write("\2\2\u06f6\u06f5\3\2\2\2\u06f6\u06f7\3\2\2\2\u06f7\u06f8")
        buf.write("\3\2\2\2\u06f8\u06fc\7\u00ea\2\2\u06f9\u06fa\t\f\2\2\u06fa")
        buf.write("\u06fc\7\u00e8\2\2\u06fb\u06e9\3\2\2\2\u06fb\u06ea\3\2")
        buf.write("\2\2\u06fb\u06ef\3\2\2\2\u06fb\u06f4\3\2\2\2\u06fb\u06f9")
        buf.write("\3\2\2\2\u06fc\u0155\3\2\2\2\u06fd\u06fe\5\u029e\u0150")
        buf.write("\2\u06fe\u06ff\7|\2\2\u06ff\u0700\5\u02a2\u0152\2\u0700")
        buf.write("\u0157\3\2\2\2\u0701\u0702\7\27\2\2\u0702\u0703\5\u015a")
        buf.write("\u00ae\2\u0703\u0704\5\u015c\u00af\2\u0704\u0159\3\2\2")
        buf.write("\2\u0705\u0707\7\u010c\2\2\u0706\u0708\7\u00e4\2\2\u0707")
        buf.write("\u0706\3\2\2\2\u0707\u0708\3\2\2\2\u0708\u0709\3\2\2\2")
        buf.write("\u0709\u070a\7\u00ea\2\2\u070a\u015b\3\2\2\2\u070b\u070c")
        buf.write("\5\u02b0\u0159\2\u070c\u015d\3\2\2\2\u070d\u070e\7\30")
        buf.write("\2\2\u070e\u015f\3\2\2\2\u070f\u0710\7\31\2\2\u0710\u0711")
        buf.write("\5\u0162\u00b2\2\u0711\u0712\5\u0164\u00b3\2\u0712\u0161")
        buf.write("\3\2\2\2\u0713\u071c\t\f\2\2\u0714\u0716\7\u00e4\2\2\u0715")
        buf.write("\u0714\3\2\2\2\u0715\u0716\3\2\2\2\u0716\u0718\3\2\2\2")
        buf.write("\u0717\u0719\7\u009f\2\2\u0718\u0717\3\2\2\2\u0718\u0719")
        buf.write("\3\2\2\2\u0719\u071a\3\2\2\2\u071a\u071d\7\u00ea\2\2\u071b")
        buf.write("\u071d\7\u00e8\2\2\u071c\u0715\3\2\2\2\u071c\u071b\3\2")
        buf.write("\2\2\u071d\u0163\3\2\2\2\u071e\u071f\5\u02b4\u015b\2\u071f")
        buf.write("\u0165\3\2\2\2\u0720\u0721\7\32\2\2\u0721\u0722\5\u0168")
        buf.write("\u00b5\2\u0722\u0723\5\u016a\u00b6\2\u0723\u0167\3\2\2")
        buf.write("\2\u0724\u0725\t\33\2\2\u0725\u0169\3\2\2\2\u0726\u0727")
        buf.write("\5\u02b0\u0159\2\u0727\u016b\3\2\2\2\u0728\u0729\7\33")
        buf.write("\2\2\u0729\u072a\5\u016e\u00b8\2\u072a\u072b\5\u0170\u00b9")
        buf.write("\2\u072b\u016d\3\2\2\2\u072c\u072e\t\34\2\2\u072d\u072c")
        buf.write("\3\2\2\2\u072d\u072e\3\2\2\2\u072e\u0730\3\2\2\2\u072f")
        buf.write("\u0731\t\35\2\2\u0730\u072f\3\2\2\2\u0730\u0731\3\2\2")
        buf.write("\2\u0731\u0732\3\2\2\2\u0732\u0747\t\36\2\2\u0733\u0735")
        buf.write("\t\34\2\2\u0734\u0733\3\2\2\2\u0734\u0735\3\2\2\2\u0735")
        buf.write("\u0737\3\2\2\2\u0736\u0738\t\35\2\2\u0737\u0736\3\2\2")
        buf.write("\2\u0737\u0738\3\2\2\2\u0738\u0739\3\2\2\2\u0739\u073a")
        buf.write("\t\4\2\2\u073a\u0747\t\36\2\2\u073b\u073d\7\u0087\2\2")
        buf.write("\u073c\u073e\t\34\2\2\u073d\u073c\3\2\2\2\u073d\u073e")
        buf.write("\3\2\2\2\u073e\u073f\3\2\2\2\u073f\u0747\t\36\2\2\u0740")
        buf.write("\u0742\7\u0087\2\2\u0741\u0743\t\34\2\2\u0742\u0741\3")
        buf.write("\2\2\2\u0742\u0743\3\2\2\2\u0743\u0744\3\2\2\2\u0744\u0745")
        buf.write("\t\4\2\2\u0745\u0747\t\36\2\2\u0746\u072d\3\2\2\2\u0746")
        buf.write("\u0734\3\2\2\2\u0746\u073b\3\2\2\2\u0746\u0740\3\2\2\2")
        buf.write("\u0747\u016f\3\2\2\2\u0748\u0749\5\u02ac\u0157\2\u0749")
        buf.write("\u074a\7|\2\2\u074a\u074b\7t\2\2\u074b\u074c\5\u02ac\u0157")
        buf.write("\2\u074c\u074d\7\177\2\2\u074d\u0171\3\2\2\2\u074e\u074f")
        buf.write("\7\34\2\2\u074f\u0750\5\u0174\u00bb\2\u0750\u0751\5\u0176")
        buf.write("\u00bc\2\u0751\u0173\3\2\2\2\u0752\u0754\7\u00dd\2\2\u0753")
        buf.write("\u0752\3\2\2\2\u0753\u0754\3\2\2\2\u0754\u0755\3\2\2\2")
        buf.write("\u0755\u075c\t\36\2\2\u0756\u0758\7\u00dd\2\2\u0757\u0756")
        buf.write("\3\2\2\2\u0757\u0758\3\2\2\2\u0758\u0759\3\2\2\2\u0759")
        buf.write("\u075a\t\4\2\2\u075a\u075c\t\36\2\2\u075b\u0753\3\2\2")
        buf.write("\2\u075b\u0757\3\2\2\2\u075c\u0175\3\2\2\2\u075d\u075e")
        buf.write("\5\u02ac\u0157\2\u075e\u075f\7|\2\2\u075f\u0760\7t\2\2")
        buf.write("\u0760\u0761\5\u02ac\u0157\2\u0761\u0762\7\177\2\2\u0762")
        buf.write("\u0177\3\2\2\2\u0763\u0764\7\35\2\2\u0764\u0765\5\u017a")
        buf.write("\u00be\2\u0765\u0766\5\u017c\u00bf\2\u0766\u0179\3\2\2")
        buf.write("\2\u0767\u0769\7\u010c\2\2\u0768\u076a\7\u00e4\2\2\u0769")
        buf.write("\u0768\3\2\2\2\u0769\u076a\3\2\2\2\u076a\u076b\3\2\2\2")
        buf.write("\u076b\u076c\7\u00ea\2\2\u076c\u017b\3\2\2\2\u076d\u076e")
        buf.write("\5\u02b0\u0159\2\u076e\u017d\3\2\2\2\u076f\u0770\7\37")
        buf.write("\2\2\u0770\u0771\5\u0180\u00c1\2\u0771\u0772\5\u0182\u00c2")
        buf.write("\2\u0772\u017f\3\2\2\2\u0773\u0775\t\37\2\2\u0774\u0776")
        buf.write("\7\u00ff\2\2\u0775\u0774\3\2\2\2\u0775\u0776\3\2\2\2\u0776")
        buf.write("\u0777\3\2\2\2\u0777\u078d\t\n\2\2\u0778\u0779\7\u00d9")
        buf.write("\2\2\u0779\u077a\7\u009f\2\2\u077a\u078d\7\u00a3\2\2\u077b")
        buf.write("\u077d\7\u00e4\2\2\u077c\u077b\3\2\2\2\u077c\u077d\3\2")
        buf.write("\2\2\u077d\u077f\3\2\2\2\u077e\u0780\7\u009f\2\2\u077f")
        buf.write("\u077e\3\2\2\2\u077f\u0780\3\2\2\2\u0780\u0781\3\2\2\2")
        buf.write("\u0781\u078d\7\u00ea\2\2\u0782\u0784\t\f\2\2\u0783\u0785")
        buf.write("\7\u00e4\2\2\u0784\u0783\3\2\2\2\u0784\u0785\3\2\2\2\u0785")
        buf.write("\u0787\3\2\2\2\u0786\u0788\7\u009f\2\2\u0787\u0786\3\2")
        buf.write("\2\2\u0787\u0788\3\2\2\2\u0788\u0789\3\2\2\2\u0789\u078d")
        buf.write("\7\u00ea\2\2\u078a\u078b\t\f\2\2\u078b\u078d\7\u00e8\2")
        buf.write("\2\u078c\u0773\3\2\2\2\u078c\u0778\3\2\2\2\u078c\u077c")
        buf.write("\3\2\2\2\u078c\u0782\3\2\2\2\u078c\u078a\3\2\2\2\u078d")
        buf.write("\u0181\3\2\2\2\u078e\u078f\5\u029e\u0150\2\u078f\u0790")
        buf.write("\7|\2\2\u0790\u0791\5\u02a4\u0153\2\u0791\u0183\3\2\2")
        buf.write("\2\u0792\u0793\7 \2\2\u0793\u0794\5\u0186\u00c4\2\u0794")
        buf.write("\u0795\5\u0188\u00c5\2\u0795\u0185\3\2\2\2\u0796\u0798")
        buf.write("\t\37\2\2\u0797\u0799\7\u00ff\2\2\u0798\u0797\3\2\2\2")
        buf.write("\u0798\u0799\3\2\2\2\u0799\u079a\3\2\2\2\u079a\u07b0\t")
        buf.write("\n\2\2\u079b\u079c\7\u00d9\2\2\u079c\u079d\7\u009f\2\2")
        buf.write("\u079d\u07b0\7\u00a3\2\2\u079e\u07a0\7\u00e4\2\2\u079f")
        buf.write("\u079e\3\2\2\2\u079f\u07a0\3\2\2\2\u07a0\u07a2\3\2\2\2")
        buf.write("\u07a1\u07a3\7\u009f\2\2\u07a2\u07a1\3\2\2\2\u07a2\u07a3")
        buf.write("\3\2\2\2\u07a3\u07a4\3\2\2\2\u07a4\u07b0\7\u00ea\2\2\u07a5")
        buf.write("\u07a7\t\f\2\2\u07a6\u07a8\7\u00e4\2\2\u07a7\u07a6\3\2")
        buf.write("\2\2\u07a7\u07a8\3\2\2\2\u07a8\u07aa\3\2\2\2\u07a9\u07ab")
        buf.write("\7\u009f\2\2\u07aa\u07a9\3\2\2\2\u07aa\u07ab\3\2\2\2\u07ab")
        buf.write("\u07ac\3\2\2\2\u07ac\u07b0\7\u00ea\2\2\u07ad\u07ae\t\f")
        buf.write("\2\2\u07ae\u07b0\7\u00e8\2\2\u07af\u0796\3\2\2\2\u07af")
        buf.write("\u079b\3\2\2\2\u07af\u079f\3\2\2\2\u07af\u07a5\3\2\2\2")
        buf.write("\u07af\u07ad\3\2\2\2\u07b0\u0187\3\2\2\2\u07b1\u07b2\5")
        buf.write("\u029e\u0150\2\u07b2\u07b3\7|\2\2\u07b3\u07b4\5\u02a4")
        buf.write("\u0153\2\u07b4\u0189\3\2\2\2\u07b5\u07b6\7\36\2\2\u07b6")
        buf.write("\u07b7\5\u018c\u00c7\2\u07b7\u07b8\5\u018e\u00c8\2\u07b8")
        buf.write("\u018b\3\2\2\2\u07b9\u07ba\t \2\2\u07ba\u07bf\t\13\2\2")
        buf.write("\u07bb\u07bc\7\u00d9\2\2\u07bc\u07bd\7\u009f\2\2\u07bd")
        buf.write("\u07bf\7\u00a3\2\2\u07be\u07b9\3\2\2\2\u07be\u07bb\3\2")
        buf.write("\2\2\u07bf\u018d\3\2\2\2\u07c0\u07c1\5\u029e\u0150\2\u07c1")
        buf.write("\u07c2\7|\2\2\u07c2\u07c3\5\u02a4\u0153\2\u07c3\u018f")
        buf.write("\3\2\2\2\u07c4\u07c5\7!\2\2\u07c5\u07c6\5\u0192\u00ca")
        buf.write("\2\u07c6\u07c7\5\u0194\u00cb\2\u07c7\u0191\3\2\2\2\u07c8")
        buf.write("\u07cf\t\n\2\2\u07c9\u07cb\7\u00e4\2\2\u07ca\u07c9\3\2")
        buf.write("\2\2\u07ca\u07cb\3\2\2\2\u07cb\u07cc\3\2\2\2\u07cc\u07cf")
        buf.write("\7\u00ea\2\2\u07cd\u07cf\7\u00e8\2\2\u07ce\u07c8\3\2\2")
        buf.write("\2\u07ce\u07ca\3\2\2\2\u07ce\u07cd\3\2\2\2\u07cf\u0193")
        buf.write("\3\2\2\2\u07d0\u07d1\5\u029e\u0150\2\u07d1\u07d2\7|\2")
        buf.write("\2\u07d2\u07d3\5\u02a2\u0152\2\u07d3\u0195\3\2\2\2\u07d4")
        buf.write("\u07d5\7\"\2\2\u07d5\u07d6\5\u0198\u00cd\2\u07d6\u0197")
        buf.write("\3\2\2\2\u07d7\u07d8\t!\2\2\u07d8\u0199\3\2\2\2\u07d9")
        buf.write("\u07da\7#\2\2\u07da\u07db\5\u019c\u00cf\2\u07db\u07dc")
        buf.write("\5\u019e\u00d0\2\u07dc\u019b\3\2\2\2\u07dd\u07e4\t\n\2")
        buf.write("\2\u07de\u07e0\7\u00e4\2\2\u07df\u07de\3\2\2\2\u07df\u07e0")
        buf.write("\3\2\2\2\u07e0\u07e1\3\2\2\2\u07e1\u07e4\7\u00ea\2\2\u07e2")
        buf.write("\u07e4\7\u00e8\2\2\u07e3\u07dd\3\2\2\2\u07e3\u07df\3\2")
        buf.write("\2\2\u07e3\u07e2\3\2\2\2\u07e4\u019d\3\2\2\2\u07e5\u07e6")
        buf.write("\5\u029e\u0150\2\u07e6\u07e7\7|\2\2\u07e7\u07e8\5\u02a2")
        buf.write("\u0152\2\u07e8\u019f\3\2\2\2\u07e9\u07ea\7$\2\2\u07ea")
        buf.write("\u07eb\5\u01a2\u00d2\2\u07eb\u07ec\5\u01a4\u00d3\2\u07ec")
        buf.write("\u01a1\3\2\2\2\u07ed\u07ee\t\"\2\2\u07ee\u01a3\3\2\2\2")
        buf.write("\u07ef\u07f0\5\u02b0\u0159\2\u07f0\u01a5\3\2\2\2\u07f1")
        buf.write("\u07f2\7&\2\2\u07f2\u07f3\5\u01a8\u00d5\2\u07f3\u07f4")
        buf.write("\5\u01aa\u00d6\2\u07f4\u01a7\3\2\2\2\u07f5\u07f7\t\37")
        buf.write("\2\2\u07f6\u07f5\3\2\2\2\u07f6\u07f7\3\2\2\2\u07f7\u07f8")
        buf.write("\3\2\2\2\u07f8\u0808\t\n\2\2\u07f9\u07fb\t\f\2\2\u07fa")
        buf.write("\u07f9\3\2\2\2\u07fa\u07fb\3\2\2\2\u07fb\u07fd\3\2\2\2")
        buf.write("\u07fc\u07fe\7\u00e4\2\2\u07fd\u07fc\3\2\2\2\u07fd\u07fe")
        buf.write("\3\2\2\2\u07fe\u0800\3\2\2\2\u07ff\u0801\7\u009f\2\2\u0800")
        buf.write("\u07ff\3\2\2\2\u0800\u0801\3\2\2\2\u0801\u0802\3\2\2\2")
        buf.write("\u0802\u0808\7\u00ea\2\2\u0803\u0805\t\f\2\2\u0804\u0803")
        buf.write("\3\2\2\2\u0804\u0805\3\2\2\2\u0805\u0806\3\2\2\2\u0806")
        buf.write("\u0808\7\u00e8\2\2\u0807\u07f6\3\2\2\2\u0807\u07fa\3\2")
        buf.write("\2\2\u0807\u0804\3\2\2\2\u0808\u01a9\3\2\2\2\u0809\u080a")
        buf.write("\5\u029e\u0150\2\u080a\u080b\7|\2\2\u080b\u080c\5\u02a2")
        buf.write("\u0152\2\u080c\u01ab\3\2\2\2\u080d\u080e\7%\2\2\u080e")
        buf.write("\u080f\5\u01ae\u00d8\2\u080f\u0810\5\u01b0\u00d9\2\u0810")
        buf.write("\u01ad\3\2\2\2\u0811\u0812\t \2\2\u0812\u0813\t\13\2\2")
        buf.write("\u0813\u01af\3\2\2\2\u0814\u0815\5\u029e\u0150\2\u0815")
        buf.write("\u0816\7|\2\2\u0816\u0817\5\u02a2\u0152\2\u0817\u01b1")
        buf.write("\3\2\2\2\u0818\u0819\7\'\2\2\u0819\u081a\5\u01b4\u00db")
        buf.write("\2\u081a\u081b\5\u01b6\u00dc\2\u081b\u01b3\3\2\2\2\u081c")
        buf.write("\u0823\t\t\2\2\u081d\u081f\7\u00e4\2\2\u081e\u081d\3\2")
        buf.write("\2\2\u081e\u081f\3\2\2\2\u081f\u0820\3\2\2\2\u0820\u0823")
        buf.write("\7\u00ea\2\2\u0821\u0823\7\u00e8\2\2\u0822\u081c\3\2\2")
        buf.write("\2\u0822\u081e\3\2\2\2\u0822\u0821\3\2\2\2\u0823\u01b5")
        buf.write("\3\2\2\2\u0824\u0825\5\u029e\u0150\2\u0825\u0826\7|\2")
        buf.write("\2\u0826\u0827\5\u02a0\u0151\2\u0827\u01b7\3\2\2\2\u0828")
        buf.write("\u0829\7(\2\2\u0829\u082a\5\u01ba\u00de\2\u082a\u082b")
        buf.write("\5\u01bc\u00df\2\u082b\u01b9\3\2\2\2\u082c\u082d\t\16")
        buf.write("\2\2\u082d\u01bb\3\2\2\2\u082e\u082f\5\u02b0\u0159\2\u082f")
        buf.write("\u01bd\3\2\2\2\u0830\u0831\7)\2\2\u0831\u0832\5\u01c0")
        buf.write("\u00e1\2\u0832\u0833\5\u01c2\u00e2\2\u0833\u01bf\3\2\2")
        buf.write("\2\u0834\u0835\t\16\2\2\u0835\u01c1\3\2\2\2\u0836\u0837")
        buf.write("\5\u02b2\u015a\2\u0837\u01c3\3\2\2\2\u0838\u0839\7*\2")
        buf.write("\2\u0839\u083a\5\u01c6\u00e4\2\u083a\u01c5\3\2\2\2\u083b")
        buf.write("\u083c\5\u02ac\u0157\2\u083c\u01c7\3\2\2\2\u083d\u083e")
        buf.write("\7+\2\2\u083e\u083f\5\u01ca\u00e6\2\u083f\u0840\5\u01cc")
        buf.write("\u00e7\2\u0840\u01c9\3\2\2\2\u0841\u0842\t\24\2\2\u0842")
        buf.write("\u01cb\3\2\2\2\u0843\u0844\5\u029e\u0150\2\u0844\u0845")
        buf.write("\7|\2\2\u0845\u0846\5\u02a0\u0151\2\u0846\u01cd\3\2\2")
        buf.write("\2\u0847\u0848\7,\2\2\u0848\u0849\5\u01d0\u00e9\2\u0849")
        buf.write("\u084a\5\u01d2\u00ea\2\u084a\u01cf\3\2\2\2\u084b\u084d")
        buf.write("\t#\2\2\u084c\u084b\3\2\2\2\u084c\u084d\3\2\2\2\u084d")
        buf.write("\u084e\3\2\2\2\u084e\u084f\t$\2\2\u084f\u01d1\3\2\2\2")
        buf.write("\u0850\u0851\7t\2\2\u0851\u0852\5\u02ac\u0157\2\u0852")
        buf.write("\u0853\7\177\2\2\u0853\u01d3\3\2\2\2\u0854\u0855\7-\2")
        buf.write("\2\u0855\u0856\5\u01d6\u00ec\2\u0856\u0857\5\u01d8\u00ed")
        buf.write("\2\u0857\u01d5\3\2\2\2\u0858\u0859\7\u00d5\2\2\u0859\u01d7")
        buf.write("\3\2\2\2\u085a\u085b\7t\2\2\u085b\u085c\5\u02ac\u0157")
        buf.write("\2\u085c\u085d\7\177\2\2\u085d\u01d9\3\2\2\2\u085e\u085f")
        buf.write("\7.\2\2\u085f\u0860\5\u01dc\u00ef\2\u0860\u0861\5\u01de")
        buf.write("\u00f0\2\u0861\u01db\3\2\2\2\u0862\u0864\7\u0109\2\2\u0863")
        buf.write("\u0865\t%\2\2\u0864\u0863\3\2\2\2\u0864\u0865\3\2\2\2")
        buf.write("\u0865\u01dd\3\2\2\2\u0866\u0867\5\u029e\u0150\2\u0867")
        buf.write("\u0868\7|\2\2\u0868\u0869\5\u029e\u0150\2\u0869\u086a")
        buf.write("\7|\2\2\u086a\u086b\5\u029e\u0150\2\u086b\u086e\7|\2\2")
        buf.write("\u086c\u086f\5\u029e\u0150\2\u086d\u086f\5\u02e6\u0174")
        buf.write("\2\u086e\u086c\3\2\2\2\u086e\u086d\3\2\2\2\u086f\u01df")
        buf.write("\3\2\2\2\u0870\u0871\7/\2\2\u0871\u0872\5\u01e2\u00f2")
        buf.write("\2\u0872\u0873\5\u01e4\u00f3\2\u0873\u01e1\3\2\2\2\u0874")
        buf.write("\u0876\7\u010c\2\2\u0875\u0877\7\u00e4\2\2\u0876\u0875")
        buf.write("\3\2\2\2\u0876\u0877\3\2\2\2\u0877\u0878\3\2\2\2\u0878")
        buf.write("\u087a\7\u00ea\2\2\u0879\u087b\7\u00e4\2\2\u087a\u0879")
        buf.write("\3\2\2\2\u087a\u087b\3\2\2\2\u087b\u0887\3\2\2\2\u087c")
        buf.write("\u087e\t\f\2\2\u087d\u087f\7\u00e4\2\2\u087e\u087d\3\2")
        buf.write("\2\2\u087e\u087f\3\2\2\2\u087f\u0880\3\2\2\2\u0880\u0887")
        buf.write("\7\u00ea\2\2\u0881\u0882\t\f\2\2\u0882\u0887\7\u00e8\2")
        buf.write("\2\u0883\u0884\7\u010c\2\2\u0884\u0885\7\u00e4\2\2\u0885")
        buf.write("\u0887\7\u00e8\2\2\u0886\u0874\3\2\2\2\u0886\u087c\3\2")
        buf.write("\2\2\u0886\u0881\3\2\2\2\u0886\u0883\3\2\2\2\u0887\u01e3")
        buf.write("\3\2\2\2\u0888\u0889\5\u02b0\u0159\2\u0889\u01e5\3\2\2")
        buf.write("\2\u088a\u088b\7\60\2\2\u088b\u088c\5\u01e8\u00f5\2\u088c")
        buf.write("\u088d\5\u01ea\u00f6\2\u088d\u01e7\3\2\2\2\u088e\u0890")
        buf.write("\t\17\2\2\u088f\u088e\3\2\2\2\u088f\u0890\3\2\2\2\u0890")
        buf.write("\u0891\3\2\2\2\u0891\u0892\t&\2\2\u0892\u0893\t\21\2\2")
        buf.write("\u0893\u01e9\3\2\2\2\u0894\u0895\7t\2\2\u0895\u0896\5")
        buf.write("\u02ac\u0157\2\u0896\u0897\7\177\2\2\u0897\u0898\7|\2")
        buf.write("\2\u0898\u0899\5\u02ac\u0157\2\u0899\u01eb\3\2\2\2\u089a")
        buf.write("\u089b\7\61\2\2\u089b\u089c\5\u01ee\u00f8\2\u089c\u089d")
        buf.write("\5\u01f0\u00f9\2\u089d\u01ed\3\2\2\2\u089e\u089f\t\n\2")
        buf.write("\2\u089f\u01ef\3\2\2\2\u08a0\u08a1\5\u029e\u0150\2\u08a1")
        buf.write("\u08a2\7|\2\2\u08a2\u08a3\5\u02a2\u0152\2\u08a3\u01f1")
        buf.write("\3\2\2\2\u08a4\u08a5\7\62\2\2\u08a5\u01f3\3\2\2\2\u08a6")
        buf.write("\u08a7\7\u008d\2\2\u08a7\u01f5\3\2\2\2\u08a8\u08a9\7\63")
        buf.write("\2\2\u08a9\u08aa\5\u01f8\u00fd\2\u08aa\u08ab\5\u01fa\u00fe")
        buf.write("\2\u08ab\u01f7\3\2\2\2\u08ac\u08ae\7\u010c\2\2\u08ad\u08af")
        buf.write("\7\u00e4\2\2\u08ae\u08ad\3\2\2\2\u08ae\u08af\3\2\2\2\u08af")
        buf.write("\u08b0\3\2\2\2\u08b0\u08b4\7\u00ea\2\2\u08b1\u08b2\7\u010c")
        buf.write("\2\2\u08b2\u08b4\7\u00e8\2\2\u08b3\u08ac\3\2\2\2\u08b3")
        buf.write("\u08b1\3\2\2\2\u08b4\u01f9\3\2\2\2\u08b5\u08b6\5\u02b0")
        buf.write("\u0159\2\u08b6\u01fb\3\2\2\2\u08b7\u08b8\7\64\2\2\u08b8")
        buf.write("\u08b9\5\u01fe\u0100\2\u08b9\u08ba\5\u0200\u0101\2\u08ba")
        buf.write("\u01fd\3\2\2\2\u08bb\u08bc\t\n\2\2\u08bc\u01ff\3\2\2\2")
        buf.write("\u08bd\u08be\5\u029e\u0150\2\u08be\u08bf\7|\2\2\u08bf")
        buf.write("\u08c0\5\u02a4\u0153\2\u08c0\u0201\3\2\2\2\u08c1\u08c2")
        buf.write("\7\65\2\2\u08c2\u08c3\5\u0204\u0103\2\u08c3\u08c4\5\u0206")
        buf.write("\u0104\2\u08c4\u0203\3\2\2\2\u08c5\u08c6\t\'\2\2\u08c6")
        buf.write("\u0205\3\2\2\2\u08c7\u08c8\5\u02b4\u015b\2\u08c8\u0207")
        buf.write("\3\2\2\2\u08c9\u08cc\5\u020a\u0106\2\u08ca\u08cc\5\u0210")
        buf.write("\u0109\2\u08cb\u08c9\3\2\2\2\u08cb\u08ca\3\2\2\2\u08cc")
        buf.write("\u0209\3\2\2\2\u08cd\u08ce\7\67\2\2\u08ce\u08cf\5\u020c")
        buf.write("\u0107\2\u08cf\u08d0\5\u020e\u0108\2\u08d0\u020b\3\2\2")
        buf.write("\2\u08d1\u08d3\t(\2\2\u08d2\u08d4\7\u00e4\2\2\u08d3\u08d2")
        buf.write("\3\2\2\2\u08d3\u08d4\3\2\2\2\u08d4\u08d5\3\2\2\2\u08d5")
        buf.write("\u08d6\t)\2\2\u08d6\u08d7\t\'\2\2\u08d7\u020d\3\2\2\2")
        buf.write("\u08d8\u08d9\5\u02b2\u015a\2\u08d9\u020f\3\2\2\2\u08da")
        buf.write("\u08db\7\67\2\2\u08db\u08dc\5\u0212\u010a\2\u08dc\u08dd")
        buf.write("\5\u0214\u010b\2\u08dd\u0211\3\2\2\2\u08de\u08df\t(\2")
        buf.write("\2\u08df\u08e1\t*\2\2\u08e0\u08e2\7\u00e4\2\2\u08e1\u08e0")
        buf.write("\3\2\2\2\u08e1\u08e2\3\2\2\2\u08e2\u08e3\3\2\2\2\u08e3")
        buf.write("\u08e4\t)\2\2\u08e4\u08e5\t\'\2\2\u08e5\u0213\3\2\2\2")
        buf.write("\u08e6\u08e7\5\u02ac\u0157\2\u08e7\u08e8\7|\2\2\u08e8")
        buf.write("\u08e9\5\u02ac\u0157\2\u08e9\u08ea\7|\2\2\u08ea\u08eb")
        buf.write("\5\u02ac\u0157\2\u08eb\u08ed\7|\2\2\u08ec\u08ee\7v\2\2")
        buf.write("\u08ed\u08ec\3\2\2\2\u08ed\u08ee\3\2\2\2\u08ee\u08ef\3")
        buf.write("\2\2\2\u08ef\u08f0\5\u02ac\u0157\2\u08f0\u0215\3\2\2\2")
        buf.write("\u08f1\u08f4\5\u0218\u010d\2\u08f2\u08f4\5\u021e\u0110")
        buf.write("\2\u08f3\u08f1\3\2\2\2\u08f3\u08f2\3\2\2\2\u08f4\u0217")
        buf.write("\3\2\2\2\u08f5\u08f6\7\66\2\2\u08f6\u08f7\5\u021a\u010e")
        buf.write("\2\u08f7\u08f8\5\u021c\u010f\2\u08f8\u0219\3\2\2\2\u08f9")
        buf.write("\u08fb\t(\2\2\u08fa\u08fc\7\u00e4\2\2\u08fb\u08fa\3\2")
        buf.write("\2\2\u08fb\u08fc\3\2\2\2\u08fc\u08fd\3\2\2\2\u08fd\u08fe")
        buf.write("\t\'\2\2\u08fe\u021b\3\2\2\2\u08ff\u0900\5\u02b2\u015a")
        buf.write("\2\u0900\u021d\3\2\2\2\u0901\u0902\7\66\2\2\u0902\u0903")
        buf.write("\5\u0220\u0111\2\u0903\u0904\5\u0222\u0112\2\u0904\u021f")
        buf.write("\3\2\2\2\u0905\u0906\t(\2\2\u0906\u0908\t*\2\2\u0907\u0909")
        buf.write("\7\u00e4\2\2\u0908\u0907\3\2\2\2\u0908\u0909\3\2\2\2\u0909")
        buf.write("\u090a\3\2\2\2\u090a\u090b\t\'\2\2\u090b\u0221\3\2\2\2")
        buf.write("\u090c\u090d\5\u02ac\u0157\2\u090d\u090e\7|\2\2\u090e")
        buf.write("\u090f\5\u02ac\u0157\2\u090f\u0910\7|\2\2\u0910\u0911")
        buf.write("\5\u02ac\u0157\2\u0911\u0913\7|\2\2\u0912\u0914\7v\2\2")
        buf.write("\u0913\u0912\3\2\2\2\u0913\u0914\3\2\2\2\u0914\u0915\3")
        buf.write("\2\2\2\u0915\u0916\5\u02ac\u0157\2\u0916\u0223\3\2\2\2")
        buf.write("\u0917\u0918\78\2\2\u0918\u0919\5\u0226\u0114\2\u0919")
        buf.write("\u091a\5\u0228\u0115\2\u091a\u0225\3\2\2\2\u091b\u091c")
        buf.write("\t\25\2\2\u091c\u0227\3\2\2\2\u091d\u091e\5\u02b2\u015a")
        buf.write("\2\u091e\u0229\3\2\2\2\u091f\u0920\79\2\2\u0920\u0921")
        buf.write("\5\u022c\u0117\2\u0921\u0922\5\u022e\u0118\2\u0922\u022b")
        buf.write("\3\2\2\2\u0923\u0924\t+\2\2\u0924\u022d\3\2\2\2\u0925")
        buf.write("\u0926\5\u02b2\u015a\2\u0926\u022f\3\2\2\2\u0927\u0928")
        buf.write("\7:\2\2\u0928\u0929\5\u0232\u011a\2\u0929\u092a\5\u0234")
        buf.write("\u011b\2\u092a\u0231\3\2\2\2\u092b\u092d\7\u010c\2\2\u092c")
        buf.write("\u092e\7\u00e4\2\2\u092d\u092c\3\2\2\2\u092d\u092e\3\2")
        buf.write("\2\2\u092e\u092f\3\2\2\2\u092f\u0930\7\u00ea\2\2\u0930")
        buf.write("\u0233\3\2\2\2\u0931\u0932\5\u02b0\u0159\2\u0932\u0235")
        buf.write("\3\2\2\2\u0933\u0934\7;\2\2\u0934\u0935\5\u0238\u011d")
        buf.write("\2\u0935\u0936\5\u023a\u011e\2\u0936\u0237\3\2\2\2\u0937")
        buf.write("\u0938\t\'\2\2\u0938\u093f\7\u00a3\2\2\u0939\u093b\7\u00e4")
        buf.write("\2\2\u093a\u0939\3\2\2\2\u093a\u093b\3\2\2\2\u093b\u093c")
        buf.write("\3\2\2\2\u093c\u093d\t\'\2\2\u093d\u093f\7\u00ea\2\2\u093e")
        buf.write("\u0937\3\2\2\2\u093e\u093a\3\2\2\2\u093f\u0239\3\2\2\2")
        buf.write("\u0940\u0941\5\u02b4\u015b\2\u0941\u023b\3\2\2\2\u0942")
        buf.write("\u0943\7<\2\2\u0943\u0944\5\u023e\u0120\2\u0944\u0945")
        buf.write("\5\u0240\u0121\2\u0945\u023d\3\2\2\2\u0946\u0948\7\u010c")
        buf.write("\2\2\u0947\u0949\7\u00e4\2\2\u0948\u0947\3\2\2\2\u0948")
        buf.write("\u0949\3\2\2\2\u0949\u094a\3\2\2\2\u094a\u0953\7\u00ea")
        buf.write("\2\2\u094b\u094d\t\f\2\2\u094c\u094e\7\u00e4\2\2\u094d")
        buf.write("\u094c\3\2\2\2\u094d\u094e\3\2\2\2\u094e\u094f\3\2\2\2")
        buf.write("\u094f\u0953\7\u00ea\2\2\u0950\u0951\t\f\2\2\u0951\u0953")
        buf.write("\7\u00e8\2\2\u0952\u0946\3\2\2\2\u0952\u094b\3\2\2\2\u0952")
        buf.write("\u0950\3\2\2\2\u0953\u023f\3\2\2\2\u0954\u0955\5\u02b0")
        buf.write("\u0159\2\u0955\u0241\3\2\2\2\u0956\u0957\7=\2\2\u0957")
        buf.write("\u0958\5\u0244\u0123\2\u0958\u0959\5\u0246\u0124\2\u0959")
        buf.write("\u0243\3\2\2\2\u095a\u095c\t,\2\2\u095b\u095a\3\2\2\2")
        buf.write("\u095b\u095c\3\2\2\2\u095c\u095e\3\2\2\2\u095d\u095f\t")
        buf.write("-\2\2\u095e\u095d\3\2\2\2\u095e\u095f\3\2\2\2\u095f\u0961")
        buf.write("\3\2\2\2\u0960\u0962\t\4\2\2\u0961\u0960\3\2\2\2\u0961")
        buf.write("\u0962\3\2\2\2\u0962\u0963\3\2\2\2\u0963\u0970\t\36\2")
        buf.write("\2\u0964\u0966\7\u0087\2\2\u0965\u0967\t\34\2\2\u0966")
        buf.write("\u0965\3\2\2\2\u0966\u0967\3\2\2\2\u0967\u0968\3\2\2\2")
        buf.write("\u0968\u0970\t\36\2\2\u0969\u096b\7\u0087\2\2\u096a\u096c")
        buf.write("\t\34\2\2\u096b\u096a\3\2\2\2\u096b\u096c\3\2\2\2\u096c")
        buf.write("\u096d\3\2\2\2\u096d\u096e\t\4\2\2\u096e\u0970\t\36\2")
        buf.write("\2\u096f\u095b\3\2\2\2\u096f\u0964\3\2\2\2\u096f\u0969")
        buf.write("\3\2\2\2\u0970\u0245\3\2\2\2\u0971\u0972\7t\2\2\u0972")
        buf.write("\u0973\5\u02ac\u0157\2\u0973\u0974\7\177\2\2\u0974\u0975")
        buf.write("\7|\2\2\u0975\u0976\5\u02ac\u0157\2\u0976\u0247\3\2\2")
        buf.write("\2\u0977\u0978\7>\2\2\u0978\u0979\5\u024a\u0126\2\u0979")
        buf.write("\u097a\5\u024c\u0127\2\u097a\u0249\3\2\2\2\u097b\u097c")
        buf.write("\7\u009f\2\2\u097c\u097f\7\u00a3\2\2\u097d\u097f\t\n\2")
        buf.write("\2\u097e\u097b\3\2\2\2\u097e\u097d\3\2\2\2\u097f\u0983")
        buf.write("\3\2\2\2\u0980\u0981\7\u00ff\2\2\u0981\u0983\t\13\2\2")
        buf.write("\u0982\u097e\3\2\2\2\u0982\u0980\3\2\2\2\u0983\u0993\3")
        buf.write("\2\2\2\u0984\u0986\t\f\2\2\u0985\u0984\3\2\2\2\u0985\u0986")
        buf.write("\3\2\2\2\u0986\u0988\3\2\2\2\u0987\u0989\7\u00e4\2\2\u0988")
        buf.write("\u0987\3\2\2\2\u0988\u0989\3\2\2\2\u0989\u098b\3\2\2\2")
        buf.write("\u098a\u098c\7\u009f\2\2\u098b\u098a\3\2\2\2\u098b\u098c")
        buf.write("\3\2\2\2\u098c\u098d\3\2\2\2\u098d\u0993\7\u00ea\2\2\u098e")
        buf.write("\u0990\t\f\2\2\u098f\u098e\3\2\2\2\u098f\u0990\3\2\2\2")
        buf.write("\u0990\u0991\3\2\2\2\u0991\u0993\7\u00e8\2\2\u0992\u0982")
        buf.write("\3\2\2\2\u0992\u0985\3\2\2\2\u0992\u098f\3\2\2\2\u0993")
        buf.write("\u024b\3\2\2\2\u0994\u0995\5\u029e\u0150\2\u0995\u0996")
        buf.write("\7|\2\2\u0996\u0997\5\u02a2\u0152\2\u0997\u024d\3\2\2")
        buf.write("\2\u0998\u0999\7?\2\2\u0999\u099a\5\u0250\u0129\2\u099a")
        buf.write("\u099b\5\u0252\u012a\2\u099b\u024f\3\2\2\2\u099c\u099d")
        buf.write("\7\u009f\2\2\u099d\u09a0\7\u00a3\2\2\u099e\u09a0\t\n\2")
        buf.write("\2\u099f\u099c\3\2\2\2\u099f\u099e\3\2\2\2\u09a0\u09a4")
        buf.write("\3\2\2\2\u09a1\u09a2\7\u00ff\2\2\u09a2\u09a4\t\13\2\2")
        buf.write("\u09a3\u099f\3\2\2\2\u09a3\u09a1\3\2\2\2\u09a4\u0251\3")
        buf.write("\2\2\2\u09a5\u09a6\5\u029e\u0150\2\u09a6\u09a7\7|\2\2")
        buf.write("\u09a7\u09a8\5\u02a2\u0152\2\u09a8\u0253\3\2\2\2\u09a9")
        buf.write("\u09aa\7@\2\2\u09aa\u09ab\5\u0256\u012c\2\u09ab\u09ac")
        buf.write("\5\u0258\u012d\2\u09ac\u0255\3\2\2\2\u09ad\u09ae\7\u011d")
        buf.write("\2\2\u09ae\u09b0\t.\2\2\u09af\u09b1\t/\2\2\u09b0\u09af")
        buf.write("\3\2\2\2\u09b0\u09b1\3\2\2\2\u09b1\u09b3\3\2\2\2\u09b2")
        buf.write("\u09b4\t\4\2\2\u09b3\u09b2\3\2\2\2\u09b3\u09b4\3\2\2\2")
        buf.write("\u09b4\u09b5\3\2\2\2\u09b5\u09b6\t\60\2\2\u09b6\u09c2")
        buf.write("\t\61\2\2\u09b7\u09b8\7\u00b7\2\2\u09b8\u09ba\t.\2\2\u09b9")
        buf.write("\u09bb\t/\2\2\u09ba\u09b9\3\2\2\2\u09ba\u09bb\3\2\2\2")
        buf.write("\u09bb\u09bd\3\2\2\2\u09bc\u09be\t\4\2\2\u09bd\u09bc\3")
        buf.write("\2\2\2\u09bd\u09be\3\2\2\2\u09be\u09bf\3\2\2\2\u09bf\u09c0")
        buf.write("\t\62\2\2\u09c0\u09c2\t\61\2\2\u09c1\u09ad\3\2\2\2\u09c1")
        buf.write("\u09b7\3\2\2\2\u09c2\u0257\3\2\2\2\u09c3\u09c4\5\u02ac")
        buf.write("\u0157\2\u09c4\u09c5\7|\2\2\u09c5\u09c6\7t\2\2\u09c6\u09c7")
        buf.write("\5\u02ac\u0157\2\u09c7\u09c8\7|\2\2\u09c8\u09c9\5\u02ac")
        buf.write("\u0157\2\u09c9\u09ca\7\177\2\2\u09ca\u0259\3\2\2\2\u09cb")
        buf.write("\u09cc\7B\2\2\u09cc\u09cd\5\u025c\u012f\2\u09cd\u09ce")
        buf.write("\5\u025e\u0130\2\u09ce\u025b\3\2\2\2\u09cf\u09d0\7\u011d")
        buf.write("\2\2\u09d0\u09d2\t.\2\2\u09d1\u09d3\t/\2\2\u09d2\u09d1")
        buf.write("\3\2\2\2\u09d2\u09d3\3\2\2\2\u09d3\u09d5\3\2\2\2\u09d4")
        buf.write("\u09d6\t\4\2\2\u09d5\u09d4\3\2\2\2\u09d5\u09d6\3\2\2\2")
        buf.write("\u09d6\u09d7\3\2\2\2\u09d7\u09d8\t\60\2\2\u09d8\u09e4")
        buf.write("\t\61\2\2\u09d9\u09da\7\u00b7\2\2\u09da\u09dc\t.\2\2\u09db")
        buf.write("\u09dd\t/\2\2\u09dc\u09db\3\2\2\2\u09dc\u09dd\3\2\2\2")
        buf.write("\u09dd\u09df\3\2\2\2\u09de\u09e0\t\4\2\2\u09df\u09de\3")
        buf.write("\2\2\2\u09df\u09e0\3\2\2\2\u09e0\u09e1\3\2\2\2\u09e1\u09e2")
        buf.write("\t\62\2\2\u09e2\u09e4\t\61\2\2\u09e3\u09cf\3\2\2\2\u09e3")
        buf.write("\u09d9\3\2\2\2\u09e4\u025d\3\2\2\2\u09e5\u09e6\7t\2\2")
        buf.write("\u09e6\u09e7\5\u02ac\u0157\2\u09e7\u09e8\7|\2\2\u09e8")
        buf.write("\u09e9\5\u02ac\u0157\2\u09e9\u09ea\7\177\2\2\u09ea\u09eb")
        buf.write("\7|\2\2\u09eb\u09ec\5\u02ac\u0157\2\u09ec\u025f\3\2\2")
        buf.write("\2\u09ed\u09ee\7C\2\2\u09ee\u09ef\5\u0262\u0132\2\u09ef")
        buf.write("\u09f0\5\u0264\u0133\2\u09f0\u0261\3\2\2\2\u09f1\u09f2")
        buf.write("\7\u011d\2\2\u09f2\u09f4\t.\2\2\u09f3\u09f5\t/\2\2\u09f4")
        buf.write("\u09f3\3\2\2\2\u09f4\u09f5\3\2\2\2\u09f5\u09f7\3\2\2\2")
        buf.write("\u09f6\u09f8\t\4\2\2\u09f7\u09f6\3\2\2\2\u09f7\u09f8\3")
        buf.write("\2\2\2\u09f8\u09f9\3\2\2\2\u09f9\u09fa\t\60\2\2\u09fa")
        buf.write("\u0a06\t\61\2\2\u09fb\u09fc\7\u00b7\2\2\u09fc\u09fe\t")
        buf.write(".\2\2\u09fd\u09ff\t/\2\2\u09fe\u09fd\3\2\2\2\u09fe\u09ff")
        buf.write("\3\2\2\2\u09ff\u0a01\3\2\2\2\u0a00\u0a02\t\4\2\2\u0a01")
        buf.write("\u0a00\3\2\2\2\u0a01\u0a02\3\2\2\2\u0a02\u0a03\3\2\2\2")
        buf.write("\u0a03\u0a04\t\62\2\2\u0a04\u0a06\t\61\2\2\u0a05\u09f1")
        buf.write("\3\2\2\2\u0a05\u09fb\3\2\2\2\u0a06\u0263\3\2\2\2\u0a07")
        buf.write("\u0a08\7t\2\2\u0a08\u0a09\5\u02ac\u0157\2\u0a09\u0a0a")
        buf.write("\7|\2\2\u0a0a\u0a0b\5\u02ac\u0157\2\u0a0b\u0a0c\7\177")
        buf.write("\2\2\u0a0c\u0a0d\7|\2\2\u0a0d\u0a0e\5\u02ac\u0157\2\u0a0e")
        buf.write("\u0265\3\2\2\2\u0a0f\u0a10\7A\2\2\u0a10\u0a11\5\u0268")
        buf.write("\u0135\2\u0a11\u0a12\5\u026a\u0136\2\u0a12\u0267\3\2\2")
        buf.write("\2\u0a13\u0a14\t\63\2\2\u0a14\u0a15\7\u0109\2\2\u0a15")
        buf.write("\u0269\3\2\2\2\u0a16\u0a17\5\u02ac\u0157\2\u0a17\u0a18")
        buf.write("\7|\2\2\u0a18\u0a19\7t\2\2\u0a19\u0a1a\5\u02ac\u0157\2")
        buf.write("\u0a1a\u0a1b\7\177\2\2\u0a1b\u026b\3\2\2\2\u0a1c\u0a1d")
        buf.write("\7D\2\2\u0a1d\u0a1e\5\u026e\u0138\2\u0a1e\u0a1f\5\u0270")
        buf.write("\u0139\2\u0a1f\u026d\3\2\2\2\u0a20\u0a21\t\64\2\2\u0a21")
        buf.write("\u0a22\t\26\2\2\u0a22\u026f\3\2\2\2\u0a23\u0a24\5\u029e")
        buf.write("\u0150\2\u0a24\u0a25\7|\2\2\u0a25\u0a26\5\u029e\u0150")
        buf.write("\2\u0a26\u0271\3\2\2\2\u0a27\u0a28\7E\2\2\u0a28\u0a29")
        buf.write("\5\u0274\u013b\2\u0a29\u0a2a\5\u0276\u013c\2\u0a2a\u0273")
        buf.write("\3\2\2\2\u0a2b\u0a2c\t.\2\2\u0a2c\u0a2d\7\u008b\2\2\u0a2d")
        buf.write("\u0a2e\t)\2\2\u0a2e\u0a2f\t\65\2\2\u0a2f\u0275\3\2\2\2")
        buf.write("\u0a30\u0a31\5\u02ac\u0157\2\u0a31\u0a32\7|\2\2\u0a32")
        buf.write("\u0a33\7t\2\2\u0a33\u0a34\5\u02ac\u0157\2\u0a34\u0a35")
        buf.write("\7|\2\2\u0a35\u0a38\5\u02ac\u0157\2\u0a36\u0a37\7|\2\2")
        buf.write("\u0a37\u0a39\5\u02ac\u0157\2\u0a38\u0a36\3\2\2\2\u0a38")
        buf.write("\u0a39\3\2\2\2\u0a39\u0a3a\3\2\2\2\u0a3a\u0a3b\7\177\2")
        buf.write("\2\u0a3b\u0277\3\2\2\2\u0a3c\u0a3d\7G\2\2\u0a3d\u0a3e")
        buf.write("\5\u027a\u013e\2\u0a3e\u0a3f\5\u027c\u013f\2\u0a3f\u0279")
        buf.write("\3\2\2\2\u0a40\u0a43\t\66\2\2\u0a41\u0a43\t\67\2\2\u0a42")
        buf.write("\u0a40\3\2\2\2\u0a42\u0a41\3\2\2\2\u0a43\u0a44\3\2\2\2")
        buf.write("\u0a44\u0a45\7\u0109\2\2\u0a45\u027b\3\2\2\2\u0a46\u0a47")
        buf.write("\5\u02ac\u0157\2\u0a47\u0a48\7|\2\2\u0a48\u0a49\7t\2\2")
        buf.write("\u0a49\u0a4a\5\u02ac\u0157\2\u0a4a\u0a4b\7\177\2\2\u0a4b")
        buf.write("\u027d\3\2\2\2\u0a4c\u0a4d\7F\2\2\u0a4d\u027f\3\2\2\2")
        buf.write("\u0a4e\u0a4f\7H\2\2\u0a4f\u0281\3\2\2\2\u0a50\u0a51\7")
        buf.write("I\2\2\u0a51\u0283\3\2\2\2\u0a52\u0a53\7J\2\2\u0a53\u0285")
        buf.write("\3\2\2\2\u0a54\u0a55\7K\2\2\u0a55\u0287\3\2\2\2\u0a56")
        buf.write("\u0a57\7L\2\2\u0a57\u0289\3\2\2\2\u0a58\u0a59\7N\2\2\u0a59")
        buf.write("\u028b\3\2\2\2\u0a5a\u0a5b\7O\2\2\u0a5b\u028d\3\2\2\2")
        buf.write("\u0a5c\u0a5d\7P\2\2\u0a5d\u028f\3\2\2\2\u0a5e\u0a5f\7")
        buf.write("Q\2\2\u0a5f\u0291\3\2\2\2\u0a60\u0a61\7M\2\2\u0a61\u0a62")
        buf.write("\5\u0294\u014b\2\u0a62\u0a63\5\u0296\u014c\2\u0a63\u0293")
        buf.write("\3\2\2\2\u0a64\u0a65\t8\2\2\u0a65\u0a69\7\u00b3\2\2\u0a66")
        buf.write("\u0a67\7\u0105\2\2\u0a67\u0a69\7\u0109\2\2\u0a68\u0a64")
        buf.write("\3\2\2\2\u0a68\u0a66\3\2\2\2\u0a69\u0295\3\2\2\2\u0a6a")
        buf.write("\u0a6b\5\u02ac\u0157\2\u0a6b\u0a6d\7|\2\2\u0a6c\u0a6e")
        buf.write("\7v\2\2\u0a6d\u0a6c\3\2\2\2\u0a6d\u0a6e\3\2\2\2\u0a6e")
        buf.write("\u0a6f\3\2\2\2\u0a6f\u0a70\5\u02ac\u0157\2\u0a70\u0297")
        buf.write("\3\2\2\2\u0a71\u0a72\7R\2\2\u0a72\u0a73\5\u029a\u014e")
        buf.write("\2\u0a73\u0a74\5\u029c\u014f\2\u0a74\u0299\3\2\2\2\u0a75")
        buf.write("\u0a76\t\16\2\2\u0a76\u029b\3\2\2\2\u0a77\u0a78\5\u02b2")
        buf.write("\u015a\2\u0a78\u029d\3\2\2\2\u0a79\u0a7a\5\u0098M\2\u0a7a")
        buf.write("\u029f\3\2\2\2\u0a7b\u0a7e\5\u0098M\2\u0a7c\u0a7e\5\u02b8")
        buf.write("\u015d\2\u0a7d\u0a7b\3\2\2\2\u0a7d\u0a7c\3\2\2\2\u0a7e")
        buf.write("\u02a1\3\2\2\2\u0a7f\u0a80\5\u02a0\u0151\2\u0a80\u0a81")
        buf.write("\7|\2\2\u0a81\u0a82\5\u02a0\u0151\2\u0a82\u02a3\3\2\2")
        buf.write("\2\u0a83\u0a84\5\u02a0\u0151\2\u0a84\u0a85\7|\2\2\u0a85")
        buf.write("\u0a86\5\u02a0\u0151\2\u0a86\u0a87\7|\2\2\u0a87\u0a88")
        buf.write("\5\u02a0\u0151\2\u0a88\u02a5\3\2\2\2\u0a89\u0a8a\5\u02a0")
        buf.write("\u0151\2\u0a8a\u0a8b\7|\2\2\u0a8b\u0a8c\5\u02a0\u0151")
        buf.write("\2\u0a8c\u0a8d\7|\2\2\u0a8d\u0a8e\5\u02a0\u0151\2\u0a8e")
        buf.write("\u0a8f\7|\2\2\u0a8f\u0a90\5\u02a0\u0151\2\u0a90\u02a7")
        buf.write("\3\2\2\2\u0a91\u0a92\5\u02a0\u0151\2\u0a92\u0a93\7|\2")
        buf.write("\2\u0a93\u0a94\5\u02a0\u0151\2\u0a94\u0a95\7|\2\2\u0a95")
        buf.write("\u0a96\5\u02a0\u0151\2\u0a96\u0a97\7|\2\2\u0a97\u0a98")
        buf.write("\5\u02a0\u0151\2\u0a98\u0a99\7|\2\2\u0a99\u0a9a\5\u02a0")
        buf.write("\u0151\2\u0a9a\u02a9\3\2\2\2\u0a9b\u0a9c\7\u0120\2\2\u0a9c")
        buf.write("\u02ab\3\2\2\2\u0a9d\u0a9e\5\u02ae\u0158\2\u0a9e\u02ad")
        buf.write("\3\2\2\2\u0a9f\u0aa1\5\u0098M\2\u0aa0\u0aa2\t9\2\2\u0aa1")
        buf.write("\u0aa0\3\2\2\2\u0aa1\u0aa2\3\2\2\2\u0aa2\u0aa5\3\2\2\2")
        buf.write("\u0aa3\u0aa5\5\u02b8\u015d\2\u0aa4\u0a9f\3\2\2\2\u0aa4")
        buf.write("\u0aa3\3\2\2\2\u0aa5\u0aa8\3\2\2\2\u0aa6\u0aa7\7q\2\2")
        buf.write("\u0aa7\u0aa9\5\u02b8\u015d\2\u0aa8\u0aa6\3\2\2\2\u0aa8")
        buf.write("\u0aa9\3\2\2\2\u0aa9\u0aae\3\2\2\2\u0aaa\u0aab\7y\2\2")
        buf.write("\u0aab\u0aac\5\u02ac\u0157\2\u0aac\u0aad\7x\2\2\u0aad")
        buf.write("\u0aaf\3\2\2\2\u0aae\u0aaa\3\2\2\2\u0aae\u0aaf\3\2\2\2")
        buf.write("\u0aaf\u0ac2\3\2\2\2\u0ab0\u0ab3\7s\2\2\u0ab1\u0ab4\5")
        buf.write("\u0098M\2\u0ab2\u0ab4\7\u0121\2\2\u0ab3\u0ab1\3\2\2\2")
        buf.write("\u0ab3\u0ab2\3\2\2\2\u0ab4\u0abc\3\2\2\2\u0ab5\u0ab8\7")
        buf.write("|\2\2\u0ab6\u0ab9\5\u0098M\2\u0ab7\u0ab9\7\u0121\2\2\u0ab8")
        buf.write("\u0ab6\3\2\2\2\u0ab8\u0ab7\3\2\2\2\u0ab9\u0abb\3\2\2\2")
        buf.write("\u0aba\u0ab5\3\2\2\2\u0abb\u0abe\3\2\2\2\u0abc\u0aba\3")
        buf.write("\2\2\2\u0abc\u0abd\3\2\2\2\u0abd\u0abf\3\2\2\2\u0abe\u0abc")
        buf.write("\3\2\2\2\u0abf\u0ac2\7~\2\2\u0ac0\u0ac2\7\u0121\2\2\u0ac1")
        buf.write("\u0aa4\3\2\2\2\u0ac1\u0ab0\3\2\2\2\u0ac1\u0ac0\3\2\2\2")
        buf.write("\u0ac2\u02af\3\2\2\2\u0ac3\u0ac4\5\u02ac\u0157\2\u0ac4")
        buf.write("\u0ac5\7|\2\2\u0ac5\u0ac6\5\u02ac\u0157\2\u0ac6\u02b1")
        buf.write("\3\2\2\2\u0ac7\u0ac8\5\u02ac\u0157\2\u0ac8\u0ac9\7|\2")
        buf.write("\2\u0ac9\u0aca\5\u02ac\u0157\2\u0aca\u0acb\7|\2\2\u0acb")
        buf.write("\u0acc\5\u02ac\u0157\2\u0acc\u02b3\3\2\2\2\u0acd\u0ace")
        buf.write("\5\u02ac\u0157\2\u0ace\u0acf\7|\2\2\u0acf\u0ad0\5\u02ac")
        buf.write("\u0157\2\u0ad0\u0ad1\7|\2\2\u0ad1\u0ad2\5\u02ac\u0157")
        buf.write("\2\u0ad2\u0ad3\7|\2\2\u0ad3\u0ad4\5\u02ac\u0157\2\u0ad4")
        buf.write("\u02b5\3\2\2\2\u0ad5\u0ad6\5\u02ac\u0157\2\u0ad6\u0ad7")
        buf.write("\7|\2\2\u0ad7\u0ad8\5\u02ac\u0157\2\u0ad8\u0ad9\7|\2\2")
        buf.write("\u0ad9\u0ada\5\u02ac\u0157\2\u0ada\u0adb\7|\2\2\u0adb")
        buf.write("\u0adc\5\u02ac\u0157\2\u0adc\u0add\7|\2\2\u0add\u0ade")
        buf.write("\5\u02ac\u0157\2\u0ade\u02b7\3\2\2\2\u0adf\u0ae0\5\u02ba")
        buf.write("\u015e\2\u0ae0\u02b9\3\2\2\2\u0ae1\u0ae2\5\u02bc\u015f")
        buf.write("\2\u0ae2\u02bb\3\2\2\2\u0ae3\u0ae9\5\u02be\u0160\2\u0ae4")
        buf.write("\u0ae5\7S\2\2\u0ae5\u0ae6\5\u02ba\u015e\2\u0ae6\u0ae7")
        buf.write("\7}\2\2\u0ae7\u0ae8\5\u02bc\u015f\2\u0ae8\u0aea\3\2\2")
        buf.write("\2\u0ae9\u0ae4\3\2\2\2\u0ae9\u0aea\3\2\2\2\u0aea\u02bd")
        buf.write("\3\2\2\2\u0aeb\u0af0\5\u02c0\u0161\2\u0aec\u0aed\7T\2")
        buf.write("\2\u0aed\u0aef\5\u02c0\u0161\2\u0aee\u0aec\3\2\2\2\u0aef")
        buf.write("\u0af2\3\2\2\2\u0af0\u0aee\3\2\2\2\u0af0\u0af1\3\2\2\2")
        buf.write("\u0af1\u02bf\3\2\2\2\u0af2\u0af0\3\2\2\2\u0af3\u0af8\5")
        buf.write("\u02c2\u0162\2\u0af4\u0af5\7U\2\2\u0af5\u0af7\5\u02c2")
        buf.write("\u0162\2\u0af6\u0af4\3\2\2\2\u0af7\u0afa\3\2\2\2\u0af8")
        buf.write("\u0af6\3\2\2\2\u0af8\u0af9\3\2\2\2\u0af9\u02c1\3\2\2\2")
        buf.write("\u0afa\u0af8\3\2\2\2\u0afb\u0b00\5\u02c4\u0163\2\u0afc")
        buf.write("\u0afd\7V\2\2\u0afd\u0aff\5\u02c4\u0163\2\u0afe\u0afc")
        buf.write("\3\2\2\2\u0aff\u0b02\3\2\2\2\u0b00\u0afe\3\2\2\2\u0b00")
        buf.write("\u0b01\3\2\2\2\u0b01\u02c3\3\2\2\2\u0b02\u0b00\3\2\2\2")
        buf.write("\u0b03\u0b08\5\u02c6\u0164\2\u0b04\u0b05\7W\2\2\u0b05")
        buf.write("\u0b07\5\u02c6\u0164\2\u0b06\u0b04\3\2\2\2\u0b07\u0b0a")
        buf.write("\3\2\2\2\u0b08\u0b06\3\2\2\2\u0b08\u0b09\3\2\2\2\u0b09")
        buf.write("\u02c5\3\2\2\2\u0b0a\u0b08\3\2\2\2\u0b0b\u0b10\5\u02c8")
        buf.write("\u0165\2\u0b0c\u0b0d\7X\2\2\u0b0d\u0b0f\5\u02c8\u0165")
        buf.write("\2\u0b0e\u0b0c\3\2\2\2\u0b0f\u0b12\3\2\2\2\u0b10\u0b0e")
        buf.write("\3\2\2\2\u0b10\u0b11\3\2\2\2\u0b11\u02c7\3\2\2\2\u0b12")
        buf.write("\u0b10\3\2\2\2\u0b13\u0b18\5\u02ca\u0166\2\u0b14\u0b15")
        buf.write("\t:\2\2\u0b15\u0b17\5\u02ca\u0166\2\u0b16\u0b14\3\2\2")
        buf.write("\2\u0b17\u0b1a\3\2\2\2\u0b18\u0b16\3\2\2\2\u0b18\u0b19")
        buf.write("\3\2\2\2\u0b19\u02c9\3\2\2\2\u0b1a\u0b18\3\2\2\2\u0b1b")
        buf.write("\u0b21\5\u02ce\u0168\2\u0b1c\u0b1d\5\u02cc\u0167\2\u0b1d")
        buf.write("\u0b1e\5\u02ce\u0168\2\u0b1e\u0b20\3\2\2\2\u0b1f\u0b1c")
        buf.write("\3\2\2\2\u0b20\u0b23\3\2\2\2\u0b21\u0b1f\3\2\2\2\u0b21")
        buf.write("\u0b22\3\2\2\2\u0b22\u02cb\3\2\2\2\u0b23\u0b21\3\2\2\2")
        buf.write("\u0b24\u0b25\t;\2\2\u0b25\u02cd\3\2\2\2\u0b26\u0b2c\5")
        buf.write("\u02d2\u016a\2\u0b27\u0b28\5\u02d0\u0169\2\u0b28\u0b29")
        buf.write("\5\u02d2\u016a\2\u0b29\u0b2b\3\2\2\2\u0b2a\u0b27\3\2\2")
        buf.write("\2\u0b2b\u0b2e\3\2\2\2\u0b2c\u0b2a\3\2\2\2\u0b2c\u0b2d")
        buf.write("\3\2\2\2\u0b2d\u02cf\3\2\2\2\u0b2e\u0b2c\3\2\2\2\u0b2f")
        buf.write("\u0b30\t<\2\2\u0b30\u02d1\3\2\2\2\u0b31\u0b36\5\u02d4")
        buf.write("\u016b\2\u0b32\u0b33\t=\2\2\u0b33\u0b35\5\u02d4\u016b")
        buf.write("\2\u0b34\u0b32\3\2\2\2\u0b35\u0b38\3\2\2\2\u0b36\u0b34")
        buf.write("\3\2\2\2\u0b36\u0b37\3\2\2\2\u0b37\u02d3\3\2\2\2\u0b38")
        buf.write("\u0b36\3\2\2\2\u0b39\u0b3e\5\u02d6\u016c\2\u0b3a\u0b3b")
        buf.write("\t>\2\2\u0b3b\u0b3d\5\u02d6\u016c\2\u0b3c\u0b3a\3\2\2")
        buf.write("\2\u0b3d\u0b40\3\2\2\2\u0b3e\u0b3c\3\2\2\2\u0b3e\u0b3f")
        buf.write("\3\2\2\2\u0b3f\u02d5\3\2\2\2\u0b40\u0b3e\3\2\2\2\u0b41")
        buf.write("\u0b42\7q\2\2\u0b42\u0b47\5\u02d6\u016c\2\u0b43\u0b44")
        buf.write("\7w\2\2\u0b44\u0b47\5\u02d6\u016c\2\u0b45\u0b47\5\u02d8")
        buf.write("\u016d\2\u0b46\u0b41\3\2\2\2\u0b46\u0b43\3\2\2\2\u0b46")
        buf.write("\u0b45\3\2\2\2\u0b47\u02d7\3\2\2\2\u0b48\u0b49\7_\2\2")
        buf.write("\u0b49\u0b4f\5\u02d6\u016c\2\u0b4a\u0b4b\7v\2\2\u0b4b")
        buf.write("\u0b4f\5\u02d6\u016c\2\u0b4c\u0b4f\5\u02da\u016e\2\u0b4d")
        buf.write("\u0b4f\5\u02de\u0170\2\u0b4e\u0b48\3\2\2\2\u0b4e\u0b4a")
        buf.write("\3\2\2\2\u0b4e\u0b4c\3\2\2\2\u0b4e\u0b4d\3\2\2\2\u0b4f")
        buf.write("\u02d9\3\2\2\2\u0b50\u0b51\5\u02dc\u016f\2\u0b51\u02db")
        buf.write("\3\2\2\2\u0b52\u0b53\7r\2\2\u0b53\u0b54\t?\2\2\u0b54\u0b55")
        buf.write("\7{\2\2\u0b55\u0b56\5\u02d6\u016c\2\u0b56\u02dd\3\2\2")
        buf.write("\2\u0b57\u0b5b\5\u02e0\u0171\2\u0b58\u0b5b\5\u02e2\u0172")
        buf.write("\2\u0b59\u0b5b\5\u02e4\u0173\2\u0b5a\u0b57\3\2\2\2\u0b5a")
        buf.write("\u0b58\3\2\2\2\u0b5a\u0b59\3\2\2\2\u0b5b\u02df\3\2\2\2")
        buf.write("\u0b5c\u0b5d\7r\2\2\u0b5d\u0b5e\5\u02ba\u015e\2\u0b5e")
        buf.write("\u0b5f\7{\2\2\u0b5f\u02e1\3\2\2\2\u0b60\u0b64\5\u02e6")
        buf.write("\u0174\2\u0b61\u0b64\5\u02e8\u0175\2\u0b62\u0b64\5\u02ea")
        buf.write("\u0176\2\u0b63\u0b60\3\2\2\2\u0b63\u0b61\3\2\2\2\u0b63")
        buf.write("\u0b62\3\2\2\2\u0b64\u02e3\3\2\2\2\u0b65\u0b66\7`\2\2")
        buf.write("\u0b66\u02e5\3\2\2\2\u0b67\u0b68\7c\2\2\u0b68\u02e7\3")
        buf.write("\2\2\2\u0b69\u0b6a\7b\2\2\u0b6a\u02e9\3\2\2\2\u0b6b\u0b6c")
        buf.write("\7a\2\2\u0b6c\u02eb\3\2\2\2\u00fa\u02ef\u02f4\u0306\u030c")
        buf.write("\u0314\u0319\u031f\u0324\u032b\u032f\u0334\u033a\u033d")
        buf.write("\u0340\u034b\u0350\u0355\u0358\u035b\u035e\u0361\u036b")
        buf.write("\u036f\u0375\u037c\u038f\u0394\u0397\u039c\u039f\u03a2")
        buf.write("\u03ab\u03b0\u03b5\u03c0\u03c4\u03c8\u03cd\u03d7\u03df")
        buf.write("\u03eb\u03f6\u03f9\u03fe\u0401\u0408\u040d\u0412\u041b")
        buf.write("\u0423\u042e\u0430\u0438\u043a\u044c\u0458\u0461\u046d")
        buf.write("\u0471\u047c\u0480\u0489\u0495\u049b\u04a1\u04a5\u04ad")
        buf.write("\u04b6\u04bc\u04c2\u04c7\u04ce\u04d2\u04df\u04e3\u04e8")
        buf.write("\u04f0\u04f3\u04fa\u04fe\u0509\u0522\u0574\u0578\u0582")
        buf.write("\u0586\u0593\u0597\u059a\u059d\u05a0\u05a4\u05a7\u05b2")
        buf.write("\u05c7\u05d5\u05db\u05e6\u05fd\u0601\u0612\u0616\u0633")
        buf.write("\u0640\u0647\u065d\u0663\u066d\u0672\u0678\u067c\u06a6")
        buf.write("\u06b2\u06b5\u06b8\u06be\u06c1\u06c4\u06c8\u06ce\u06d9")
        buf.write("\u06e3\u06ec\u06f1\u06f6\u06fb\u0707\u0715\u0718\u071c")
        buf.write("\u072d\u0730\u0734\u0737\u073d\u0742\u0746\u0753\u0757")
        buf.write("\u075b\u0769\u0775\u077c\u077f\u0784\u0787\u078c\u0798")
        buf.write("\u079f\u07a2\u07a7\u07aa\u07af\u07be\u07ca\u07ce\u07df")
        buf.write("\u07e3\u07f6\u07fa\u07fd\u0800\u0804\u0807\u081e\u0822")
        buf.write("\u084c\u0864\u086e\u0876\u087a\u087e\u0886\u088f\u08ae")
        buf.write("\u08b3\u08cb\u08d3\u08e1\u08ed\u08f3\u08fb\u0908\u0913")
        buf.write("\u092d\u093a\u093e\u0948\u094d\u0952\u095b\u095e\u0961")
        buf.write("\u0966\u096b\u096f\u097e\u0982\u0985\u0988\u098b\u098f")
        buf.write("\u0992\u099f\u09a3\u09b0\u09b3\u09ba\u09bd\u09c1\u09d2")
        buf.write("\u09d5\u09dc\u09df\u09e3\u09f4\u09f7\u09fe\u0a01\u0a05")
        buf.write("\u0a38\u0a42\u0a68\u0a6d\u0a7d\u0aa1\u0aa4\u0aa8\u0aae")
        buf.write("\u0ab3\u0ab8\u0abc\u0ac1\u0ae9\u0af0\u0af8\u0b00\u0b08")
        buf.write("\u0b10\u0b18\u0b21\u0b2c\u0b36\u0b3e\u0b46\u0b4e\u0b5a")
        buf.write("\u0b63")
        return buf.getvalue()


class PtxParser ( Parser ):

    grammarFileName = "Ptx.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'?'", "'||'", "'&&'", "'|'", "'^'", "'&'", 
                     "'=='", "'<='", "'>='", "'<<'", "'>>'", "'*'", "'~'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'.3d'", "'.2d'", "'.1d'", "'.debug_abbrev'", "'.debug_info'", 
                     "'.debug_line'", "'.debug_loc'", "'.debug_pubnames'", 
                     "'.debug_ranges'", "'.byte'", "'.4byte'", "'='", "';'", 
                     "'+'", "'('", "'{'", "'['", "'!='", "'!'", "'-'", "'>'", 
                     "'<'", "'...'", "')'", "','", "':'", "'}'", "']'", 
                     "<INVALID>", "'.zero'", "'.xor'", "'.wt'", "'.width'", 
                     "'.wide'", "'.wb'", "'.volatile'", "'.visible'", "'.version'", 
                     "'.vb'", "'.v4'", "'.v2'", "'.uni'", "'.u8'", "'.u64'", 
                     "'.u32'", "'.u16'", "'.trap'", "'.to'", "'.texref'", 
                     "'.tex'", "'.target'", "'.sys'", "'.sync'", "'.surfref'", 
                     "'.subnormal'", "'.sreg'", "'.shiftamt'", "'.shared'", 
                     "'.section'", "'.sat'", "'.samplerref'", "'.s8'", "'.s64'", 
                     "'.s32'", "'.s16'", "'.rzi'", "'.rz'", "'.rpi'", "'.rp'", 
                     "'.rni'", "'.rn'", "'.rmi'", "'.rm'", "'.reqntid'", 
                     "'.reg'", "'.red'", "'.rcp'", "'.rc8'", "'.rc16'", 
                     "'.pred'", "'.pragma'", "'.popc'", "'.param'", "'.p'", 
                     "'.or'", "'.oc'", "'.number'", "'.num'", "'.ns'", "'\"nounroll\"'", 
                     "<INVALID>", "'.notanumber'", "'.normalized_coords'", 
                     "'.normal'", "'.neu'", "'.ne'", "'.nan'", "'.minnctapersm'", 
                     "'.min'", "'.maxntid'", "'.maxnreg'", "'.maxnctapersm'", 
                     "'.max'", "'.lu'", "'.ltu'", "'.lt'", "'.ls'", "'.local'", 
                     "'.loc'", "'.lo'", "'.leu'", "'.le'", "'.L2'", "'.L1'", 
                     "'.infinite'", "'.inc'", "'.hs'", "'.hi'", "'.height'", 
                     "'.gtu'", "'.gt'", "'.global'", "'.gl'", "'.geu'", 
                     "'.ge'", "'.func'", "'.weak'", "'.full'", "'.ftz'", 
                     "'.finite'", "'.filter_mode'", "'.file'", "'.f64'", 
                     "'.f4e'", "'.f32'", "'.f16'", "'.extern'", "'.exch'", 
                     "'.equ'", "'.eq'", "'.entry'", "'.ecr'", "'.ecl'", 
                     "<INVALID>", "'.depth'", "'.dec'", "'.cv'", "'.cta'", 
                     "'.cs'", "'.const'", "'.clamp'", "'.channel_order'", 
                     "'.channel_data_type'", "'.channel_data'", "'.cg'", 
                     "'.cc'", "'.cas'", "'.calltargets'", "'.callprototype'", 
                     "'.ca'", "'.branchtargets'", "'.ballot'", "'.b8'", 
                     "'.b64'", "'.b4e'", "'.b32'", "'.b16'", "'.arrive'", 
                     "'.approx'", "'.any'", "'.and'", "'.all'", "'.align'", 
                     "'.addr_mode_2'", "'.addr_mode_1'", "'.addr_mode_0'", 
                     "'.address_size'", "'.add'", "'.x'", "'.y'", "'.z'", 
                     "'.w'", "'.a'", "'.r'", "'.g'", "'.b'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'@'", "'%'", 
                     "'/'", "'.'" ]

    symbolicNames = [ "<INVALID>", "KI_ABS", "KI_ADD", "KI_ADDC", "KI_AND", 
                      "KI_ATOM", "KI_BAR", "KI_BFE", "KI_BFI", "KI_BFIND", 
                      "KI_BRA", "KI_BREV", "KI_BRKPT", "KI_CALL", "KI_CLZ", 
                      "KI_CNOT", "KI_COPYSIGN", "KI_COS", "KI_CVT", "KI_CVTA", 
                      "KI_DIV", "KI_EX2", "KI_EXIT", "KI_FMA", "KI_ISSPACEP", 
                      "KI_LD", "KI_LDU", "KI_LG2", "KI_MAD24", "KI_MAD", 
                      "KI_MADC", "KI_MAX", "KI_MEMBAR", "KI_MIN", "KI_MOV", 
                      "KI_MUL24", "KI_MUL", "KI_NEG", "KI_NOT", "KI_OR", 
                      "KI_PMEVENT", "KI_POPC", "KI_PREFETCH", "KI_PREFETCHU", 
                      "KI_PRMT", "KI_RCP", "KI_RED", "KI_REM", "KI_RET", 
                      "KI_RSQRT", "KI_SAD", "KI_SELP", "KI_SETP", "KI_SET", 
                      "KI_SHL", "KI_SHR", "KI_SIN", "KI_SLCT", "KI_SQRT", 
                      "KI_ST", "KI_SUB", "KI_SUBC", "KI_SULD", "KI_SUQ", 
                      "KI_SURED", "KI_SUST", "KI_TESTP", "KI_TEX", "KI_TRAP", 
                      "KI_TXQ", "KI_VABSDIFF", "KI_VADD", "KI_VMAD", "KI_VMAX", 
                      "KI_VMIN", "KI_VOTE", "KI_VSET", "KI_VSHL", "KI_VSHR", 
                      "KI_VSUB", "KI_XOR", "T_QUESTION", "T_OROR", "T_ANDAND", 
                      "T_OR", "T_XOR", "T_AND", "T_EQEQ", "T_LE", "T_GE", 
                      "T_LTLT", "T_GTGT", "T_STAR", "T_TILDE", "T_FLT_LITERAL", 
                      "T_HEX_LITERAL", "T_OCT_LITERAL", "T_DEC_LITERAL", 
                      "K_3D", "K_2D", "K_1D", "U_DEBUG_ABBREV", "U_DEBUG_INFO", 
                      "U_DEBUG_LINE", "U_DEBUG_LOC", "U_DEBUG_PUBNAMES", 
                      "U_DEBUG_RANGES", "U_BYTE", "U_4BYTE", "T_EQ", "T_SEMICOLON", 
                      "T_PLUS", "T_OP", "T_OC", "T_OB", "T_NOTEQ", "T_NOT", 
                      "T_MINUS", "T_GT", "T_LT", "T_ELLIPSIS", "T_CP", "T_COMMA", 
                      "T_COLON", "T_CC", "T_CB", "LINE_COMMENT", "K_ZERO", 
                      "K_XOR", "K_WT", "K_WIDTH", "K_WIDE", "K_WB", "K_VOLATILE", 
                      "K_VISIBLE", "K_VERSION", "K_VB", "K_V4", "K_V2", 
                      "K_UNI", "K_U8", "K_U64", "K_U32", "K_U16", "K_TRAP", 
                      "K_TO", "K_TEXREF", "K_TEX", "K_TARGET", "K_SYS", 
                      "K_SYNC", "K_SURFREF", "K_SUBNORMAL", "K_SREG", "K_SHIFTAMT", 
                      "K_SHARED", "K_SECTION", "K_SAT", "K_SAMPLERREF", 
                      "K_S8", "K_S64", "K_S32", "K_S16", "K_RZI", "K_RZ", 
                      "K_RPI", "K_RP", "K_RNI", "K_RN", "K_RMI", "K_RM", 
                      "K_REQNTID", "K_REG", "K_RED", "K_RCP", "K_RC8", "K_RC16", 
                      "K_PRED", "K_PRAGMA", "K_POPC", "K_PARAM", "K_P", 
                      "K_OR", "K_OC", "K_NUMBER", "K_NUM", "K_NS", "K_NOUNROLL", 
                      "T_STRING", "K_NOTANUMBER", "K_NORMALIZED_COORDS", 
                      "K_NORMAL", "K_NEU", "K_NE", "K_NAN", "K_MINNCTAPERSM", 
                      "K_MIN", "K_MAXNTID", "K_MAXNREG", "K_MAXNCTAPERSM", 
                      "K_MAX", "K_LU", "K_LTU", "K_LT", "K_LS", "K_LOCAL", 
                      "K_LOC", "K_LO", "K_LEU", "K_LE", "K_L2", "K_L1", 
                      "K_INFINITE", "K_INC", "K_HS", "K_HI", "K_HEIGHT", 
                      "K_GTU", "K_GT", "K_GLOBAL", "K_GL", "K_GEU", "K_GE", 
                      "K_FUNC", "K_WEAK", "K_FULL", "K_FTZ", "K_FINITE", 
                      "K_FILTER_MODE", "K_FILE", "K_F64", "K_F4E", "K_F32", 
                      "K_F16", "K_EXTERN", "K_EXCH", "K_EQU", "K_EQ", "K_ENTRY", 
                      "K_ECR", "K_ECL", "K_DWARF", "K_DEPTH", "K_DEC", "K_CV", 
                      "K_CTA", "K_CS", "K_CONST", "K_CLAMP", "K_CHANNEL_ORDER", 
                      "K_CHANNEL_DATA_TYPE", "K_CHANNEL_DATA", "K_CG", "K_CC", 
                      "K_CAS", "K_CALLTARGETS", "K_CALLPROTOTYPE", "K_CA", 
                      "K_BRANCHTARGETS", "K_BALLOT", "K_B8", "K_B64", "K_B4E", 
                      "K_B32", "K_B16", "K_ARRIVE", "K_APPROX", "K_ANY", 
                      "K_AND", "K_ALL", "K_ALIGN", "K_ADDR_MODE_2", "K_ADDR_MODE_1", 
                      "K_ADDR_MODE_0", "K_ADDRESS_SIZE", "K_ADD", "K_X", 
                      "K_Y", "K_Z", "K_W", "K_A", "K_R", "K_G", "K_B", "COMMENT", 
                      "WS", "T_WORD", "T_UNDERSCORE", "T_AT", "T_PERCENT", 
                      "T_SLASH", "T_DOT" ]

    RULE_prog = 0
    RULE_version = 1
    RULE_target = 2
    RULE_address_size = 3
    RULE_target_list = 4
    RULE_statement = 5
    RULE_label_decl = 6
    RULE_semicolon_terminated_statement = 7
    RULE_unterminated_statement = 8
    RULE_semicolon_terminated_directive = 9
    RULE_unterminated_directive = 10
    RULE_entry = 11
    RULE_entry_aux = 12
    RULE_kernel_name = 13
    RULE_entry_param_list = 14
    RULE_entry_param = 15
    RULE_entry_space = 16
    RULE_align = 17
    RULE_byte_count = 18
    RULE_entry_param_type = 19
    RULE_entry_body = 20
    RULE_fundamental_type = 21
    RULE_fundamental_type_aux = 22
    RULE_vector_type = 23
    RULE_vector_type_aux = 24
    RULE_opaque_type = 25
    RULE_opaque_type_aux = 26
    RULE_func = 27
    RULE_func_aux = 28
    RULE_func_name = 29
    RULE_func_ret_list = 30
    RULE_func_ret = 31
    RULE_func_ret_space = 32
    RULE_func_ret_type = 33
    RULE_func_param_list = 34
    RULE_func_param = 35
    RULE_func_param_space = 36
    RULE_func_param_type = 37
    RULE_func_body = 38
    RULE_control_flow_directive = 39
    RULE_branch_targets = 40
    RULE_list_of_labels = 41
    RULE_call_targets = 42
    RULE_call_prototype = 43
    RULE_call_param_list = 44
    RULE_call_param = 45
    RULE_call_param_space = 46
    RULE_call_param_type = 47
    RULE_performance_tuning_directives = 48
    RULE_performance_tuning_directive = 49
    RULE_maxnreg = 50
    RULE_maxntid = 51
    RULE_reqntid = 52
    RULE_minnctapersm = 53
    RULE_maxnctapersm = 54
    RULE_pragma = 55
    RULE_list_of_strings = 56
    RULE_debugging_directive = 57
    RULE_dwarf = 58
    RULE_filef = 59
    RULE_section = 60
    RULE_section_name = 61
    RULE_data_declarator_list = 62
    RULE_loc = 63
    RULE_linking_directive = 64
    RULE_extern_ = 65
    RULE_visible = 66
    RULE_identifier_decl = 67
    RULE_identifier_decl_aux = 68
    RULE_variable_declarator_list = 69
    RULE_variable_declarator_list_with_initializer = 70
    RULE_variable_declarator = 71
    RULE_array_spec = 72
    RULE_array_spec_aux = 73
    RULE_parameterized_register_spec = 74
    RULE_id_or_opcode = 75
    RULE_opcode = 76
    RULE_variable_declarator_with_initializer = 77
    RULE_variable_equal_initializer = 78
    RULE_variable_initializer = 79
    RULE_aggregate_initializer = 80
    RULE_typet = 81
    RULE_idi = 82
    RULE_state_space_specifier = 83
    RULE_state_space_specifier_aux = 84
    RULE_global_space_specifier = 85
    RULE_const_space_specifier = 86
    RULE_const_ = 87
    RULE_globalg = 88
    RULE_local = 89
    RULE_param = 90
    RULE_reg = 91
    RULE_shared = 92
    RULE_sreg = 93
    RULE_tex = 94
    RULE_instruction = 95
    RULE_instruction_aux = 96
    RULE_predicate = 97
    RULE_i_abs = 98
    RULE_i_abs_type = 99
    RULE_i_abs_opr = 100
    RULE_i_add = 101
    RULE_i_add_type = 102
    RULE_i_add_opr = 103
    RULE_i_addc = 104
    RULE_i_addc_type = 105
    RULE_i_addc_opr = 106
    RULE_i_and = 107
    RULE_i_and_type = 108
    RULE_i_and_opr = 109
    RULE_i_atom = 110
    RULE_i_atom_type = 111
    RULE_i_atom_opr = 112
    RULE_i_bar = 113
    RULE_i_bar1 = 114
    RULE_i_bar1_type = 115
    RULE_i_bar1_opr = 116
    RULE_i_bar2 = 117
    RULE_i_bar2_type = 118
    RULE_i_bar2_opr = 119
    RULE_i_bar3 = 120
    RULE_i_bar3_type = 121
    RULE_i_bar3_opr = 122
    RULE_i_bar4 = 123
    RULE_i_bar4_type = 124
    RULE_i_bar4_opr = 125
    RULE_i_bfe = 126
    RULE_i_bfe_type = 127
    RULE_i_bfe_opr = 128
    RULE_i_bfi = 129
    RULE_i_bfi_type = 130
    RULE_i_bfi_opr = 131
    RULE_i_bfind = 132
    RULE_i_bfind_type = 133
    RULE_i_bfind_opr = 134
    RULE_i_bra = 135
    RULE_i_bra_type = 136
    RULE_i_bra_opr = 137
    RULE_i_brev = 138
    RULE_i_brev_type = 139
    RULE_i_brev_opr = 140
    RULE_i_brkpt = 141
    RULE_i_call = 142
    RULE_i_call_type = 143
    RULE_flist = 144
    RULE_fproto = 145
    RULE_i_clz = 146
    RULE_i_clz_type = 147
    RULE_i_clz_opr = 148
    RULE_i_cnot = 149
    RULE_i_cnot_type = 150
    RULE_i_cnot_opr = 151
    RULE_i_copysign = 152
    RULE_i_copysign_type = 153
    RULE_i_copysign_opr = 154
    RULE_i_cos = 155
    RULE_i_cos_type = 156
    RULE_i_cos_opr = 157
    RULE_i_cvt = 158
    RULE_i_cvt_type = 159
    RULE_i_cvt_irnd = 160
    RULE_i_cvt_irnd_aux = 161
    RULE_i_cvt_frnd = 162
    RULE_i_cvt_frnd_aux = 163
    RULE_i_cvt_opr = 164
    RULE_i_cvta = 165
    RULE_i_cvta_type = 166
    RULE_i_cvta_opr = 167
    RULE_i_div = 168
    RULE_i_div_type = 169
    RULE_i_div_opr = 170
    RULE_i_ex2 = 171
    RULE_i_ex2_type = 172
    RULE_i_ex2_opr = 173
    RULE_i_exit = 174
    RULE_i_fma = 175
    RULE_i_fma_type = 176
    RULE_i_fma_opr = 177
    RULE_i_isspacep = 178
    RULE_i_isspacep_type = 179
    RULE_i_isspacep_opr = 180
    RULE_i_ld = 181
    RULE_i_ld_type = 182
    RULE_i_ld_opr = 183
    RULE_i_ldu = 184
    RULE_i_ldu_type = 185
    RULE_i_ldu_opr = 186
    RULE_i_lg2 = 187
    RULE_i_lg2_type = 188
    RULE_i_lg2_opr = 189
    RULE_i_mad = 190
    RULE_i_mad_type = 191
    RULE_i_mad_opr = 192
    RULE_i_madc = 193
    RULE_i_madc_type = 194
    RULE_i_madc_opr = 195
    RULE_i_mad24 = 196
    RULE_i_mad24_type = 197
    RULE_i_mad24_opr = 198
    RULE_i_max = 199
    RULE_i_max_type = 200
    RULE_i_max_opr = 201
    RULE_i_membar = 202
    RULE_i_membar_type = 203
    RULE_i_min = 204
    RULE_i_min_type = 205
    RULE_i_min_opr = 206
    RULE_i_mov = 207
    RULE_i_mov_type = 208
    RULE_i_mov_opr = 209
    RULE_i_mul = 210
    RULE_i_mul_type = 211
    RULE_i_mul_opr = 212
    RULE_i_mul24 = 213
    RULE_i_mul24_type = 214
    RULE_i_mul24_opr = 215
    RULE_i_neg = 216
    RULE_i_neg_type = 217
    RULE_i_neg_opr = 218
    RULE_i_not = 219
    RULE_i_not_type = 220
    RULE_i_not_opr = 221
    RULE_i_or = 222
    RULE_i_or_type = 223
    RULE_i_or_opr = 224
    RULE_i_pmevent = 225
    RULE_i_pmevent_opr = 226
    RULE_i_popc = 227
    RULE_i_popc_type = 228
    RULE_i_popc_opr = 229
    RULE_i_prefetch = 230
    RULE_i_prefetch_type = 231
    RULE_i_prefetch_opr = 232
    RULE_i_prefetchu = 233
    RULE_i_prefetchu_type = 234
    RULE_i_prefetchu_opr = 235
    RULE_i_prmt = 236
    RULE_i_prmt_type = 237
    RULE_i_prmt_opr = 238
    RULE_i_rcp = 239
    RULE_i_rcp_type = 240
    RULE_i_rcp_opr = 241
    RULE_i_red = 242
    RULE_i_red_type = 243
    RULE_i_red_opr = 244
    RULE_i_rem = 245
    RULE_i_rem_type = 246
    RULE_i_rem_opr = 247
    RULE_i_ret = 248
    RULE_i_ret_type = 249
    RULE_i_rsqrt = 250
    RULE_i_rsqrt_type = 251
    RULE_i_rsqrt_opr = 252
    RULE_i_sad = 253
    RULE_i_sad_type = 254
    RULE_i_sad_opr = 255
    RULE_i_selp = 256
    RULE_i_selp_type = 257
    RULE_i_selp_opr = 258
    RULE_i_set = 259
    RULE_i_set1 = 260
    RULE_i_set1_type = 261
    RULE_i_set1_opr = 262
    RULE_i_set2 = 263
    RULE_i_set2_type = 264
    RULE_i_set2_opr = 265
    RULE_i_setp = 266
    RULE_i_setp1 = 267
    RULE_i_setp1_type = 268
    RULE_i_setp1_opr = 269
    RULE_i_setp2 = 270
    RULE_i_setp2_type = 271
    RULE_i_setp2_opr = 272
    RULE_i_shl = 273
    RULE_i_shl_type = 274
    RULE_i_shl_opr = 275
    RULE_i_shr = 276
    RULE_i_shr_type = 277
    RULE_i_shr_opr = 278
    RULE_i_sin = 279
    RULE_i_sin_type = 280
    RULE_i_sin_opr = 281
    RULE_i_slct = 282
    RULE_i_slct_type = 283
    RULE_i_slct_opr = 284
    RULE_i_sqrt = 285
    RULE_i_sqrt_type = 286
    RULE_i_sqrt_opr = 287
    RULE_i_st = 288
    RULE_i_st_type = 289
    RULE_i_st_opr = 290
    RULE_i_sub = 291
    RULE_i_sub_type = 292
    RULE_i_sub_opr = 293
    RULE_i_subc = 294
    RULE_i_subc_type = 295
    RULE_i_subc_opr = 296
    RULE_i_suld = 297
    RULE_i_suld_type = 298
    RULE_i_suld_opr = 299
    RULE_i_sured = 300
    RULE_i_sured_type = 301
    RULE_i_sured_opr = 302
    RULE_i_sust = 303
    RULE_i_sust_type = 304
    RULE_i_sust_opr = 305
    RULE_i_suq = 306
    RULE_i_suq_type = 307
    RULE_i_suq_opr = 308
    RULE_i_testp = 309
    RULE_i_testp_type = 310
    RULE_i_testp_opr = 311
    RULE_i_tex = 312
    RULE_i_tex_type = 313
    RULE_i_tex_opr = 314
    RULE_i_txq = 315
    RULE_i_txq_type = 316
    RULE_i_txq_opr = 317
    RULE_i_trap = 318
    RULE_i_vabsdiff = 319
    RULE_i_vadd = 320
    RULE_i_vmad = 321
    RULE_i_vmax = 322
    RULE_i_vmin = 323
    RULE_i_vset = 324
    RULE_i_vshl = 325
    RULE_i_vshr = 326
    RULE_i_vsub = 327
    RULE_i_vote = 328
    RULE_i_vote_type = 329
    RULE_i_vote_opr = 330
    RULE_i_xor = 331
    RULE_i_xor_type = 332
    RULE_i_xor_opr = 333
    RULE_opr_register = 334
    RULE_opr_register_or_constant = 335
    RULE_opr_register_or_constant2 = 336
    RULE_opr_register_or_constant3 = 337
    RULE_opr_register_or_constant4 = 338
    RULE_opr_register_or_constant5 = 339
    RULE_opr_label = 340
    RULE_opr = 341
    RULE_opr_aux = 342
    RULE_opr2 = 343
    RULE_opr3 = 344
    RULE_opr4 = 345
    RULE_opr5 = 346
    RULE_constant_expression = 347
    RULE_constant_expression_aux = 348
    RULE_conditional_expression = 349
    RULE_conditional_or_expression = 350
    RULE_conditional_and_expression = 351
    RULE_inclusive_or_expression = 352
    RULE_exclusive_or_expression = 353
    RULE_and_expression = 354
    RULE_equality_expression = 355
    RULE_relational_expression = 356
    RULE_relational_op = 357
    RULE_shift_expression = 358
    RULE_shift_op = 359
    RULE_additive_expression = 360
    RULE_multiplicative_expression = 361
    RULE_unary_expression = 362
    RULE_unary_expression_not_plus_minus = 363
    RULE_cast_expression = 364
    RULE_cast_expression_aux = 365
    RULE_primary = 366
    RULE_par_expression = 367
    RULE_integer = 368
    RULE_float_ = 369
    RULE_base_10_integer = 370
    RULE_base_8_integer = 371
    RULE_base_16_integer = 372

    ruleNames =  [ "prog", "version", "target", "address_size", "target_list", 
                   "statement", "label_decl", "semicolon_terminated_statement", 
                   "unterminated_statement", "semicolon_terminated_directive", 
                   "unterminated_directive", "entry", "entry_aux", "kernel_name", 
                   "entry_param_list", "entry_param", "entry_space", "align", 
                   "byte_count", "entry_param_type", "entry_body", "fundamental_type", 
                   "fundamental_type_aux", "vector_type", "vector_type_aux", 
                   "opaque_type", "opaque_type_aux", "func", "func_aux", 
                   "func_name", "func_ret_list", "func_ret", "func_ret_space", 
                   "func_ret_type", "func_param_list", "func_param", "func_param_space", 
                   "func_param_type", "func_body", "control_flow_directive", 
                   "branch_targets", "list_of_labels", "call_targets", "call_prototype", 
                   "call_param_list", "call_param", "call_param_space", 
                   "call_param_type", "performance_tuning_directives", "performance_tuning_directive", 
                   "maxnreg", "maxntid", "reqntid", "minnctapersm", "maxnctapersm", 
                   "pragma", "list_of_strings", "debugging_directive", "dwarf", 
                   "filef", "section", "section_name", "data_declarator_list", 
                   "loc", "linking_directive", "extern_", "visible", "identifier_decl", 
                   "identifier_decl_aux", "variable_declarator_list", "variable_declarator_list_with_initializer", 
                   "variable_declarator", "array_spec", "array_spec_aux", 
                   "parameterized_register_spec", "id_or_opcode", "opcode", 
                   "variable_declarator_with_initializer", "variable_equal_initializer", 
                   "variable_initializer", "aggregate_initializer", "typet", 
                   "idi", "state_space_specifier", "state_space_specifier_aux", 
                   "global_space_specifier", "const_space_specifier", "const_", 
                   "globalg", "local", "param", "reg", "shared", "sreg", 
                   "tex", "instruction", "instruction_aux", "predicate", 
                   "i_abs", "i_abs_type", "i_abs_opr", "i_add", "i_add_type", 
                   "i_add_opr", "i_addc", "i_addc_type", "i_addc_opr", "i_and", 
                   "i_and_type", "i_and_opr", "i_atom", "i_atom_type", "i_atom_opr", 
                   "i_bar", "i_bar1", "i_bar1_type", "i_bar1_opr", "i_bar2", 
                   "i_bar2_type", "i_bar2_opr", "i_bar3", "i_bar3_type", 
                   "i_bar3_opr", "i_bar4", "i_bar4_type", "i_bar4_opr", 
                   "i_bfe", "i_bfe_type", "i_bfe_opr", "i_bfi", "i_bfi_type", 
                   "i_bfi_opr", "i_bfind", "i_bfind_type", "i_bfind_opr", 
                   "i_bra", "i_bra_type", "i_bra_opr", "i_brev", "i_brev_type", 
                   "i_brev_opr", "i_brkpt", "i_call", "i_call_type", "flist", 
                   "fproto", "i_clz", "i_clz_type", "i_clz_opr", "i_cnot", 
                   "i_cnot_type", "i_cnot_opr", "i_copysign", "i_copysign_type", 
                   "i_copysign_opr", "i_cos", "i_cos_type", "i_cos_opr", 
                   "i_cvt", "i_cvt_type", "i_cvt_irnd", "i_cvt_irnd_aux", 
                   "i_cvt_frnd", "i_cvt_frnd_aux", "i_cvt_opr", "i_cvta", 
                   "i_cvta_type", "i_cvta_opr", "i_div", "i_div_type", "i_div_opr", 
                   "i_ex2", "i_ex2_type", "i_ex2_opr", "i_exit", "i_fma", 
                   "i_fma_type", "i_fma_opr", "i_isspacep", "i_isspacep_type", 
                   "i_isspacep_opr", "i_ld", "i_ld_type", "i_ld_opr", "i_ldu", 
                   "i_ldu_type", "i_ldu_opr", "i_lg2", "i_lg2_type", "i_lg2_opr", 
                   "i_mad", "i_mad_type", "i_mad_opr", "i_madc", "i_madc_type", 
                   "i_madc_opr", "i_mad24", "i_mad24_type", "i_mad24_opr", 
                   "i_max", "i_max_type", "i_max_opr", "i_membar", "i_membar_type", 
                   "i_min", "i_min_type", "i_min_opr", "i_mov", "i_mov_type", 
                   "i_mov_opr", "i_mul", "i_mul_type", "i_mul_opr", "i_mul24", 
                   "i_mul24_type", "i_mul24_opr", "i_neg", "i_neg_type", 
                   "i_neg_opr", "i_not", "i_not_type", "i_not_opr", "i_or", 
                   "i_or_type", "i_or_opr", "i_pmevent", "i_pmevent_opr", 
                   "i_popc", "i_popc_type", "i_popc_opr", "i_prefetch", 
                   "i_prefetch_type", "i_prefetch_opr", "i_prefetchu", "i_prefetchu_type", 
                   "i_prefetchu_opr", "i_prmt", "i_prmt_type", "i_prmt_opr", 
                   "i_rcp", "i_rcp_type", "i_rcp_opr", "i_red", "i_red_type", 
                   "i_red_opr", "i_rem", "i_rem_type", "i_rem_opr", "i_ret", 
                   "i_ret_type", "i_rsqrt", "i_rsqrt_type", "i_rsqrt_opr", 
                   "i_sad", "i_sad_type", "i_sad_opr", "i_selp", "i_selp_type", 
                   "i_selp_opr", "i_set", "i_set1", "i_set1_type", "i_set1_opr", 
                   "i_set2", "i_set2_type", "i_set2_opr", "i_setp", "i_setp1", 
                   "i_setp1_type", "i_setp1_opr", "i_setp2", "i_setp2_type", 
                   "i_setp2_opr", "i_shl", "i_shl_type", "i_shl_opr", "i_shr", 
                   "i_shr_type", "i_shr_opr", "i_sin", "i_sin_type", "i_sin_opr", 
                   "i_slct", "i_slct_type", "i_slct_opr", "i_sqrt", "i_sqrt_type", 
                   "i_sqrt_opr", "i_st", "i_st_type", "i_st_opr", "i_sub", 
                   "i_sub_type", "i_sub_opr", "i_subc", "i_subc_type", "i_subc_opr", 
                   "i_suld", "i_suld_type", "i_suld_opr", "i_sured", "i_sured_type", 
                   "i_sured_opr", "i_sust", "i_sust_type", "i_sust_opr", 
                   "i_suq", "i_suq_type", "i_suq_opr", "i_testp", "i_testp_type", 
                   "i_testp_opr", "i_tex", "i_tex_type", "i_tex_opr", "i_txq", 
                   "i_txq_type", "i_txq_opr", "i_trap", "i_vabsdiff", "i_vadd", 
                   "i_vmad", "i_vmax", "i_vmin", "i_vset", "i_vshl", "i_vshr", 
                   "i_vsub", "i_vote", "i_vote_type", "i_vote_opr", "i_xor", 
                   "i_xor_type", "i_xor_opr", "opr_register", "opr_register_or_constant", 
                   "opr_register_or_constant2", "opr_register_or_constant3", 
                   "opr_register_or_constant4", "opr_register_or_constant5", 
                   "opr_label", "opr", "opr_aux", "opr2", "opr3", "opr4", 
                   "opr5", "constant_expression", "constant_expression_aux", 
                   "conditional_expression", "conditional_or_expression", 
                   "conditional_and_expression", "inclusive_or_expression", 
                   "exclusive_or_expression", "and_expression", "equality_expression", 
                   "relational_expression", "relational_op", "shift_expression", 
                   "shift_op", "additive_expression", "multiplicative_expression", 
                   "unary_expression", "unary_expression_not_plus_minus", 
                   "cast_expression", "cast_expression_aux", "primary", 
                   "par_expression", "integer", "float_", "base_10_integer", 
                   "base_8_integer", "base_16_integer" ]

    EOF = Token.EOF
    KI_ABS=1
    KI_ADD=2
    KI_ADDC=3
    KI_AND=4
    KI_ATOM=5
    KI_BAR=6
    KI_BFE=7
    KI_BFI=8
    KI_BFIND=9
    KI_BRA=10
    KI_BREV=11
    KI_BRKPT=12
    KI_CALL=13
    KI_CLZ=14
    KI_CNOT=15
    KI_COPYSIGN=16
    KI_COS=17
    KI_CVT=18
    KI_CVTA=19
    KI_DIV=20
    KI_EX2=21
    KI_EXIT=22
    KI_FMA=23
    KI_ISSPACEP=24
    KI_LD=25
    KI_LDU=26
    KI_LG2=27
    KI_MAD24=28
    KI_MAD=29
    KI_MADC=30
    KI_MAX=31
    KI_MEMBAR=32
    KI_MIN=33
    KI_MOV=34
    KI_MUL24=35
    KI_MUL=36
    KI_NEG=37
    KI_NOT=38
    KI_OR=39
    KI_PMEVENT=40
    KI_POPC=41
    KI_PREFETCH=42
    KI_PREFETCHU=43
    KI_PRMT=44
    KI_RCP=45
    KI_RED=46
    KI_REM=47
    KI_RET=48
    KI_RSQRT=49
    KI_SAD=50
    KI_SELP=51
    KI_SETP=52
    KI_SET=53
    KI_SHL=54
    KI_SHR=55
    KI_SIN=56
    KI_SLCT=57
    KI_SQRT=58
    KI_ST=59
    KI_SUB=60
    KI_SUBC=61
    KI_SULD=62
    KI_SUQ=63
    KI_SURED=64
    KI_SUST=65
    KI_TESTP=66
    KI_TEX=67
    KI_TRAP=68
    KI_TXQ=69
    KI_VABSDIFF=70
    KI_VADD=71
    KI_VMAD=72
    KI_VMAX=73
    KI_VMIN=74
    KI_VOTE=75
    KI_VSET=76
    KI_VSHL=77
    KI_VSHR=78
    KI_VSUB=79
    KI_XOR=80
    T_QUESTION=81
    T_OROR=82
    T_ANDAND=83
    T_OR=84
    T_XOR=85
    T_AND=86
    T_EQEQ=87
    T_LE=88
    T_GE=89
    T_LTLT=90
    T_GTGT=91
    T_STAR=92
    T_TILDE=93
    T_FLT_LITERAL=94
    T_HEX_LITERAL=95
    T_OCT_LITERAL=96
    T_DEC_LITERAL=97
    K_3D=98
    K_2D=99
    K_1D=100
    U_DEBUG_ABBREV=101
    U_DEBUG_INFO=102
    U_DEBUG_LINE=103
    U_DEBUG_LOC=104
    U_DEBUG_PUBNAMES=105
    U_DEBUG_RANGES=106
    U_BYTE=107
    U_4BYTE=108
    T_EQ=109
    T_SEMICOLON=110
    T_PLUS=111
    T_OP=112
    T_OC=113
    T_OB=114
    T_NOTEQ=115
    T_NOT=116
    T_MINUS=117
    T_GT=118
    T_LT=119
    T_ELLIPSIS=120
    T_CP=121
    T_COMMA=122
    T_COLON=123
    T_CC=124
    T_CB=125
    LINE_COMMENT=126
    K_ZERO=127
    K_XOR=128
    K_WT=129
    K_WIDTH=130
    K_WIDE=131
    K_WB=132
    K_VOLATILE=133
    K_VISIBLE=134
    K_VERSION=135
    K_VB=136
    K_V4=137
    K_V2=138
    K_UNI=139
    K_U8=140
    K_U64=141
    K_U32=142
    K_U16=143
    K_TRAP=144
    K_TO=145
    K_TEXREF=146
    K_TEX=147
    K_TARGET=148
    K_SYS=149
    K_SYNC=150
    K_SURFREF=151
    K_SUBNORMAL=152
    K_SREG=153
    K_SHIFTAMT=154
    K_SHARED=155
    K_SECTION=156
    K_SAT=157
    K_SAMPLERREF=158
    K_S8=159
    K_S64=160
    K_S32=161
    K_S16=162
    K_RZI=163
    K_RZ=164
    K_RPI=165
    K_RP=166
    K_RNI=167
    K_RN=168
    K_RMI=169
    K_RM=170
    K_REQNTID=171
    K_REG=172
    K_RED=173
    K_RCP=174
    K_RC8=175
    K_RC16=176
    K_PRED=177
    K_PRAGMA=178
    K_POPC=179
    K_PARAM=180
    K_P=181
    K_OR=182
    K_OC=183
    K_NUMBER=184
    K_NUM=185
    K_NS=186
    K_NOUNROLL=187
    T_STRING=188
    K_NOTANUMBER=189
    K_NORMALIZED_COORDS=190
    K_NORMAL=191
    K_NEU=192
    K_NE=193
    K_NAN=194
    K_MINNCTAPERSM=195
    K_MIN=196
    K_MAXNTID=197
    K_MAXNREG=198
    K_MAXNCTAPERSM=199
    K_MAX=200
    K_LU=201
    K_LTU=202
    K_LT=203
    K_LS=204
    K_LOCAL=205
    K_LOC=206
    K_LO=207
    K_LEU=208
    K_LE=209
    K_L2=210
    K_L1=211
    K_INFINITE=212
    K_INC=213
    K_HS=214
    K_HI=215
    K_HEIGHT=216
    K_GTU=217
    K_GT=218
    K_GLOBAL=219
    K_GL=220
    K_GEU=221
    K_GE=222
    K_FUNC=223
    K_WEAK=224
    K_FULL=225
    K_FTZ=226
    K_FINITE=227
    K_FILTER_MODE=228
    K_FILE=229
    K_F64=230
    K_F4E=231
    K_F32=232
    K_F16=233
    K_EXTERN=234
    K_EXCH=235
    K_EQU=236
    K_EQ=237
    K_ENTRY=238
    K_ECR=239
    K_ECL=240
    K_DWARF=241
    K_DEPTH=242
    K_DEC=243
    K_CV=244
    K_CTA=245
    K_CS=246
    K_CONST=247
    K_CLAMP=248
    K_CHANNEL_ORDER=249
    K_CHANNEL_DATA_TYPE=250
    K_CHANNEL_DATA=251
    K_CG=252
    K_CC=253
    K_CAS=254
    K_CALLTARGETS=255
    K_CALLPROTOTYPE=256
    K_CA=257
    K_BRANCHTARGETS=258
    K_BALLOT=259
    K_B8=260
    K_B64=261
    K_B4E=262
    K_B32=263
    K_B16=264
    K_ARRIVE=265
    K_APPROX=266
    K_ANY=267
    K_AND=268
    K_ALL=269
    K_ALIGN=270
    K_ADDR_MODE_2=271
    K_ADDR_MODE_1=272
    K_ADDR_MODE_0=273
    K_ADDRESS_SIZE=274
    K_ADD=275
    K_X=276
    K_Y=277
    K_Z=278
    K_W=279
    K_A=280
    K_R=281
    K_G=282
    K_B=283
    COMMENT=284
    WS=285
    T_WORD=286
    T_UNDERSCORE=287
    T_AT=288
    T_PERCENT=289
    T_SLASH=290
    T_DOT=291

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def version(self):
            return self.getTypedRuleContext(PtxParser.VersionContext,0)


        def target(self):
            return self.getTypedRuleContext(PtxParser.TargetContext,0)


        def EOF(self):
            return self.getToken(PtxParser.EOF, 0)

        def address_size(self):
            return self.getTypedRuleContext(PtxParser.Address_sizeContext,0)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.StatementContext)
            else:
                return self.getTypedRuleContext(PtxParser.StatementContext,i)


        def getRuleIndex(self):
            return PtxParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)




    def prog(self):

        localctx = PtxParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 746
            self.version()
            self.state = 747
            self.target()
            self.state = 749
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_ADDRESS_SIZE:
                self.state = 748
                self.address_size()


            self.state = 752 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 751
                self.statement()
                self.state = 754 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PtxParser.KI_ABS) | (1 << PtxParser.KI_ADD) | (1 << PtxParser.KI_ADDC) | (1 << PtxParser.KI_AND) | (1 << PtxParser.KI_ATOM) | (1 << PtxParser.KI_BAR) | (1 << PtxParser.KI_BFE) | (1 << PtxParser.KI_BFI) | (1 << PtxParser.KI_BFIND) | (1 << PtxParser.KI_BRA) | (1 << PtxParser.KI_BREV) | (1 << PtxParser.KI_BRKPT) | (1 << PtxParser.KI_CALL) | (1 << PtxParser.KI_CLZ) | (1 << PtxParser.KI_CNOT) | (1 << PtxParser.KI_COPYSIGN) | (1 << PtxParser.KI_COS) | (1 << PtxParser.KI_CVT) | (1 << PtxParser.KI_CVTA) | (1 << PtxParser.KI_DIV) | (1 << PtxParser.KI_EX2) | (1 << PtxParser.KI_EXIT) | (1 << PtxParser.KI_FMA) | (1 << PtxParser.KI_ISSPACEP) | (1 << PtxParser.KI_LD) | (1 << PtxParser.KI_LDU) | (1 << PtxParser.KI_LG2) | (1 << PtxParser.KI_MAD24) | (1 << PtxParser.KI_MAD) | (1 << PtxParser.KI_MADC) | (1 << PtxParser.KI_MAX) | (1 << PtxParser.KI_MEMBAR) | (1 << PtxParser.KI_MIN) | (1 << PtxParser.KI_MOV) | (1 << PtxParser.KI_MUL24) | (1 << PtxParser.KI_MUL) | (1 << PtxParser.KI_NEG) | (1 << PtxParser.KI_NOT) | (1 << PtxParser.KI_OR) | (1 << PtxParser.KI_PMEVENT) | (1 << PtxParser.KI_POPC) | (1 << PtxParser.KI_PREFETCH) | (1 << PtxParser.KI_PREFETCHU) | (1 << PtxParser.KI_PRMT) | (1 << PtxParser.KI_RCP) | (1 << PtxParser.KI_RED) | (1 << PtxParser.KI_REM) | (1 << PtxParser.KI_RET) | (1 << PtxParser.KI_RSQRT) | (1 << PtxParser.KI_SAD) | (1 << PtxParser.KI_SELP) | (1 << PtxParser.KI_SETP) | (1 << PtxParser.KI_SET) | (1 << PtxParser.KI_SHL) | (1 << PtxParser.KI_SHR) | (1 << PtxParser.KI_SIN) | (1 << PtxParser.KI_SLCT) | (1 << PtxParser.KI_SQRT) | (1 << PtxParser.KI_ST) | (1 << PtxParser.KI_SUB) | (1 << PtxParser.KI_SUBC) | (1 << PtxParser.KI_SULD) | (1 << PtxParser.KI_SUQ))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (PtxParser.KI_SURED - 64)) | (1 << (PtxParser.KI_SUST - 64)) | (1 << (PtxParser.KI_TESTP - 64)) | (1 << (PtxParser.KI_TEX - 64)) | (1 << (PtxParser.KI_TRAP - 64)) | (1 << (PtxParser.KI_TXQ - 64)) | (1 << (PtxParser.KI_VABSDIFF - 64)) | (1 << (PtxParser.KI_VADD - 64)) | (1 << (PtxParser.KI_VMAD - 64)) | (1 << (PtxParser.KI_VMAX - 64)) | (1 << (PtxParser.KI_VMIN - 64)) | (1 << (PtxParser.KI_VOTE - 64)) | (1 << (PtxParser.KI_VSET - 64)) | (1 << (PtxParser.KI_VSHL - 64)) | (1 << (PtxParser.KI_VSHR - 64)) | (1 << (PtxParser.KI_VSUB - 64)) | (1 << (PtxParser.KI_XOR - 64)) | (1 << (PtxParser.T_OC - 64)))) != 0) or ((((_la - 134)) & ~0x3f) == 0 and ((1 << (_la - 134)) & ((1 << (PtxParser.K_VISIBLE - 134)) | (1 << (PtxParser.K_TEX - 134)) | (1 << (PtxParser.K_SREG - 134)) | (1 << (PtxParser.K_SHARED - 134)) | (1 << (PtxParser.K_SECTION - 134)) | (1 << (PtxParser.K_REG - 134)) | (1 << (PtxParser.K_PRAGMA - 134)) | (1 << (PtxParser.K_PARAM - 134)))) != 0) or ((((_la - 205)) & ~0x3f) == 0 and ((1 << (_la - 205)) & ((1 << (PtxParser.K_LOCAL - 205)) | (1 << (PtxParser.K_LOC - 205)) | (1 << (PtxParser.K_GLOBAL - 205)) | (1 << (PtxParser.K_FUNC - 205)) | (1 << (PtxParser.K_WEAK - 205)) | (1 << (PtxParser.K_FILE - 205)) | (1 << (PtxParser.K_EXTERN - 205)) | (1 << (PtxParser.K_ENTRY - 205)) | (1 << (PtxParser.K_DWARF - 205)) | (1 << (PtxParser.K_CONST - 205)))) != 0) or ((((_la - 270)) & ~0x3f) == 0 and ((1 << (_la - 270)) & ((1 << (PtxParser.K_ALIGN - 270)) | (1 << (PtxParser.T_WORD - 270)) | (1 << (PtxParser.T_AT - 270)))) != 0)):
                    break

            self.state = 756
            self.match(PtxParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VersionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_VERSION(self):
            return self.getToken(PtxParser.K_VERSION, 0)

        def float_(self):
            return self.getTypedRuleContext(PtxParser.Float_Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_version

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersion" ):
                listener.enterVersion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersion" ):
                listener.exitVersion(self)




    def version(self):

        localctx = PtxParser.VersionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_version)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 758
            self.match(PtxParser.K_VERSION)
            self.state = 759
            self.float_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TargetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_TARGET(self):
            return self.getToken(PtxParser.K_TARGET, 0)

        def target_list(self):
            return self.getTypedRuleContext(PtxParser.Target_listContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_target

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTarget" ):
                listener.enterTarget(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTarget" ):
                listener.exitTarget(self)




    def target(self):

        localctx = PtxParser.TargetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_target)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 761
            self.match(PtxParser.K_TARGET)
            self.state = 762
            self.target_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Address_sizeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ADDRESS_SIZE(self):
            return self.getToken(PtxParser.K_ADDRESS_SIZE, 0)

        def integer(self):
            return self.getTypedRuleContext(PtxParser.IntegerContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_address_size

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddress_size" ):
                listener.enterAddress_size(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddress_size" ):
                listener.exitAddress_size(self)




    def address_size(self):

        localctx = PtxParser.Address_sizeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_address_size)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 764
            self.match(PtxParser.K_ADDRESS_SIZE)
            self.state = 765
            self.integer()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Target_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_WORD(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_WORD)
            else:
                return self.getToken(PtxParser.T_WORD, i)

        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_target_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTarget_list" ):
                listener.enterTarget_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTarget_list" ):
                listener.exitTarget_list(self)




    def target_list(self):

        localctx = PtxParser.Target_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_target_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 767
            self.match(PtxParser.T_WORD)
            self.state = 772
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_COMMA:
                self.state = 768
                self.match(PtxParser.T_COMMA)
                self.state = 769
                self.match(PtxParser.T_WORD)
                self.state = 774
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label_decl(self):
            return self.getTypedRuleContext(PtxParser.Label_declContext,0)


        def semicolon_terminated_statement(self):
            return self.getTypedRuleContext(PtxParser.Semicolon_terminated_statementContext,0)


        def unterminated_statement(self):
            return self.getTypedRuleContext(PtxParser.Unterminated_statementContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = PtxParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_statement)
        try:
            self.state = 778
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 775
                self.label_decl()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 776
                self.semicolon_terminated_statement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 777
                self.unterminated_statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Label_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_WORD(self):
            return self.getToken(PtxParser.T_WORD, 0)

        def T_COLON(self):
            return self.getToken(PtxParser.T_COLON, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_label_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabel_decl" ):
                listener.enterLabel_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabel_decl" ):
                listener.exitLabel_decl(self)




    def label_decl(self):

        localctx = PtxParser.Label_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_label_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 780
            self.match(PtxParser.T_WORD)
            self.state = 781
            self.match(PtxParser.T_COLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Semicolon_terminated_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_SEMICOLON(self):
            return self.getToken(PtxParser.T_SEMICOLON, 0)

        def semicolon_terminated_directive(self):
            return self.getTypedRuleContext(PtxParser.Semicolon_terminated_directiveContext,0)


        def instruction(self):
            return self.getTypedRuleContext(PtxParser.InstructionContext,0)


        def linking_directive(self):
            return self.getTypedRuleContext(PtxParser.Linking_directiveContext,0)


        def pragma(self):
            return self.getTypedRuleContext(PtxParser.PragmaContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_semicolon_terminated_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSemicolon_terminated_statement" ):
                listener.enterSemicolon_terminated_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSemicolon_terminated_statement" ):
                listener.exitSemicolon_terminated_statement(self)




    def semicolon_terminated_statement(self):

        localctx = PtxParser.Semicolon_terminated_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_semicolon_terminated_statement)
        try:
            self.state = 791
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR, PtxParser.K_VISIBLE, PtxParser.K_TEX, PtxParser.K_SREG, PtxParser.K_SHARED, PtxParser.K_REG, PtxParser.K_PARAM, PtxParser.K_LOCAL, PtxParser.K_GLOBAL, PtxParser.K_EXTERN, PtxParser.K_CONST, PtxParser.K_ALIGN, PtxParser.T_WORD, PtxParser.T_AT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 786
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PtxParser.K_TEX, PtxParser.K_SREG, PtxParser.K_SHARED, PtxParser.K_REG, PtxParser.K_PARAM, PtxParser.K_LOCAL, PtxParser.K_GLOBAL, PtxParser.K_CONST, PtxParser.K_ALIGN, PtxParser.T_WORD]:
                    self.state = 783
                    self.semicolon_terminated_directive()
                    pass
                elif token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR, PtxParser.T_AT]:
                    self.state = 784
                    self.instruction()
                    pass
                elif token in [PtxParser.K_VISIBLE, PtxParser.K_EXTERN]:
                    self.state = 785
                    self.linking_directive()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 788
                self.match(PtxParser.T_SEMICOLON)
                pass
            elif token in [PtxParser.K_PRAGMA]:
                self.enterOuterAlt(localctx, 2)
                self.state = 790
                self.pragma()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Unterminated_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unterminated_directive(self):
            return self.getTypedRuleContext(PtxParser.Unterminated_directiveContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_unterminated_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnterminated_statement" ):
                listener.enterUnterminated_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnterminated_statement" ):
                listener.exitUnterminated_statement(self)




    def unterminated_statement(self):

        localctx = PtxParser.Unterminated_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_unterminated_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 793
            self.unterminated_directive()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Semicolon_terminated_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def control_flow_directive(self):
            return self.getTypedRuleContext(PtxParser.Control_flow_directiveContext,0)


        def identifier_decl(self):
            return self.getTypedRuleContext(PtxParser.Identifier_declContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_semicolon_terminated_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSemicolon_terminated_directive" ):
                listener.enterSemicolon_terminated_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSemicolon_terminated_directive" ):
                listener.exitSemicolon_terminated_directive(self)




    def semicolon_terminated_directive(self):

        localctx = PtxParser.Semicolon_terminated_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_semicolon_terminated_directive)
        try:
            self.state = 797
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.T_WORD]:
                self.enterOuterAlt(localctx, 1)
                self.state = 795
                self.control_flow_directive()
                pass
            elif token in [PtxParser.K_TEX, PtxParser.K_SREG, PtxParser.K_SHARED, PtxParser.K_REG, PtxParser.K_PARAM, PtxParser.K_LOCAL, PtxParser.K_GLOBAL, PtxParser.K_CONST, PtxParser.K_ALIGN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 796
                self.identifier_decl()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Unterminated_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entry(self):
            return self.getTypedRuleContext(PtxParser.EntryContext,0)


        def func(self):
            return self.getTypedRuleContext(PtxParser.FuncContext,0)


        def T_SEMICOLON(self):
            return self.getToken(PtxParser.T_SEMICOLON, 0)

        def debugging_directive(self):
            return self.getTypedRuleContext(PtxParser.Debugging_directiveContext,0)


        def T_OC(self):
            return self.getToken(PtxParser.T_OC, 0)

        def T_CC(self):
            return self.getToken(PtxParser.T_CC, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.StatementContext)
            else:
                return self.getTypedRuleContext(PtxParser.StatementContext,i)


        def getRuleIndex(self):
            return PtxParser.RULE_unterminated_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnterminated_directive" ):
                listener.enterUnterminated_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnterminated_directive" ):
                listener.exitUnterminated_directive(self)




    def unterminated_directive(self):

        localctx = PtxParser.Unterminated_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_unterminated_directive)
        self._la = 0 # Token type
        try:
            self.state = 813
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 799
                self.entry()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 800
                self.func()
                self.state = 802
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.T_SEMICOLON:
                    self.state = 801
                    self.match(PtxParser.T_SEMICOLON)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 804
                self.debugging_directive()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 805
                self.match(PtxParser.T_OC)
                self.state = 807 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 806
                    self.statement()
                    self.state = 809 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PtxParser.KI_ABS) | (1 << PtxParser.KI_ADD) | (1 << PtxParser.KI_ADDC) | (1 << PtxParser.KI_AND) | (1 << PtxParser.KI_ATOM) | (1 << PtxParser.KI_BAR) | (1 << PtxParser.KI_BFE) | (1 << PtxParser.KI_BFI) | (1 << PtxParser.KI_BFIND) | (1 << PtxParser.KI_BRA) | (1 << PtxParser.KI_BREV) | (1 << PtxParser.KI_BRKPT) | (1 << PtxParser.KI_CALL) | (1 << PtxParser.KI_CLZ) | (1 << PtxParser.KI_CNOT) | (1 << PtxParser.KI_COPYSIGN) | (1 << PtxParser.KI_COS) | (1 << PtxParser.KI_CVT) | (1 << PtxParser.KI_CVTA) | (1 << PtxParser.KI_DIV) | (1 << PtxParser.KI_EX2) | (1 << PtxParser.KI_EXIT) | (1 << PtxParser.KI_FMA) | (1 << PtxParser.KI_ISSPACEP) | (1 << PtxParser.KI_LD) | (1 << PtxParser.KI_LDU) | (1 << PtxParser.KI_LG2) | (1 << PtxParser.KI_MAD24) | (1 << PtxParser.KI_MAD) | (1 << PtxParser.KI_MADC) | (1 << PtxParser.KI_MAX) | (1 << PtxParser.KI_MEMBAR) | (1 << PtxParser.KI_MIN) | (1 << PtxParser.KI_MOV) | (1 << PtxParser.KI_MUL24) | (1 << PtxParser.KI_MUL) | (1 << PtxParser.KI_NEG) | (1 << PtxParser.KI_NOT) | (1 << PtxParser.KI_OR) | (1 << PtxParser.KI_PMEVENT) | (1 << PtxParser.KI_POPC) | (1 << PtxParser.KI_PREFETCH) | (1 << PtxParser.KI_PREFETCHU) | (1 << PtxParser.KI_PRMT) | (1 << PtxParser.KI_RCP) | (1 << PtxParser.KI_RED) | (1 << PtxParser.KI_REM) | (1 << PtxParser.KI_RET) | (1 << PtxParser.KI_RSQRT) | (1 << PtxParser.KI_SAD) | (1 << PtxParser.KI_SELP) | (1 << PtxParser.KI_SETP) | (1 << PtxParser.KI_SET) | (1 << PtxParser.KI_SHL) | (1 << PtxParser.KI_SHR) | (1 << PtxParser.KI_SIN) | (1 << PtxParser.KI_SLCT) | (1 << PtxParser.KI_SQRT) | (1 << PtxParser.KI_ST) | (1 << PtxParser.KI_SUB) | (1 << PtxParser.KI_SUBC) | (1 << PtxParser.KI_SULD) | (1 << PtxParser.KI_SUQ))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (PtxParser.KI_SURED - 64)) | (1 << (PtxParser.KI_SUST - 64)) | (1 << (PtxParser.KI_TESTP - 64)) | (1 << (PtxParser.KI_TEX - 64)) | (1 << (PtxParser.KI_TRAP - 64)) | (1 << (PtxParser.KI_TXQ - 64)) | (1 << (PtxParser.KI_VABSDIFF - 64)) | (1 << (PtxParser.KI_VADD - 64)) | (1 << (PtxParser.KI_VMAD - 64)) | (1 << (PtxParser.KI_VMAX - 64)) | (1 << (PtxParser.KI_VMIN - 64)) | (1 << (PtxParser.KI_VOTE - 64)) | (1 << (PtxParser.KI_VSET - 64)) | (1 << (PtxParser.KI_VSHL - 64)) | (1 << (PtxParser.KI_VSHR - 64)) | (1 << (PtxParser.KI_VSUB - 64)) | (1 << (PtxParser.KI_XOR - 64)) | (1 << (PtxParser.T_OC - 64)))) != 0) or ((((_la - 134)) & ~0x3f) == 0 and ((1 << (_la - 134)) & ((1 << (PtxParser.K_VISIBLE - 134)) | (1 << (PtxParser.K_TEX - 134)) | (1 << (PtxParser.K_SREG - 134)) | (1 << (PtxParser.K_SHARED - 134)) | (1 << (PtxParser.K_SECTION - 134)) | (1 << (PtxParser.K_REG - 134)) | (1 << (PtxParser.K_PRAGMA - 134)) | (1 << (PtxParser.K_PARAM - 134)))) != 0) or ((((_la - 205)) & ~0x3f) == 0 and ((1 << (_la - 205)) & ((1 << (PtxParser.K_LOCAL - 205)) | (1 << (PtxParser.K_LOC - 205)) | (1 << (PtxParser.K_GLOBAL - 205)) | (1 << (PtxParser.K_FUNC - 205)) | (1 << (PtxParser.K_WEAK - 205)) | (1 << (PtxParser.K_FILE - 205)) | (1 << (PtxParser.K_EXTERN - 205)) | (1 << (PtxParser.K_ENTRY - 205)) | (1 << (PtxParser.K_DWARF - 205)) | (1 << (PtxParser.K_CONST - 205)))) != 0) or ((((_la - 270)) & ~0x3f) == 0 and ((1 << (_la - 270)) & ((1 << (PtxParser.K_ALIGN - 270)) | (1 << (PtxParser.T_WORD - 270)) | (1 << (PtxParser.T_AT - 270)))) != 0)):
                        break

                self.state = 811
                self.match(PtxParser.T_CC)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EntryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entry_aux(self):
            return self.getTypedRuleContext(PtxParser.Entry_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_entry

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntry" ):
                listener.enterEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntry" ):
                listener.exitEntry(self)




    def entry(self):

        localctx = PtxParser.EntryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_entry)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 815
            self.entry_aux()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Entry_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ENTRY(self):
            return self.getToken(PtxParser.K_ENTRY, 0)

        def kernel_name(self):
            return self.getTypedRuleContext(PtxParser.Kernel_nameContext,0)


        def entry_body(self):
            return self.getTypedRuleContext(PtxParser.Entry_bodyContext,0)


        def T_OP(self):
            return self.getToken(PtxParser.T_OP, 0)

        def T_CP(self):
            return self.getToken(PtxParser.T_CP, 0)

        def performance_tuning_directives(self):
            return self.getTypedRuleContext(PtxParser.Performance_tuning_directivesContext,0)


        def K_VISIBLE(self):
            return self.getToken(PtxParser.K_VISIBLE, 0)

        def K_EXTERN(self):
            return self.getToken(PtxParser.K_EXTERN, 0)

        def entry_param_list(self):
            return self.getTypedRuleContext(PtxParser.Entry_param_listContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_entry_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntry_aux" ):
                listener.enterEntry_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntry_aux" ):
                listener.exitEntry_aux(self)




    def entry_aux(self):

        localctx = PtxParser.Entry_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_entry_aux)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 818
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_VISIBLE or _la==PtxParser.K_EXTERN:
                self.state = 817
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_VISIBLE or _la==PtxParser.K_EXTERN):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 820
            self.match(PtxParser.K_ENTRY)
            self.state = 821
            self.kernel_name()
            self.state = 827
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_OP:
                self.state = 822
                self.match(PtxParser.T_OP)
                self.state = 824
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_PARAM:
                    self.state = 823
                    self.entry_param_list()


                self.state = 826
                self.match(PtxParser.T_CP)


            self.state = 830
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 171)) & ~0x3f) == 0 and ((1 << (_la - 171)) & ((1 << (PtxParser.K_REQNTID - 171)) | (1 << (PtxParser.K_PRAGMA - 171)) | (1 << (PtxParser.K_MINNCTAPERSM - 171)) | (1 << (PtxParser.K_MAXNTID - 171)) | (1 << (PtxParser.K_MAXNREG - 171)))) != 0):
                self.state = 829
                self.performance_tuning_directives()


            self.state = 832
            self.entry_body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Kernel_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_WORD(self):
            return self.getToken(PtxParser.T_WORD, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_kernel_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKernel_name" ):
                listener.enterKernel_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKernel_name" ):
                listener.exitKernel_name(self)




    def kernel_name(self):

        localctx = PtxParser.Kernel_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_kernel_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 834
            self.match(PtxParser.T_WORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Entry_param_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entry_param(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Entry_paramContext)
            else:
                return self.getTypedRuleContext(PtxParser.Entry_paramContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_entry_param_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntry_param_list" ):
                listener.enterEntry_param_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntry_param_list" ):
                listener.exitEntry_param_list(self)




    def entry_param_list(self):

        localctx = PtxParser.Entry_param_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_entry_param_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 836
            self.entry_param()
            self.state = 841
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_COMMA:
                self.state = 837
                self.match(PtxParser.T_COMMA)
                self.state = 838
                self.entry_param()
                self.state = 843
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Entry_paramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def entry_space(self):
            return self.getTypedRuleContext(PtxParser.Entry_spaceContext,0)


        def entry_param_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Entry_param_typeContext)
            else:
                return self.getTypedRuleContext(PtxParser.Entry_param_typeContext,i)


        def T_WORD(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_WORD)
            else:
                return self.getToken(PtxParser.T_WORD, i)

        def align(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.AlignContext)
            else:
                return self.getTypedRuleContext(PtxParser.AlignContext,i)


        def array_spec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Array_specContext)
            else:
                return self.getTypedRuleContext(PtxParser.Array_specContext,i)


        def getRuleIndex(self):
            return PtxParser.RULE_entry_param

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntry_param" ):
                listener.enterEntry_param(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntry_param" ):
                listener.exitEntry_param(self)




    def entry_param(self):

        localctx = PtxParser.Entry_paramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_entry_param)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 844
            self.entry_space()
            self.state = 846
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_ALIGN:
                self.state = 845
                self.align()


            self.state = 848
            self.entry_param_type()
            self.state = 849
            self.match(PtxParser.T_WORD)
            self.state = 851
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 850
                self.array_spec()


            self.state = 854
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_WORD:
                self.state = 853
                self.match(PtxParser.T_WORD)


            self.state = 857
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_TEXREF - 140)) | (1 << (PtxParser.K_SURFREF - 140)) | (1 << (PtxParser.K_SAMPLERREF - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)) | (1 << (PtxParser.K_PRED - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_F16 - 230)) | (1 << (PtxParser.K_B8 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0):
                self.state = 856
                self.entry_param_type()


            self.state = 860
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_ALIGN:
                self.state = 859
                self.align()


            self.state = 863
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_OB:
                self.state = 862
                self.array_spec()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Entry_spaceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PARAM(self):
            return self.getToken(PtxParser.K_PARAM, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_entry_space

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntry_space" ):
                listener.enterEntry_space(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntry_space" ):
                listener.exitEntry_space(self)




    def entry_space(self):

        localctx = PtxParser.Entry_spaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_entry_space)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 865
            self.match(PtxParser.K_PARAM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AlignContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ALIGN(self):
            return self.getToken(PtxParser.K_ALIGN, 0)

        def byte_count(self):
            return self.getTypedRuleContext(PtxParser.Byte_countContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_align

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlign" ):
                listener.enterAlign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlign" ):
                listener.exitAlign(self)




    def align(self):

        localctx = PtxParser.AlignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_align)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 867
            self.match(PtxParser.K_ALIGN)
            self.state = 868
            self.byte_count()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Byte_countContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def base_10_integer(self):
            return self.getTypedRuleContext(PtxParser.Base_10_integerContext,0)


        def base_8_integer(self):
            return self.getTypedRuleContext(PtxParser.Base_8_integerContext,0)


        def base_16_integer(self):
            return self.getTypedRuleContext(PtxParser.Base_16_integerContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_byte_count

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterByte_count" ):
                listener.enterByte_count(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitByte_count" ):
                listener.exitByte_count(self)




    def byte_count(self):

        localctx = PtxParser.Byte_countContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_byte_count)
        try:
            self.state = 873
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.T_DEC_LITERAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 870
                self.base_10_integer()
                pass
            elif token in [PtxParser.T_OCT_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 871
                self.base_8_integer()
                pass
            elif token in [PtxParser.T_HEX_LITERAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 872
                self.base_16_integer()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Entry_param_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fundamental_type(self):
            return self.getTypedRuleContext(PtxParser.Fundamental_typeContext,0)


        def opaque_type(self):
            return self.getTypedRuleContext(PtxParser.Opaque_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_entry_param_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntry_param_type" ):
                listener.enterEntry_param_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntry_param_type" ):
                listener.exitEntry_param_type(self)




    def entry_param_type(self):

        localctx = PtxParser.Entry_param_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_entry_param_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 877
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_U8, PtxParser.K_U64, PtxParser.K_U32, PtxParser.K_U16, PtxParser.K_S8, PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16, PtxParser.K_PRED, PtxParser.K_F64, PtxParser.K_F32, PtxParser.K_F16, PtxParser.K_B8, PtxParser.K_B64, PtxParser.K_B32, PtxParser.K_B16]:
                self.state = 875
                self.fundamental_type()
                pass
            elif token in [PtxParser.K_TEXREF, PtxParser.K_SURFREF, PtxParser.K_SAMPLERREF]:
                self.state = 876
                self.opaque_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Entry_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OC(self):
            return self.getToken(PtxParser.T_OC, 0)

        def T_CC(self):
            return self.getToken(PtxParser.T_CC, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.StatementContext)
            else:
                return self.getTypedRuleContext(PtxParser.StatementContext,i)


        def getRuleIndex(self):
            return PtxParser.RULE_entry_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntry_body" ):
                listener.enterEntry_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntry_body" ):
                listener.exitEntry_body(self)




    def entry_body(self):

        localctx = PtxParser.Entry_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_entry_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 879
            self.match(PtxParser.T_OC)
            self.state = 883
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PtxParser.KI_ABS) | (1 << PtxParser.KI_ADD) | (1 << PtxParser.KI_ADDC) | (1 << PtxParser.KI_AND) | (1 << PtxParser.KI_ATOM) | (1 << PtxParser.KI_BAR) | (1 << PtxParser.KI_BFE) | (1 << PtxParser.KI_BFI) | (1 << PtxParser.KI_BFIND) | (1 << PtxParser.KI_BRA) | (1 << PtxParser.KI_BREV) | (1 << PtxParser.KI_BRKPT) | (1 << PtxParser.KI_CALL) | (1 << PtxParser.KI_CLZ) | (1 << PtxParser.KI_CNOT) | (1 << PtxParser.KI_COPYSIGN) | (1 << PtxParser.KI_COS) | (1 << PtxParser.KI_CVT) | (1 << PtxParser.KI_CVTA) | (1 << PtxParser.KI_DIV) | (1 << PtxParser.KI_EX2) | (1 << PtxParser.KI_EXIT) | (1 << PtxParser.KI_FMA) | (1 << PtxParser.KI_ISSPACEP) | (1 << PtxParser.KI_LD) | (1 << PtxParser.KI_LDU) | (1 << PtxParser.KI_LG2) | (1 << PtxParser.KI_MAD24) | (1 << PtxParser.KI_MAD) | (1 << PtxParser.KI_MADC) | (1 << PtxParser.KI_MAX) | (1 << PtxParser.KI_MEMBAR) | (1 << PtxParser.KI_MIN) | (1 << PtxParser.KI_MOV) | (1 << PtxParser.KI_MUL24) | (1 << PtxParser.KI_MUL) | (1 << PtxParser.KI_NEG) | (1 << PtxParser.KI_NOT) | (1 << PtxParser.KI_OR) | (1 << PtxParser.KI_PMEVENT) | (1 << PtxParser.KI_POPC) | (1 << PtxParser.KI_PREFETCH) | (1 << PtxParser.KI_PREFETCHU) | (1 << PtxParser.KI_PRMT) | (1 << PtxParser.KI_RCP) | (1 << PtxParser.KI_RED) | (1 << PtxParser.KI_REM) | (1 << PtxParser.KI_RET) | (1 << PtxParser.KI_RSQRT) | (1 << PtxParser.KI_SAD) | (1 << PtxParser.KI_SELP) | (1 << PtxParser.KI_SETP) | (1 << PtxParser.KI_SET) | (1 << PtxParser.KI_SHL) | (1 << PtxParser.KI_SHR) | (1 << PtxParser.KI_SIN) | (1 << PtxParser.KI_SLCT) | (1 << PtxParser.KI_SQRT) | (1 << PtxParser.KI_ST) | (1 << PtxParser.KI_SUB) | (1 << PtxParser.KI_SUBC) | (1 << PtxParser.KI_SULD) | (1 << PtxParser.KI_SUQ))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (PtxParser.KI_SURED - 64)) | (1 << (PtxParser.KI_SUST - 64)) | (1 << (PtxParser.KI_TESTP - 64)) | (1 << (PtxParser.KI_TEX - 64)) | (1 << (PtxParser.KI_TRAP - 64)) | (1 << (PtxParser.KI_TXQ - 64)) | (1 << (PtxParser.KI_VABSDIFF - 64)) | (1 << (PtxParser.KI_VADD - 64)) | (1 << (PtxParser.KI_VMAD - 64)) | (1 << (PtxParser.KI_VMAX - 64)) | (1 << (PtxParser.KI_VMIN - 64)) | (1 << (PtxParser.KI_VOTE - 64)) | (1 << (PtxParser.KI_VSET - 64)) | (1 << (PtxParser.KI_VSHL - 64)) | (1 << (PtxParser.KI_VSHR - 64)) | (1 << (PtxParser.KI_VSUB - 64)) | (1 << (PtxParser.KI_XOR - 64)) | (1 << (PtxParser.T_OC - 64)))) != 0) or ((((_la - 134)) & ~0x3f) == 0 and ((1 << (_la - 134)) & ((1 << (PtxParser.K_VISIBLE - 134)) | (1 << (PtxParser.K_TEX - 134)) | (1 << (PtxParser.K_SREG - 134)) | (1 << (PtxParser.K_SHARED - 134)) | (1 << (PtxParser.K_SECTION - 134)) | (1 << (PtxParser.K_REG - 134)) | (1 << (PtxParser.K_PRAGMA - 134)) | (1 << (PtxParser.K_PARAM - 134)))) != 0) or ((((_la - 205)) & ~0x3f) == 0 and ((1 << (_la - 205)) & ((1 << (PtxParser.K_LOCAL - 205)) | (1 << (PtxParser.K_LOC - 205)) | (1 << (PtxParser.K_GLOBAL - 205)) | (1 << (PtxParser.K_FUNC - 205)) | (1 << (PtxParser.K_WEAK - 205)) | (1 << (PtxParser.K_FILE - 205)) | (1 << (PtxParser.K_EXTERN - 205)) | (1 << (PtxParser.K_ENTRY - 205)) | (1 << (PtxParser.K_DWARF - 205)) | (1 << (PtxParser.K_CONST - 205)))) != 0) or ((((_la - 270)) & ~0x3f) == 0 and ((1 << (_la - 270)) & ((1 << (PtxParser.K_ALIGN - 270)) | (1 << (PtxParser.T_WORD - 270)) | (1 << (PtxParser.T_AT - 270)))) != 0):
                self.state = 880
                self.statement()
                self.state = 885
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 886
            self.match(PtxParser.T_CC)
            self.state = 890
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,24,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 887
                    self.statement() 
                self.state = 892
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,24,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fundamental_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fundamental_type_aux(self):
            return self.getTypedRuleContext(PtxParser.Fundamental_type_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_fundamental_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFundamental_type" ):
                listener.enterFundamental_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFundamental_type" ):
                listener.exitFundamental_type(self)




    def fundamental_type(self):

        localctx = PtxParser.Fundamental_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_fundamental_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 893
            self.fundamental_type_aux()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Fundamental_type_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_S8(self):
            return self.getToken(PtxParser.K_S8, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_U8(self):
            return self.getToken(PtxParser.K_U8, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_F16(self):
            return self.getToken(PtxParser.K_F16, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_B8(self):
            return self.getToken(PtxParser.K_B8, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_PRED(self):
            return self.getToken(PtxParser.K_PRED, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_fundamental_type_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFundamental_type_aux" ):
                listener.enterFundamental_type_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFundamental_type_aux" ):
                listener.exitFundamental_type_aux(self)




    def fundamental_type_aux(self):

        localctx = PtxParser.Fundamental_type_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_fundamental_type_aux)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 895
            _la = self._input.LA(1)
            if not(((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)) | (1 << (PtxParser.K_PRED - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_F16 - 230)) | (1 << (PtxParser.K_B8 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Vector_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vector_type_aux(self):
            return self.getTypedRuleContext(PtxParser.Vector_type_auxContext,0)


        def fundamental_type(self):
            return self.getTypedRuleContext(PtxParser.Fundamental_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_vector_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVector_type" ):
                listener.enterVector_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVector_type" ):
                listener.exitVector_type(self)




    def vector_type(self):

        localctx = PtxParser.Vector_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_vector_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 897
            self.vector_type_aux()
            self.state = 898
            self.fundamental_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Vector_type_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_V4(self):
            return self.getToken(PtxParser.K_V4, 0)

        def K_V2(self):
            return self.getToken(PtxParser.K_V2, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_vector_type_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVector_type_aux" ):
                listener.enterVector_type_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVector_type_aux" ):
                listener.exitVector_type_aux(self)




    def vector_type_aux(self):

        localctx = PtxParser.Vector_type_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_vector_type_aux)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 900
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_V4 or _la==PtxParser.K_V2):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opaque_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opaque_type_aux(self):
            return self.getTypedRuleContext(PtxParser.Opaque_type_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_opaque_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpaque_type" ):
                listener.enterOpaque_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpaque_type" ):
                listener.exitOpaque_type(self)




    def opaque_type(self):

        localctx = PtxParser.Opaque_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_opaque_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 902
            self.opaque_type_aux()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opaque_type_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_TEXREF(self):
            return self.getToken(PtxParser.K_TEXREF, 0)

        def K_SAMPLERREF(self):
            return self.getToken(PtxParser.K_SAMPLERREF, 0)

        def K_SURFREF(self):
            return self.getToken(PtxParser.K_SURFREF, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_opaque_type_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpaque_type_aux" ):
                listener.enterOpaque_type_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpaque_type_aux" ):
                listener.exitOpaque_type_aux(self)




    def opaque_type_aux(self):

        localctx = PtxParser.Opaque_type_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_opaque_type_aux)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 904
            _la = self._input.LA(1)
            if not(((((_la - 146)) & ~0x3f) == 0 and ((1 << (_la - 146)) & ((1 << (PtxParser.K_TEXREF - 146)) | (1 << (PtxParser.K_SURFREF - 146)) | (1 << (PtxParser.K_SAMPLERREF - 146)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FuncContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def func_aux(self):
            return self.getTypedRuleContext(PtxParser.Func_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_func

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc" ):
                listener.enterFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc" ):
                listener.exitFunc(self)




    def func(self):

        localctx = PtxParser.FuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_func)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 906
            self.func_aux()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_FUNC(self):
            return self.getToken(PtxParser.K_FUNC, 0)

        def func_name(self):
            return self.getTypedRuleContext(PtxParser.Func_nameContext,0)


        def T_OP(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_OP)
            else:
                return self.getToken(PtxParser.T_OP, i)

        def T_CP(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_CP)
            else:
                return self.getToken(PtxParser.T_CP, i)

        def func_body(self):
            return self.getTypedRuleContext(PtxParser.Func_bodyContext,0)


        def K_VISIBLE(self):
            return self.getToken(PtxParser.K_VISIBLE, 0)

        def K_EXTERN(self):
            return self.getToken(PtxParser.K_EXTERN, 0)

        def K_WEAK(self):
            return self.getToken(PtxParser.K_WEAK, 0)

        def func_ret_list(self):
            return self.getTypedRuleContext(PtxParser.Func_ret_listContext,0)


        def func_param_list(self):
            return self.getTypedRuleContext(PtxParser.Func_param_listContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_func_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_aux" ):
                listener.enterFunc_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_aux" ):
                listener.exitFunc_aux(self)




    def func_aux(self):

        localctx = PtxParser.Func_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_func_aux)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 909
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_VISIBLE or _la==PtxParser.K_WEAK or _la==PtxParser.K_EXTERN:
                self.state = 908
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_VISIBLE or _la==PtxParser.K_WEAK or _la==PtxParser.K_EXTERN):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 911
            self.match(PtxParser.K_FUNC)
            self.state = 917
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_OP:
                self.state = 912
                self.match(PtxParser.T_OP)
                self.state = 914
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_REG or _la==PtxParser.K_PARAM:
                    self.state = 913
                    self.func_ret_list()


                self.state = 916
                self.match(PtxParser.T_CP)


            self.state = 919
            self.func_name()
            self.state = 925
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_OP:
                self.state = 920
                self.match(PtxParser.T_OP)
                self.state = 922
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_REG or _la==PtxParser.K_PARAM:
                    self.state = 921
                    self.func_param_list()


                self.state = 924
                self.match(PtxParser.T_CP)


            self.state = 928
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.state = 927
                self.func_body()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_WORD(self):
            return self.getToken(PtxParser.T_WORD, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_func_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_name" ):
                listener.enterFunc_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_name" ):
                listener.exitFunc_name(self)




    def func_name(self):

        localctx = PtxParser.Func_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_func_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 930
            self.match(PtxParser.T_WORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_ret_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def func_ret(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Func_retContext)
            else:
                return self.getTypedRuleContext(PtxParser.Func_retContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_func_ret_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_ret_list" ):
                listener.enterFunc_ret_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_ret_list" ):
                listener.exitFunc_ret_list(self)




    def func_ret_list(self):

        localctx = PtxParser.Func_ret_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_func_ret_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 932
            self.func_ret()
            self.state = 937
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_COMMA:
                self.state = 933
                self.match(PtxParser.T_COMMA)
                self.state = 934
                self.func_ret()
                self.state = 939
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_retContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def func_ret_space(self):
            return self.getTypedRuleContext(PtxParser.Func_ret_spaceContext,0)


        def func_ret_type(self):
            return self.getTypedRuleContext(PtxParser.Func_ret_typeContext,0)


        def T_WORD(self):
            return self.getToken(PtxParser.T_WORD, 0)

        def align(self):
            return self.getTypedRuleContext(PtxParser.AlignContext,0)


        def array_spec(self):
            return self.getTypedRuleContext(PtxParser.Array_specContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_func_ret

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_ret" ):
                listener.enterFunc_ret(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_ret" ):
                listener.exitFunc_ret(self)




    def func_ret(self):

        localctx = PtxParser.Func_retContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_func_ret)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 940
            self.func_ret_space()
            self.state = 942
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_ALIGN:
                self.state = 941
                self.align()


            self.state = 944
            self.func_ret_type()
            self.state = 945
            self.match(PtxParser.T_WORD)
            self.state = 947
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_OB:
                self.state = 946
                self.array_spec()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_ret_spaceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PARAM(self):
            return self.getToken(PtxParser.K_PARAM, 0)

        def K_REG(self):
            return self.getToken(PtxParser.K_REG, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_func_ret_space

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_ret_space" ):
                listener.enterFunc_ret_space(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_ret_space" ):
                listener.exitFunc_ret_space(self)




    def func_ret_space(self):

        localctx = PtxParser.Func_ret_spaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_func_ret_space)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 949
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_REG or _la==PtxParser.K_PARAM):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_ret_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fundamental_type(self):
            return self.getTypedRuleContext(PtxParser.Fundamental_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_func_ret_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_ret_type" ):
                listener.enterFunc_ret_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_ret_type" ):
                listener.exitFunc_ret_type(self)




    def func_ret_type(self):

        localctx = PtxParser.Func_ret_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_func_ret_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 951
            self.fundamental_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_param_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def func_param(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Func_paramContext)
            else:
                return self.getTypedRuleContext(PtxParser.Func_paramContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def T_ELLIPSIS(self):
            return self.getToken(PtxParser.T_ELLIPSIS, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_func_param_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_param_list" ):
                listener.enterFunc_param_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_param_list" ):
                listener.exitFunc_param_list(self)




    def func_param_list(self):

        localctx = PtxParser.Func_param_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_func_param_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 953
            self.func_param()
            self.state = 958
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_COMMA:
                self.state = 954
                self.match(PtxParser.T_COMMA)
                self.state = 955
                self.func_param()
                self.state = 960
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 962
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_ELLIPSIS:
                self.state = 961
                self.match(PtxParser.T_ELLIPSIS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_paramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def func_param_space(self):
            return self.getTypedRuleContext(PtxParser.Func_param_spaceContext,0)


        def func_param_type(self):
            return self.getTypedRuleContext(PtxParser.Func_param_typeContext,0)


        def T_WORD(self):
            return self.getToken(PtxParser.T_WORD, 0)

        def align(self):
            return self.getTypedRuleContext(PtxParser.AlignContext,0)


        def array_spec(self):
            return self.getTypedRuleContext(PtxParser.Array_specContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_func_param

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_param" ):
                listener.enterFunc_param(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_param" ):
                listener.exitFunc_param(self)




    def func_param(self):

        localctx = PtxParser.Func_paramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_func_param)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 964
            self.func_param_space()
            self.state = 966
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_ALIGN:
                self.state = 965
                self.align()


            self.state = 968
            self.func_param_type()
            self.state = 969
            self.match(PtxParser.T_WORD)
            self.state = 971
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_OB:
                self.state = 970
                self.array_spec()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_param_spaceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PARAM(self):
            return self.getToken(PtxParser.K_PARAM, 0)

        def K_REG(self):
            return self.getToken(PtxParser.K_REG, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_func_param_space

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_param_space" ):
                listener.enterFunc_param_space(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_param_space" ):
                listener.exitFunc_param_space(self)




    def func_param_space(self):

        localctx = PtxParser.Func_param_spaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_func_param_space)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 973
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_REG or _la==PtxParser.K_PARAM):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_param_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fundamental_type(self):
            return self.getTypedRuleContext(PtxParser.Fundamental_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_func_param_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_param_type" ):
                listener.enterFunc_param_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_param_type" ):
                listener.exitFunc_param_type(self)




    def func_param_type(self):

        localctx = PtxParser.Func_param_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_func_param_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 975
            self.fundamental_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Func_bodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OC(self):
            return self.getToken(PtxParser.T_OC, 0)

        def T_CC(self):
            return self.getToken(PtxParser.T_CC, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.StatementContext)
            else:
                return self.getTypedRuleContext(PtxParser.StatementContext,i)


        def getRuleIndex(self):
            return PtxParser.RULE_func_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunc_body" ):
                listener.enterFunc_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunc_body" ):
                listener.exitFunc_body(self)




    def func_body(self):

        localctx = PtxParser.Func_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_func_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 977
            self.match(PtxParser.T_OC)
            self.state = 981
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PtxParser.KI_ABS) | (1 << PtxParser.KI_ADD) | (1 << PtxParser.KI_ADDC) | (1 << PtxParser.KI_AND) | (1 << PtxParser.KI_ATOM) | (1 << PtxParser.KI_BAR) | (1 << PtxParser.KI_BFE) | (1 << PtxParser.KI_BFI) | (1 << PtxParser.KI_BFIND) | (1 << PtxParser.KI_BRA) | (1 << PtxParser.KI_BREV) | (1 << PtxParser.KI_BRKPT) | (1 << PtxParser.KI_CALL) | (1 << PtxParser.KI_CLZ) | (1 << PtxParser.KI_CNOT) | (1 << PtxParser.KI_COPYSIGN) | (1 << PtxParser.KI_COS) | (1 << PtxParser.KI_CVT) | (1 << PtxParser.KI_CVTA) | (1 << PtxParser.KI_DIV) | (1 << PtxParser.KI_EX2) | (1 << PtxParser.KI_EXIT) | (1 << PtxParser.KI_FMA) | (1 << PtxParser.KI_ISSPACEP) | (1 << PtxParser.KI_LD) | (1 << PtxParser.KI_LDU) | (1 << PtxParser.KI_LG2) | (1 << PtxParser.KI_MAD24) | (1 << PtxParser.KI_MAD) | (1 << PtxParser.KI_MADC) | (1 << PtxParser.KI_MAX) | (1 << PtxParser.KI_MEMBAR) | (1 << PtxParser.KI_MIN) | (1 << PtxParser.KI_MOV) | (1 << PtxParser.KI_MUL24) | (1 << PtxParser.KI_MUL) | (1 << PtxParser.KI_NEG) | (1 << PtxParser.KI_NOT) | (1 << PtxParser.KI_OR) | (1 << PtxParser.KI_PMEVENT) | (1 << PtxParser.KI_POPC) | (1 << PtxParser.KI_PREFETCH) | (1 << PtxParser.KI_PREFETCHU) | (1 << PtxParser.KI_PRMT) | (1 << PtxParser.KI_RCP) | (1 << PtxParser.KI_RED) | (1 << PtxParser.KI_REM) | (1 << PtxParser.KI_RET) | (1 << PtxParser.KI_RSQRT) | (1 << PtxParser.KI_SAD) | (1 << PtxParser.KI_SELP) | (1 << PtxParser.KI_SETP) | (1 << PtxParser.KI_SET) | (1 << PtxParser.KI_SHL) | (1 << PtxParser.KI_SHR) | (1 << PtxParser.KI_SIN) | (1 << PtxParser.KI_SLCT) | (1 << PtxParser.KI_SQRT) | (1 << PtxParser.KI_ST) | (1 << PtxParser.KI_SUB) | (1 << PtxParser.KI_SUBC) | (1 << PtxParser.KI_SULD) | (1 << PtxParser.KI_SUQ))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (PtxParser.KI_SURED - 64)) | (1 << (PtxParser.KI_SUST - 64)) | (1 << (PtxParser.KI_TESTP - 64)) | (1 << (PtxParser.KI_TEX - 64)) | (1 << (PtxParser.KI_TRAP - 64)) | (1 << (PtxParser.KI_TXQ - 64)) | (1 << (PtxParser.KI_VABSDIFF - 64)) | (1 << (PtxParser.KI_VADD - 64)) | (1 << (PtxParser.KI_VMAD - 64)) | (1 << (PtxParser.KI_VMAX - 64)) | (1 << (PtxParser.KI_VMIN - 64)) | (1 << (PtxParser.KI_VOTE - 64)) | (1 << (PtxParser.KI_VSET - 64)) | (1 << (PtxParser.KI_VSHL - 64)) | (1 << (PtxParser.KI_VSHR - 64)) | (1 << (PtxParser.KI_VSUB - 64)) | (1 << (PtxParser.KI_XOR - 64)) | (1 << (PtxParser.T_OC - 64)))) != 0) or ((((_la - 134)) & ~0x3f) == 0 and ((1 << (_la - 134)) & ((1 << (PtxParser.K_VISIBLE - 134)) | (1 << (PtxParser.K_TEX - 134)) | (1 << (PtxParser.K_SREG - 134)) | (1 << (PtxParser.K_SHARED - 134)) | (1 << (PtxParser.K_SECTION - 134)) | (1 << (PtxParser.K_REG - 134)) | (1 << (PtxParser.K_PRAGMA - 134)) | (1 << (PtxParser.K_PARAM - 134)))) != 0) or ((((_la - 205)) & ~0x3f) == 0 and ((1 << (_la - 205)) & ((1 << (PtxParser.K_LOCAL - 205)) | (1 << (PtxParser.K_LOC - 205)) | (1 << (PtxParser.K_GLOBAL - 205)) | (1 << (PtxParser.K_FUNC - 205)) | (1 << (PtxParser.K_WEAK - 205)) | (1 << (PtxParser.K_FILE - 205)) | (1 << (PtxParser.K_EXTERN - 205)) | (1 << (PtxParser.K_ENTRY - 205)) | (1 << (PtxParser.K_DWARF - 205)) | (1 << (PtxParser.K_CONST - 205)))) != 0) or ((((_la - 270)) & ~0x3f) == 0 and ((1 << (_la - 270)) & ((1 << (PtxParser.K_ALIGN - 270)) | (1 << (PtxParser.T_WORD - 270)) | (1 << (PtxParser.T_AT - 270)))) != 0):
                self.state = 978
                self.statement()
                self.state = 983
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 984
            self.match(PtxParser.T_CC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Control_flow_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def branch_targets(self):
            return self.getTypedRuleContext(PtxParser.Branch_targetsContext,0)


        def call_prototype(self):
            return self.getTypedRuleContext(PtxParser.Call_prototypeContext,0)


        def call_targets(self):
            return self.getTypedRuleContext(PtxParser.Call_targetsContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_control_flow_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterControl_flow_directive" ):
                listener.enterControl_flow_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitControl_flow_directive" ):
                listener.exitControl_flow_directive(self)




    def control_flow_directive(self):

        localctx = PtxParser.Control_flow_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_control_flow_directive)
        try:
            self.state = 989
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 986
                self.branch_targets()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 987
                self.call_prototype()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 988
                self.call_targets()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Branch_targetsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label_decl(self):
            return self.getTypedRuleContext(PtxParser.Label_declContext,0)


        def K_BRANCHTARGETS(self):
            return self.getToken(PtxParser.K_BRANCHTARGETS, 0)

        def list_of_labels(self):
            return self.getTypedRuleContext(PtxParser.List_of_labelsContext,0)


        def T_SEMICOLON(self):
            return self.getToken(PtxParser.T_SEMICOLON, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_branch_targets

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBranch_targets" ):
                listener.enterBranch_targets(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBranch_targets" ):
                listener.exitBranch_targets(self)




    def branch_targets(self):

        localctx = PtxParser.Branch_targetsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_branch_targets)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 991
            self.label_decl()
            self.state = 992
            self.match(PtxParser.K_BRANCHTARGETS)
            self.state = 993
            self.list_of_labels()
            self.state = 994
            self.match(PtxParser.T_SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class List_of_labelsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_list_of_labels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterList_of_labels" ):
                listener.enterList_of_labels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitList_of_labels" ):
                listener.exitList_of_labels(self)




    def list_of_labels(self):

        localctx = PtxParser.List_of_labelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_list_of_labels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 996
            self.opr()
            self.state = 1001
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_COMMA:
                self.state = 997
                self.match(PtxParser.T_COMMA)
                self.state = 998
                self.opr()
                self.state = 1003
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Call_targetsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label_decl(self):
            return self.getTypedRuleContext(PtxParser.Label_declContext,0)


        def K_CALLTARGETS(self):
            return self.getToken(PtxParser.K_CALLTARGETS, 0)

        def list_of_labels(self):
            return self.getTypedRuleContext(PtxParser.List_of_labelsContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_call_targets

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall_targets" ):
                listener.enterCall_targets(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall_targets" ):
                listener.exitCall_targets(self)




    def call_targets(self):

        localctx = PtxParser.Call_targetsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_call_targets)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1004
            self.label_decl()
            self.state = 1005
            self.match(PtxParser.K_CALLTARGETS)
            self.state = 1006
            self.list_of_labels()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Call_prototypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def label_decl(self):
            return self.getTypedRuleContext(PtxParser.Label_declContext,0)


        def K_CALLPROTOTYPE(self):
            return self.getToken(PtxParser.K_CALLPROTOTYPE, 0)

        def T_UNDERSCORE(self):
            return self.getToken(PtxParser.T_UNDERSCORE, 0)

        def T_OP(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_OP)
            else:
                return self.getToken(PtxParser.T_OP, i)

        def T_CP(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_CP)
            else:
                return self.getToken(PtxParser.T_CP, i)

        def call_param_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Call_param_listContext)
            else:
                return self.getTypedRuleContext(PtxParser.Call_param_listContext,i)


        def getRuleIndex(self):
            return PtxParser.RULE_call_prototype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall_prototype" ):
                listener.enterCall_prototype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall_prototype" ):
                listener.exitCall_prototype(self)




    def call_prototype(self):

        localctx = PtxParser.Call_prototypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_call_prototype)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1008
            self.label_decl()
            self.state = 1009
            self.match(PtxParser.K_CALLPROTOTYPE)
            self.state = 1015
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_OP:
                self.state = 1010
                self.match(PtxParser.T_OP)
                self.state = 1012
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_REG or _la==PtxParser.K_PARAM:
                    self.state = 1011
                    self.call_param_list()


                self.state = 1014
                self.match(PtxParser.T_CP)


            self.state = 1017
            self.match(PtxParser.T_UNDERSCORE)
            self.state = 1023
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_OP:
                self.state = 1018
                self.match(PtxParser.T_OP)
                self.state = 1020
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_REG or _la==PtxParser.K_PARAM:
                    self.state = 1019
                    self.call_param_list()


                self.state = 1022
                self.match(PtxParser.T_CP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Call_param_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def call_param(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Call_paramContext)
            else:
                return self.getTypedRuleContext(PtxParser.Call_paramContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_call_param_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall_param_list" ):
                listener.enterCall_param_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall_param_list" ):
                listener.exitCall_param_list(self)




    def call_param_list(self):

        localctx = PtxParser.Call_param_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_call_param_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1025
            self.call_param()
            self.state = 1030
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_COMMA:
                self.state = 1026
                self.match(PtxParser.T_COMMA)
                self.state = 1027
                self.call_param()
                self.state = 1032
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Call_paramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def call_param_space(self):
            return self.getTypedRuleContext(PtxParser.Call_param_spaceContext,0)


        def call_param_type(self):
            return self.getTypedRuleContext(PtxParser.Call_param_typeContext,0)


        def T_UNDERSCORE(self):
            return self.getToken(PtxParser.T_UNDERSCORE, 0)

        def align(self):
            return self.getTypedRuleContext(PtxParser.AlignContext,0)


        def array_spec(self):
            return self.getTypedRuleContext(PtxParser.Array_specContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_call_param

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall_param" ):
                listener.enterCall_param(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall_param" ):
                listener.exitCall_param(self)




    def call_param(self):

        localctx = PtxParser.Call_paramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_call_param)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1033
            self.call_param_space()
            self.state = 1035
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_ALIGN:
                self.state = 1034
                self.align()


            self.state = 1037
            self.call_param_type()
            self.state = 1038
            self.match(PtxParser.T_UNDERSCORE)
            self.state = 1040
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_OB:
                self.state = 1039
                self.array_spec()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Call_param_spaceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PARAM(self):
            return self.getToken(PtxParser.K_PARAM, 0)

        def K_REG(self):
            return self.getToken(PtxParser.K_REG, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_call_param_space

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall_param_space" ):
                listener.enterCall_param_space(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall_param_space" ):
                listener.exitCall_param_space(self)




    def call_param_space(self):

        localctx = PtxParser.Call_param_spaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_call_param_space)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1042
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_REG or _la==PtxParser.K_PARAM):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Call_param_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fundamental_type(self):
            return self.getTypedRuleContext(PtxParser.Fundamental_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_call_param_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall_param_type" ):
                listener.enterCall_param_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall_param_type" ):
                listener.exitCall_param_type(self)




    def call_param_type(self):

        localctx = PtxParser.Call_param_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_call_param_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1044
            self.fundamental_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Performance_tuning_directivesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def performance_tuning_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Performance_tuning_directiveContext)
            else:
                return self.getTypedRuleContext(PtxParser.Performance_tuning_directiveContext,i)


        def getRuleIndex(self):
            return PtxParser.RULE_performance_tuning_directives

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPerformance_tuning_directives" ):
                listener.enterPerformance_tuning_directives(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPerformance_tuning_directives" ):
                listener.exitPerformance_tuning_directives(self)




    def performance_tuning_directives(self):

        localctx = PtxParser.Performance_tuning_directivesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_performance_tuning_directives)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1047 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1046
                self.performance_tuning_directive()
                self.state = 1049 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 171)) & ~0x3f) == 0 and ((1 << (_la - 171)) & ((1 << (PtxParser.K_REQNTID - 171)) | (1 << (PtxParser.K_PRAGMA - 171)) | (1 << (PtxParser.K_MINNCTAPERSM - 171)) | (1 << (PtxParser.K_MAXNTID - 171)) | (1 << (PtxParser.K_MAXNREG - 171)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Performance_tuning_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def maxnreg(self):
            return self.getTypedRuleContext(PtxParser.MaxnregContext,0)


        def maxntid(self):
            return self.getTypedRuleContext(PtxParser.MaxntidContext,0)


        def reqntid(self):
            return self.getTypedRuleContext(PtxParser.ReqntidContext,0)


        def minnctapersm(self):
            return self.getTypedRuleContext(PtxParser.MinnctapersmContext,0)


        def maxnctapersm(self):
            return self.getTypedRuleContext(PtxParser.MaxnctapersmContext,0)


        def pragma(self):
            return self.getTypedRuleContext(PtxParser.PragmaContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_performance_tuning_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPerformance_tuning_directive" ):
                listener.enterPerformance_tuning_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPerformance_tuning_directive" ):
                listener.exitPerformance_tuning_directive(self)




    def performance_tuning_directive(self):

        localctx = PtxParser.Performance_tuning_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_performance_tuning_directive)
        try:
            self.state = 1057
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1051
                self.maxnreg()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1052
                self.maxntid()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1053
                self.reqntid()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1054
                self.minnctapersm()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1055
                self.maxnctapersm()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1056
                self.pragma()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MaxnregContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_MAXNREG(self):
            return self.getToken(PtxParser.K_MAXNREG, 0)

        def integer(self):
            return self.getTypedRuleContext(PtxParser.IntegerContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_maxnreg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxnreg" ):
                listener.enterMaxnreg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxnreg" ):
                listener.exitMaxnreg(self)




    def maxnreg(self):

        localctx = PtxParser.MaxnregContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_maxnreg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1059
            self.match(PtxParser.K_MAXNREG)
            self.state = 1060
            self.integer()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MaxntidContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_MAXNTID(self):
            return self.getToken(PtxParser.K_MAXNTID, 0)

        def integer(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.IntegerContext)
            else:
                return self.getTypedRuleContext(PtxParser.IntegerContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_maxntid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxntid" ):
                listener.enterMaxntid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxntid" ):
                listener.exitMaxntid(self)




    def maxntid(self):

        localctx = PtxParser.MaxntidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_maxntid)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1062
            self.match(PtxParser.K_MAXNTID)
            self.state = 1063
            self.integer()
            self.state = 1070
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_COMMA:
                self.state = 1064
                self.match(PtxParser.T_COMMA)
                self.state = 1065
                self.integer()
                self.state = 1068
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.T_COMMA:
                    self.state = 1066
                    self.match(PtxParser.T_COMMA)
                    self.state = 1067
                    self.integer()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReqntidContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_REQNTID(self):
            return self.getToken(PtxParser.K_REQNTID, 0)

        def integer(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.IntegerContext)
            else:
                return self.getTypedRuleContext(PtxParser.IntegerContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_reqntid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReqntid" ):
                listener.enterReqntid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReqntid" ):
                listener.exitReqntid(self)




    def reqntid(self):

        localctx = PtxParser.ReqntidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_reqntid)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1072
            self.match(PtxParser.K_REQNTID)
            self.state = 1073
            self.integer()
            self.state = 1080
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_COMMA:
                self.state = 1074
                self.match(PtxParser.T_COMMA)
                self.state = 1075
                self.integer()
                self.state = 1078
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.T_COMMA:
                    self.state = 1076
                    self.match(PtxParser.T_COMMA)
                    self.state = 1077
                    self.integer()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MinnctapersmContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_MINNCTAPERSM(self):
            return self.getToken(PtxParser.K_MINNCTAPERSM, 0)

        def integer(self):
            return self.getTypedRuleContext(PtxParser.IntegerContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_minnctapersm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinnctapersm" ):
                listener.enterMinnctapersm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinnctapersm" ):
                listener.exitMinnctapersm(self)




    def minnctapersm(self):

        localctx = PtxParser.MinnctapersmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_minnctapersm)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1082
            self.match(PtxParser.K_MINNCTAPERSM)
            self.state = 1083
            self.integer()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MaxnctapersmContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_MINNCTAPERSM(self):
            return self.getToken(PtxParser.K_MINNCTAPERSM, 0)

        def integer(self):
            return self.getTypedRuleContext(PtxParser.IntegerContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_maxnctapersm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaxnctapersm" ):
                listener.enterMaxnctapersm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaxnctapersm" ):
                listener.exitMaxnctapersm(self)




    def maxnctapersm(self):

        localctx = PtxParser.MaxnctapersmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_maxnctapersm)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1085
            self.match(PtxParser.K_MINNCTAPERSM)
            self.state = 1086
            self.integer()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PragmaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PRAGMA(self):
            return self.getToken(PtxParser.K_PRAGMA, 0)

        def list_of_strings(self):
            return self.getTypedRuleContext(PtxParser.List_of_stringsContext,0)


        def T_SEMICOLON(self):
            return self.getToken(PtxParser.T_SEMICOLON, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_pragma

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPragma" ):
                listener.enterPragma(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPragma" ):
                listener.exitPragma(self)




    def pragma(self):

        localctx = PtxParser.PragmaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_pragma)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1088
            self.match(PtxParser.K_PRAGMA)
            self.state = 1089
            self.list_of_strings()
            self.state = 1090
            self.match(PtxParser.T_SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class List_of_stringsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_NOUNROLL(self):
            return self.getToken(PtxParser.K_NOUNROLL, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_list_of_strings

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterList_of_strings" ):
                listener.enterList_of_strings(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitList_of_strings" ):
                listener.exitList_of_strings(self)




    def list_of_strings(self):

        localctx = PtxParser.List_of_stringsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_list_of_strings)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1092
            self.match(PtxParser.K_NOUNROLL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Debugging_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dwarf(self):
            return self.getTypedRuleContext(PtxParser.DwarfContext,0)


        def filef(self):
            return self.getTypedRuleContext(PtxParser.FilefContext,0)


        def section(self):
            return self.getTypedRuleContext(PtxParser.SectionContext,0)


        def loc(self):
            return self.getTypedRuleContext(PtxParser.LocContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_debugging_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDebugging_directive" ):
                listener.enterDebugging_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDebugging_directive" ):
                listener.exitDebugging_directive(self)




    def debugging_directive(self):

        localctx = PtxParser.Debugging_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_debugging_directive)
        try:
            self.state = 1098
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_DWARF]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1094
                self.dwarf()
                pass
            elif token in [PtxParser.K_FILE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1095
                self.filef()
                pass
            elif token in [PtxParser.K_SECTION]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1096
                self.section()
                pass
            elif token in [PtxParser.K_LOC]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1097
                self.loc()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DwarfContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_DWARF(self):
            return self.getToken(PtxParser.K_DWARF, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_dwarf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDwarf" ):
                listener.enterDwarf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDwarf" ):
                listener.exitDwarf(self)




    def dwarf(self):

        localctx = PtxParser.DwarfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_dwarf)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1100
            self.match(PtxParser.K_DWARF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FilefContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_FILE(self):
            return self.getToken(PtxParser.K_FILE, 0)

        def integer(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.IntegerContext)
            else:
                return self.getTypedRuleContext(PtxParser.IntegerContext,i)


        def T_STRING(self):
            return self.getToken(PtxParser.T_STRING, 0)

        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_filef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilef" ):
                listener.enterFilef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilef" ):
                listener.exitFilef(self)




    def filef(self):

        localctx = PtxParser.FilefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_filef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1102
            self.match(PtxParser.K_FILE)
            self.state = 1103
            self.integer()
            self.state = 1104
            self.match(PtxParser.T_STRING)
            self.state = 1110
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_COMMA:
                self.state = 1106
                self.match(PtxParser.T_COMMA)
                self.state = 1107
                self.integer()
                self.state = 1112
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SectionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def section_name(self):
            return self.getTypedRuleContext(PtxParser.Section_nameContext,0)


        def T_OC(self):
            return self.getToken(PtxParser.T_OC, 0)

        def T_CC(self):
            return self.getToken(PtxParser.T_CC, 0)

        def K_SECTION(self):
            return self.getToken(PtxParser.K_SECTION, 0)

        def data_declarator_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Data_declarator_listContext)
            else:
                return self.getTypedRuleContext(PtxParser.Data_declarator_listContext,i)


        def getRuleIndex(self):
            return PtxParser.RULE_section

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSection" ):
                listener.enterSection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSection" ):
                listener.exitSection(self)




    def section(self):

        localctx = PtxParser.SectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_section)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1113
            self.match(PtxParser.K_SECTION)
            self.state = 1114
            self.section_name()
            self.state = 1115
            self.match(PtxParser.T_OC)
            self.state = 1119
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 137)) & ~0x3f) == 0 and ((1 << (_la - 137)) & ((1 << (PtxParser.K_V4 - 137)) | (1 << (PtxParser.K_V2 - 137)) | (1 << (PtxParser.K_U8 - 137)) | (1 << (PtxParser.K_U64 - 137)) | (1 << (PtxParser.K_U32 - 137)) | (1 << (PtxParser.K_U16 - 137)) | (1 << (PtxParser.K_TEXREF - 137)) | (1 << (PtxParser.K_SURFREF - 137)) | (1 << (PtxParser.K_SAMPLERREF - 137)) | (1 << (PtxParser.K_S8 - 137)) | (1 << (PtxParser.K_S64 - 137)) | (1 << (PtxParser.K_S32 - 137)) | (1 << (PtxParser.K_S16 - 137)) | (1 << (PtxParser.K_PRED - 137)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_F16 - 230)) | (1 << (PtxParser.K_B8 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0):
                self.state = 1116
                self.data_declarator_list()
                self.state = 1121
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1122
            self.match(PtxParser.T_CC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Section_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_WORD(self):
            return self.getToken(PtxParser.T_WORD, 0)

        def U_DEBUG_ABBREV(self):
            return self.getToken(PtxParser.U_DEBUG_ABBREV, 0)

        def U_DEBUG_INFO(self):
            return self.getToken(PtxParser.U_DEBUG_INFO, 0)

        def U_DEBUG_LINE(self):
            return self.getToken(PtxParser.U_DEBUG_LINE, 0)

        def U_DEBUG_LOC(self):
            return self.getToken(PtxParser.U_DEBUG_LOC, 0)

        def T_PLUS(self):
            return self.getToken(PtxParser.T_PLUS, 0)

        def integer(self):
            return self.getTypedRuleContext(PtxParser.IntegerContext,0)


        def U_DEBUG_PUBNAMES(self):
            return self.getToken(PtxParser.U_DEBUG_PUBNAMES, 0)

        def U_DEBUG_RANGES(self):
            return self.getToken(PtxParser.U_DEBUG_RANGES, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_section_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSection_name" ):
                listener.enterSection_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSection_name" ):
                listener.exitSection_name(self)




    def section_name(self):

        localctx = PtxParser.Section_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_section_name)
        self._la = 0 # Token type
        try:
            self.state = 1135
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.T_WORD]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1124
                self.match(PtxParser.T_WORD)
                pass
            elif token in [PtxParser.U_DEBUG_ABBREV]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1125
                self.match(PtxParser.U_DEBUG_ABBREV)
                pass
            elif token in [PtxParser.U_DEBUG_INFO]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1126
                self.match(PtxParser.U_DEBUG_INFO)
                pass
            elif token in [PtxParser.U_DEBUG_LINE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1127
                self.match(PtxParser.U_DEBUG_LINE)
                pass
            elif token in [PtxParser.U_DEBUG_LOC]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1128
                self.match(PtxParser.U_DEBUG_LOC)
                self.state = 1131
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.T_PLUS:
                    self.state = 1129
                    self.match(PtxParser.T_PLUS)
                    self.state = 1130
                    self.integer()


                pass
            elif token in [PtxParser.U_DEBUG_PUBNAMES]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1133
                self.match(PtxParser.U_DEBUG_PUBNAMES)
                pass
            elif token in [PtxParser.U_DEBUG_RANGES]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1134
                self.match(PtxParser.U_DEBUG_RANGES)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Data_declarator_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typet(self):
            return self.getTypedRuleContext(PtxParser.TypetContext,0)


        def integer(self):
            return self.getTypedRuleContext(PtxParser.IntegerContext,0)


        def T_WORD(self):
            return self.getToken(PtxParser.T_WORD, 0)

        def U_DEBUG_ABBREV(self):
            return self.getToken(PtxParser.U_DEBUG_ABBREV, 0)

        def U_DEBUG_INFO(self):
            return self.getToken(PtxParser.U_DEBUG_INFO, 0)

        def U_DEBUG_LINE(self):
            return self.getToken(PtxParser.U_DEBUG_LINE, 0)

        def U_DEBUG_PUBNAMES(self):
            return self.getToken(PtxParser.U_DEBUG_PUBNAMES, 0)

        def U_DEBUG_RANGES(self):
            return self.getToken(PtxParser.U_DEBUG_RANGES, 0)

        def U_DEBUG_LOC(self):
            return self.getToken(PtxParser.U_DEBUG_LOC, 0)

        def T_PLUS(self):
            return self.getToken(PtxParser.T_PLUS, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_data_declarator_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_declarator_list" ):
                listener.enterData_declarator_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_declarator_list" ):
                listener.exitData_declarator_list(self)




    def data_declarator_list(self):

        localctx = PtxParser.Data_declarator_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_data_declarator_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1137
            self.typet()
            self.state = 1150
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.T_HEX_LITERAL, PtxParser.T_OCT_LITERAL, PtxParser.T_DEC_LITERAL]:
                self.state = 1138
                self.integer()
                pass
            elif token in [PtxParser.T_WORD]:
                self.state = 1139
                self.match(PtxParser.T_WORD)
                pass
            elif token in [PtxParser.U_DEBUG_ABBREV]:
                self.state = 1140
                self.match(PtxParser.U_DEBUG_ABBREV)
                pass
            elif token in [PtxParser.U_DEBUG_INFO]:
                self.state = 1141
                self.match(PtxParser.U_DEBUG_INFO)
                pass
            elif token in [PtxParser.U_DEBUG_LINE]:
                self.state = 1142
                self.match(PtxParser.U_DEBUG_LINE)
                pass
            elif token in [PtxParser.U_DEBUG_LOC]:
                self.state = 1143
                self.match(PtxParser.U_DEBUG_LOC)
                self.state = 1146
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.T_PLUS:
                    self.state = 1144
                    self.match(PtxParser.T_PLUS)
                    self.state = 1145
                    self.integer()


                pass
            elif token in [PtxParser.U_DEBUG_PUBNAMES]:
                self.state = 1148
                self.match(PtxParser.U_DEBUG_PUBNAMES)
                pass
            elif token in [PtxParser.U_DEBUG_RANGES]:
                self.state = 1149
                self.match(PtxParser.U_DEBUG_RANGES)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LocContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_LOC(self):
            return self.getToken(PtxParser.K_LOC, 0)

        def integer(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.IntegerContext)
            else:
                return self.getTypedRuleContext(PtxParser.IntegerContext,i)


        def getRuleIndex(self):
            return PtxParser.RULE_loc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoc" ):
                listener.enterLoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoc" ):
                listener.exitLoc(self)




    def loc(self):

        localctx = PtxParser.LocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_loc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1152
            self.match(PtxParser.K_LOC)
            self.state = 1153
            self.integer()
            self.state = 1154
            self.integer()
            self.state = 1155
            self.integer()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Linking_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def extern_(self):
            return self.getTypedRuleContext(PtxParser.Extern_Context,0)


        def visible(self):
            return self.getTypedRuleContext(PtxParser.VisibleContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_linking_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLinking_directive" ):
                listener.enterLinking_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLinking_directive" ):
                listener.exitLinking_directive(self)




    def linking_directive(self):

        localctx = PtxParser.Linking_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_linking_directive)
        try:
            self.state = 1159
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_EXTERN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1157
                self.extern_()
                pass
            elif token in [PtxParser.K_VISIBLE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1158
                self.visible()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Extern_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_EXTERN(self):
            return self.getToken(PtxParser.K_EXTERN, 0)

        def identifier_decl(self):
            return self.getTypedRuleContext(PtxParser.Identifier_declContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_extern_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtern_" ):
                listener.enterExtern_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtern_" ):
                listener.exitExtern_(self)




    def extern_(self):

        localctx = PtxParser.Extern_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_extern_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1161
            self.match(PtxParser.K_EXTERN)
            self.state = 1162
            self.identifier_decl()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VisibleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_VISIBLE(self):
            return self.getToken(PtxParser.K_VISIBLE, 0)

        def identifier_decl(self):
            return self.getTypedRuleContext(PtxParser.Identifier_declContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_visible

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisible" ):
                listener.enterVisible(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisible" ):
                listener.exitVisible(self)




    def visible(self):

        localctx = PtxParser.VisibleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_visible)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1164
            self.match(PtxParser.K_VISIBLE)
            self.state = 1165
            self.identifier_decl()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Identifier_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier_decl_aux(self):
            return self.getTypedRuleContext(PtxParser.Identifier_decl_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_identifier_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier_decl" ):
                listener.enterIdentifier_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier_decl" ):
                listener.exitIdentifier_decl(self)




    def identifier_decl(self):

        localctx = PtxParser.Identifier_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_identifier_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1167
            self.identifier_decl_aux()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Identifier_decl_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def state_space_specifier(self):
            return self.getTypedRuleContext(PtxParser.State_space_specifierContext,0)


        def variable_declarator_list(self):
            return self.getTypedRuleContext(PtxParser.Variable_declarator_listContext,0)


        def align(self):
            return self.getTypedRuleContext(PtxParser.AlignContext,0)


        def global_space_specifier(self):
            return self.getTypedRuleContext(PtxParser.Global_space_specifierContext,0)


        def variable_declarator_list_with_initializer(self):
            return self.getTypedRuleContext(PtxParser.Variable_declarator_list_with_initializerContext,0)


        def const_space_specifier(self):
            return self.getTypedRuleContext(PtxParser.Const_space_specifierContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_identifier_decl_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier_decl_aux" ):
                listener.enterIdentifier_decl_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier_decl_aux" ):
                listener.exitIdentifier_decl_aux(self)




    def identifier_decl_aux(self):

        localctx = PtxParser.Identifier_decl_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_identifier_decl_aux)
        self._la = 0 # Token type
        try:
            self.state = 1187
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_TEX, PtxParser.K_SREG, PtxParser.K_SHARED, PtxParser.K_REG, PtxParser.K_PARAM, PtxParser.K_LOCAL, PtxParser.K_ALIGN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1169
                self.state_space_specifier()
                self.state = 1171
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_ALIGN:
                    self.state = 1170
                    self.align()


                self.state = 1173
                self.variable_declarator_list()
                pass
            elif token in [PtxParser.K_GLOBAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1175
                self.global_space_specifier()
                self.state = 1177
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_ALIGN:
                    self.state = 1176
                    self.align()


                self.state = 1179
                self.variable_declarator_list_with_initializer()
                pass
            elif token in [PtxParser.K_CONST]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1181
                self.const_space_specifier()
                self.state = 1183
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_ALIGN:
                    self.state = 1182
                    self.align()


                self.state = 1185
                self.variable_declarator_list_with_initializer()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_declarator_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typet(self):
            return self.getTypedRuleContext(PtxParser.TypetContext,0)


        def variable_declarator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Variable_declaratorContext)
            else:
                return self.getTypedRuleContext(PtxParser.Variable_declaratorContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_variable_declarator_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_declarator_list" ):
                listener.enterVariable_declarator_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_declarator_list" ):
                listener.exitVariable_declarator_list(self)




    def variable_declarator_list(self):

        localctx = PtxParser.Variable_declarator_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_variable_declarator_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1189
            self.typet()
            self.state = 1190
            self.variable_declarator()
            self.state = 1195
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_COMMA:
                self.state = 1191
                self.match(PtxParser.T_COMMA)
                self.state = 1192
                self.variable_declarator()
                self.state = 1197
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_declarator_list_with_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def typet(self):
            return self.getTypedRuleContext(PtxParser.TypetContext,0)


        def variable_declarator_with_initializer(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Variable_declarator_with_initializerContext)
            else:
                return self.getTypedRuleContext(PtxParser.Variable_declarator_with_initializerContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_variable_declarator_list_with_initializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_declarator_list_with_initializer" ):
                listener.enterVariable_declarator_list_with_initializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_declarator_list_with_initializer" ):
                listener.exitVariable_declarator_list_with_initializer(self)




    def variable_declarator_list_with_initializer(self):

        localctx = PtxParser.Variable_declarator_list_with_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_variable_declarator_list_with_initializer)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1198
            self.typet()
            self.state = 1199
            self.variable_declarator_with_initializer()
            self.state = 1204
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_COMMA:
                self.state = 1200
                self.match(PtxParser.T_COMMA)
                self.state = 1201
                self.variable_declarator_with_initializer()
                self.state = 1206
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_declaratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def id_or_opcode(self):
            return self.getTypedRuleContext(PtxParser.Id_or_opcodeContext,0)


        def array_spec(self):
            return self.getTypedRuleContext(PtxParser.Array_specContext,0)


        def parameterized_register_spec(self):
            return self.getTypedRuleContext(PtxParser.Parameterized_register_specContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_variable_declarator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_declarator" ):
                listener.enterVariable_declarator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_declarator" ):
                listener.exitVariable_declarator(self)




    def variable_declarator(self):

        localctx = PtxParser.Variable_declaratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_variable_declarator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1207
            self.id_or_opcode()
            self.state = 1210
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.T_OB]:
                self.state = 1208
                self.array_spec()
                pass
            elif token in [PtxParser.T_HEX_LITERAL, PtxParser.T_OCT_LITERAL, PtxParser.T_DEC_LITERAL, PtxParser.T_LT]:
                self.state = 1209
                self.parameterized_register_spec()
                pass
            elif token in [PtxParser.T_SEMICOLON, PtxParser.T_COMMA]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Array_specContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def array_spec_aux(self):
            return self.getTypedRuleContext(PtxParser.Array_spec_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_array_spec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_spec" ):
                listener.enterArray_spec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_spec" ):
                listener.exitArray_spec(self)




    def array_spec(self):

        localctx = PtxParser.Array_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_array_spec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1212
            self.array_spec_aux()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Array_spec_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OB(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_OB)
            else:
                return self.getToken(PtxParser.T_OB, i)

        def T_CB(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_CB)
            else:
                return self.getToken(PtxParser.T_CB, i)

        def integer(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.IntegerContext)
            else:
                return self.getTypedRuleContext(PtxParser.IntegerContext,i)


        def getRuleIndex(self):
            return PtxParser.RULE_array_spec_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_spec_aux" ):
                listener.enterArray_spec_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_spec_aux" ):
                listener.exitArray_spec_aux(self)




    def array_spec_aux(self):

        localctx = PtxParser.Array_spec_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_array_spec_aux)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1219 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1214
                    self.match(PtxParser.T_OB)
                    self.state = 1216
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if ((((_la - 95)) & ~0x3f) == 0 and ((1 << (_la - 95)) & ((1 << (PtxParser.T_HEX_LITERAL - 95)) | (1 << (PtxParser.T_OCT_LITERAL - 95)) | (1 << (PtxParser.T_DEC_LITERAL - 95)))) != 0):
                        self.state = 1215
                        self.integer()


                    self.state = 1218
                    self.match(PtxParser.T_CB)

                else:
                    raise NoViableAltException(self)
                self.state = 1221 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,70,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameterized_register_specContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_LT(self):
            return self.getToken(PtxParser.T_LT, 0)

        def integer(self):
            return self.getTypedRuleContext(PtxParser.IntegerContext,0)


        def T_GT(self):
            return self.getToken(PtxParser.T_GT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_parameterized_register_spec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameterized_register_spec" ):
                listener.enterParameterized_register_spec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameterized_register_spec" ):
                listener.exitParameterized_register_spec(self)




    def parameterized_register_spec(self):

        localctx = PtxParser.Parameterized_register_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_parameterized_register_spec)
        try:
            self.state = 1228
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.T_LT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1223
                self.match(PtxParser.T_LT)
                self.state = 1224
                self.integer()
                self.state = 1225
                self.match(PtxParser.T_GT)
                pass
            elif token in [PtxParser.T_HEX_LITERAL, PtxParser.T_OCT_LITERAL, PtxParser.T_DEC_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1227
                self.integer()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Id_or_opcodeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_WORD(self):
            return self.getToken(PtxParser.T_WORD, 0)

        def opcode(self):
            return self.getTypedRuleContext(PtxParser.OpcodeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_id_or_opcode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterId_or_opcode" ):
                listener.enterId_or_opcode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitId_or_opcode" ):
                listener.exitId_or_opcode(self)




    def id_or_opcode(self):

        localctx = PtxParser.Id_or_opcodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_id_or_opcode)
        try:
            self.state = 1232
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.T_WORD]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1230
                self.match(PtxParser.T_WORD)
                pass
            elif token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1231
                self.opcode()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OpcodeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_ABS(self):
            return self.getToken(PtxParser.KI_ABS, 0)

        def KI_ADD(self):
            return self.getToken(PtxParser.KI_ADD, 0)

        def KI_ADDC(self):
            return self.getToken(PtxParser.KI_ADDC, 0)

        def KI_AND(self):
            return self.getToken(PtxParser.KI_AND, 0)

        def KI_ATOM(self):
            return self.getToken(PtxParser.KI_ATOM, 0)

        def KI_BAR(self):
            return self.getToken(PtxParser.KI_BAR, 0)

        def KI_BFE(self):
            return self.getToken(PtxParser.KI_BFE, 0)

        def KI_BFI(self):
            return self.getToken(PtxParser.KI_BFI, 0)

        def KI_BFIND(self):
            return self.getToken(PtxParser.KI_BFIND, 0)

        def KI_BRA(self):
            return self.getToken(PtxParser.KI_BRA, 0)

        def KI_BREV(self):
            return self.getToken(PtxParser.KI_BREV, 0)

        def KI_BRKPT(self):
            return self.getToken(PtxParser.KI_BRKPT, 0)

        def KI_CALL(self):
            return self.getToken(PtxParser.KI_CALL, 0)

        def KI_CLZ(self):
            return self.getToken(PtxParser.KI_CLZ, 0)

        def KI_CNOT(self):
            return self.getToken(PtxParser.KI_CNOT, 0)

        def KI_COPYSIGN(self):
            return self.getToken(PtxParser.KI_COPYSIGN, 0)

        def KI_COS(self):
            return self.getToken(PtxParser.KI_COS, 0)

        def KI_CVT(self):
            return self.getToken(PtxParser.KI_CVT, 0)

        def KI_CVTA(self):
            return self.getToken(PtxParser.KI_CVTA, 0)

        def KI_DIV(self):
            return self.getToken(PtxParser.KI_DIV, 0)

        def KI_EX2(self):
            return self.getToken(PtxParser.KI_EX2, 0)

        def KI_EXIT(self):
            return self.getToken(PtxParser.KI_EXIT, 0)

        def KI_FMA(self):
            return self.getToken(PtxParser.KI_FMA, 0)

        def KI_ISSPACEP(self):
            return self.getToken(PtxParser.KI_ISSPACEP, 0)

        def KI_LD(self):
            return self.getToken(PtxParser.KI_LD, 0)

        def KI_LDU(self):
            return self.getToken(PtxParser.KI_LDU, 0)

        def KI_LG2(self):
            return self.getToken(PtxParser.KI_LG2, 0)

        def KI_MAD(self):
            return self.getToken(PtxParser.KI_MAD, 0)

        def KI_MADC(self):
            return self.getToken(PtxParser.KI_MADC, 0)

        def KI_MAD24(self):
            return self.getToken(PtxParser.KI_MAD24, 0)

        def KI_MAX(self):
            return self.getToken(PtxParser.KI_MAX, 0)

        def KI_MEMBAR(self):
            return self.getToken(PtxParser.KI_MEMBAR, 0)

        def KI_MIN(self):
            return self.getToken(PtxParser.KI_MIN, 0)

        def KI_MOV(self):
            return self.getToken(PtxParser.KI_MOV, 0)

        def KI_MUL(self):
            return self.getToken(PtxParser.KI_MUL, 0)

        def KI_MUL24(self):
            return self.getToken(PtxParser.KI_MUL24, 0)

        def KI_NEG(self):
            return self.getToken(PtxParser.KI_NEG, 0)

        def KI_NOT(self):
            return self.getToken(PtxParser.KI_NOT, 0)

        def KI_OR(self):
            return self.getToken(PtxParser.KI_OR, 0)

        def KI_PMEVENT(self):
            return self.getToken(PtxParser.KI_PMEVENT, 0)

        def KI_POPC(self):
            return self.getToken(PtxParser.KI_POPC, 0)

        def KI_PREFETCH(self):
            return self.getToken(PtxParser.KI_PREFETCH, 0)

        def KI_PREFETCHU(self):
            return self.getToken(PtxParser.KI_PREFETCHU, 0)

        def KI_PRMT(self):
            return self.getToken(PtxParser.KI_PRMT, 0)

        def KI_RCP(self):
            return self.getToken(PtxParser.KI_RCP, 0)

        def KI_RED(self):
            return self.getToken(PtxParser.KI_RED, 0)

        def KI_REM(self):
            return self.getToken(PtxParser.KI_REM, 0)

        def KI_RET(self):
            return self.getToken(PtxParser.KI_RET, 0)

        def KI_RSQRT(self):
            return self.getToken(PtxParser.KI_RSQRT, 0)

        def KI_SAD(self):
            return self.getToken(PtxParser.KI_SAD, 0)

        def KI_SELP(self):
            return self.getToken(PtxParser.KI_SELP, 0)

        def KI_SET(self):
            return self.getToken(PtxParser.KI_SET, 0)

        def KI_SETP(self):
            return self.getToken(PtxParser.KI_SETP, 0)

        def KI_SHL(self):
            return self.getToken(PtxParser.KI_SHL, 0)

        def KI_SHR(self):
            return self.getToken(PtxParser.KI_SHR, 0)

        def KI_SIN(self):
            return self.getToken(PtxParser.KI_SIN, 0)

        def KI_SLCT(self):
            return self.getToken(PtxParser.KI_SLCT, 0)

        def KI_SQRT(self):
            return self.getToken(PtxParser.KI_SQRT, 0)

        def KI_ST(self):
            return self.getToken(PtxParser.KI_ST, 0)

        def KI_SUB(self):
            return self.getToken(PtxParser.KI_SUB, 0)

        def KI_SUBC(self):
            return self.getToken(PtxParser.KI_SUBC, 0)

        def KI_SULD(self):
            return self.getToken(PtxParser.KI_SULD, 0)

        def KI_SURED(self):
            return self.getToken(PtxParser.KI_SURED, 0)

        def KI_SUST(self):
            return self.getToken(PtxParser.KI_SUST, 0)

        def KI_SUQ(self):
            return self.getToken(PtxParser.KI_SUQ, 0)

        def KI_TESTP(self):
            return self.getToken(PtxParser.KI_TESTP, 0)

        def KI_TEX(self):
            return self.getToken(PtxParser.KI_TEX, 0)

        def KI_TXQ(self):
            return self.getToken(PtxParser.KI_TXQ, 0)

        def KI_TRAP(self):
            return self.getToken(PtxParser.KI_TRAP, 0)

        def KI_VABSDIFF(self):
            return self.getToken(PtxParser.KI_VABSDIFF, 0)

        def KI_VADD(self):
            return self.getToken(PtxParser.KI_VADD, 0)

        def KI_VMAD(self):
            return self.getToken(PtxParser.KI_VMAD, 0)

        def KI_VMAX(self):
            return self.getToken(PtxParser.KI_VMAX, 0)

        def KI_VMIN(self):
            return self.getToken(PtxParser.KI_VMIN, 0)

        def KI_VSET(self):
            return self.getToken(PtxParser.KI_VSET, 0)

        def KI_VSHL(self):
            return self.getToken(PtxParser.KI_VSHL, 0)

        def KI_VSHR(self):
            return self.getToken(PtxParser.KI_VSHR, 0)

        def KI_VSUB(self):
            return self.getToken(PtxParser.KI_VSUB, 0)

        def KI_VOTE(self):
            return self.getToken(PtxParser.KI_VOTE, 0)

        def KI_XOR(self):
            return self.getToken(PtxParser.KI_XOR, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_opcode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpcode" ):
                listener.enterOpcode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpcode" ):
                listener.exitOpcode(self)




    def opcode(self):

        localctx = PtxParser.OpcodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_opcode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1234
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PtxParser.KI_ABS) | (1 << PtxParser.KI_ADD) | (1 << PtxParser.KI_ADDC) | (1 << PtxParser.KI_AND) | (1 << PtxParser.KI_ATOM) | (1 << PtxParser.KI_BAR) | (1 << PtxParser.KI_BFE) | (1 << PtxParser.KI_BFI) | (1 << PtxParser.KI_BFIND) | (1 << PtxParser.KI_BRA) | (1 << PtxParser.KI_BREV) | (1 << PtxParser.KI_BRKPT) | (1 << PtxParser.KI_CALL) | (1 << PtxParser.KI_CLZ) | (1 << PtxParser.KI_CNOT) | (1 << PtxParser.KI_COPYSIGN) | (1 << PtxParser.KI_COS) | (1 << PtxParser.KI_CVT) | (1 << PtxParser.KI_CVTA) | (1 << PtxParser.KI_DIV) | (1 << PtxParser.KI_EX2) | (1 << PtxParser.KI_EXIT) | (1 << PtxParser.KI_FMA) | (1 << PtxParser.KI_ISSPACEP) | (1 << PtxParser.KI_LD) | (1 << PtxParser.KI_LDU) | (1 << PtxParser.KI_LG2) | (1 << PtxParser.KI_MAD24) | (1 << PtxParser.KI_MAD) | (1 << PtxParser.KI_MADC) | (1 << PtxParser.KI_MAX) | (1 << PtxParser.KI_MEMBAR) | (1 << PtxParser.KI_MIN) | (1 << PtxParser.KI_MOV) | (1 << PtxParser.KI_MUL24) | (1 << PtxParser.KI_MUL) | (1 << PtxParser.KI_NEG) | (1 << PtxParser.KI_NOT) | (1 << PtxParser.KI_OR) | (1 << PtxParser.KI_PMEVENT) | (1 << PtxParser.KI_POPC) | (1 << PtxParser.KI_PREFETCH) | (1 << PtxParser.KI_PREFETCHU) | (1 << PtxParser.KI_PRMT) | (1 << PtxParser.KI_RCP) | (1 << PtxParser.KI_RED) | (1 << PtxParser.KI_REM) | (1 << PtxParser.KI_RET) | (1 << PtxParser.KI_RSQRT) | (1 << PtxParser.KI_SAD) | (1 << PtxParser.KI_SELP) | (1 << PtxParser.KI_SETP) | (1 << PtxParser.KI_SET) | (1 << PtxParser.KI_SHL) | (1 << PtxParser.KI_SHR) | (1 << PtxParser.KI_SIN) | (1 << PtxParser.KI_SLCT) | (1 << PtxParser.KI_SQRT) | (1 << PtxParser.KI_ST) | (1 << PtxParser.KI_SUB) | (1 << PtxParser.KI_SUBC) | (1 << PtxParser.KI_SULD) | (1 << PtxParser.KI_SUQ))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (PtxParser.KI_SURED - 64)) | (1 << (PtxParser.KI_SUST - 64)) | (1 << (PtxParser.KI_TESTP - 64)) | (1 << (PtxParser.KI_TEX - 64)) | (1 << (PtxParser.KI_TRAP - 64)) | (1 << (PtxParser.KI_TXQ - 64)) | (1 << (PtxParser.KI_VABSDIFF - 64)) | (1 << (PtxParser.KI_VADD - 64)) | (1 << (PtxParser.KI_VMAD - 64)) | (1 << (PtxParser.KI_VMAX - 64)) | (1 << (PtxParser.KI_VMIN - 64)) | (1 << (PtxParser.KI_VOTE - 64)) | (1 << (PtxParser.KI_VSET - 64)) | (1 << (PtxParser.KI_VSHL - 64)) | (1 << (PtxParser.KI_VSHR - 64)) | (1 << (PtxParser.KI_VSUB - 64)) | (1 << (PtxParser.KI_XOR - 64)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_declarator_with_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def id_or_opcode(self):
            return self.getTypedRuleContext(PtxParser.Id_or_opcodeContext,0)


        def array_spec(self):
            return self.getTypedRuleContext(PtxParser.Array_specContext,0)


        def variable_equal_initializer(self):
            return self.getTypedRuleContext(PtxParser.Variable_equal_initializerContext,0)


        def T_LT(self):
            return self.getToken(PtxParser.T_LT, 0)

        def integer(self):
            return self.getTypedRuleContext(PtxParser.IntegerContext,0)


        def T_GT(self):
            return self.getToken(PtxParser.T_GT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_variable_declarator_with_initializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_declarator_with_initializer" ):
                listener.enterVariable_declarator_with_initializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_declarator_with_initializer" ):
                listener.exitVariable_declarator_with_initializer(self)




    def variable_declarator_with_initializer(self):

        localctx = PtxParser.Variable_declarator_with_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_variable_declarator_with_initializer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1236
            self.id_or_opcode()
            self.state = 1245
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.T_OB]:
                self.state = 1237
                self.array_spec()
                self.state = 1238
                self.variable_equal_initializer()
                pass
            elif token in [PtxParser.T_LT]:
                self.state = 1240
                self.match(PtxParser.T_LT)
                self.state = 1241
                self.integer()
                self.state = 1242
                self.match(PtxParser.T_GT)
                pass
            elif token in [PtxParser.T_SEMICOLON, PtxParser.T_COMMA]:
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_equal_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_EQ(self):
            return self.getToken(PtxParser.T_EQ, 0)

        def variable_initializer(self):
            return self.getTypedRuleContext(PtxParser.Variable_initializerContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_variable_equal_initializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_equal_initializer" ):
                listener.enterVariable_equal_initializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_equal_initializer" ):
                listener.exitVariable_equal_initializer(self)




    def variable_equal_initializer(self):

        localctx = PtxParser.Variable_equal_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_variable_equal_initializer)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1249
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_EQ:
                self.state = 1247
                self.match(PtxParser.T_EQ)
                self.state = 1248
                self.variable_initializer()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Variable_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aggregate_initializer(self):
            return self.getTypedRuleContext(PtxParser.Aggregate_initializerContext,0)


        def constant_expression(self):
            return self.getTypedRuleContext(PtxParser.Constant_expressionContext,0)


        def id_or_opcode(self):
            return self.getTypedRuleContext(PtxParser.Id_or_opcodeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_variable_initializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable_initializer" ):
                listener.enterVariable_initializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable_initializer" ):
                listener.exitVariable_initializer(self)




    def variable_initializer(self):

        localctx = PtxParser.Variable_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_variable_initializer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1254
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.T_OC]:
                self.state = 1251
                self.aggregate_initializer()
                pass
            elif token in [PtxParser.T_TILDE, PtxParser.T_FLT_LITERAL, PtxParser.T_HEX_LITERAL, PtxParser.T_OCT_LITERAL, PtxParser.T_DEC_LITERAL, PtxParser.T_PLUS, PtxParser.T_OP, PtxParser.T_NOT, PtxParser.T_MINUS]:
                self.state = 1252
                self.constant_expression()
                pass
            elif token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR, PtxParser.T_WORD]:
                self.state = 1253
                self.id_or_opcode()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Aggregate_initializerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OC(self):
            return self.getToken(PtxParser.T_OC, 0)

        def T_CC(self):
            return self.getToken(PtxParser.T_CC, 0)

        def variable_initializer(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Variable_initializerContext)
            else:
                return self.getTypedRuleContext(PtxParser.Variable_initializerContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_aggregate_initializer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregate_initializer" ):
                listener.enterAggregate_initializer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregate_initializer" ):
                listener.exitAggregate_initializer(self)




    def aggregate_initializer(self):

        localctx = PtxParser.Aggregate_initializerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_aggregate_initializer)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1256
            self.match(PtxParser.T_OC)
            self.state = 1265
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PtxParser.KI_ABS) | (1 << PtxParser.KI_ADD) | (1 << PtxParser.KI_ADDC) | (1 << PtxParser.KI_AND) | (1 << PtxParser.KI_ATOM) | (1 << PtxParser.KI_BAR) | (1 << PtxParser.KI_BFE) | (1 << PtxParser.KI_BFI) | (1 << PtxParser.KI_BFIND) | (1 << PtxParser.KI_BRA) | (1 << PtxParser.KI_BREV) | (1 << PtxParser.KI_BRKPT) | (1 << PtxParser.KI_CALL) | (1 << PtxParser.KI_CLZ) | (1 << PtxParser.KI_CNOT) | (1 << PtxParser.KI_COPYSIGN) | (1 << PtxParser.KI_COS) | (1 << PtxParser.KI_CVT) | (1 << PtxParser.KI_CVTA) | (1 << PtxParser.KI_DIV) | (1 << PtxParser.KI_EX2) | (1 << PtxParser.KI_EXIT) | (1 << PtxParser.KI_FMA) | (1 << PtxParser.KI_ISSPACEP) | (1 << PtxParser.KI_LD) | (1 << PtxParser.KI_LDU) | (1 << PtxParser.KI_LG2) | (1 << PtxParser.KI_MAD24) | (1 << PtxParser.KI_MAD) | (1 << PtxParser.KI_MADC) | (1 << PtxParser.KI_MAX) | (1 << PtxParser.KI_MEMBAR) | (1 << PtxParser.KI_MIN) | (1 << PtxParser.KI_MOV) | (1 << PtxParser.KI_MUL24) | (1 << PtxParser.KI_MUL) | (1 << PtxParser.KI_NEG) | (1 << PtxParser.KI_NOT) | (1 << PtxParser.KI_OR) | (1 << PtxParser.KI_PMEVENT) | (1 << PtxParser.KI_POPC) | (1 << PtxParser.KI_PREFETCH) | (1 << PtxParser.KI_PREFETCHU) | (1 << PtxParser.KI_PRMT) | (1 << PtxParser.KI_RCP) | (1 << PtxParser.KI_RED) | (1 << PtxParser.KI_REM) | (1 << PtxParser.KI_RET) | (1 << PtxParser.KI_RSQRT) | (1 << PtxParser.KI_SAD) | (1 << PtxParser.KI_SELP) | (1 << PtxParser.KI_SETP) | (1 << PtxParser.KI_SET) | (1 << PtxParser.KI_SHL) | (1 << PtxParser.KI_SHR) | (1 << PtxParser.KI_SIN) | (1 << PtxParser.KI_SLCT) | (1 << PtxParser.KI_SQRT) | (1 << PtxParser.KI_ST) | (1 << PtxParser.KI_SUB) | (1 << PtxParser.KI_SUBC) | (1 << PtxParser.KI_SULD) | (1 << PtxParser.KI_SUQ))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (PtxParser.KI_SURED - 64)) | (1 << (PtxParser.KI_SUST - 64)) | (1 << (PtxParser.KI_TESTP - 64)) | (1 << (PtxParser.KI_TEX - 64)) | (1 << (PtxParser.KI_TRAP - 64)) | (1 << (PtxParser.KI_TXQ - 64)) | (1 << (PtxParser.KI_VABSDIFF - 64)) | (1 << (PtxParser.KI_VADD - 64)) | (1 << (PtxParser.KI_VMAD - 64)) | (1 << (PtxParser.KI_VMAX - 64)) | (1 << (PtxParser.KI_VMIN - 64)) | (1 << (PtxParser.KI_VOTE - 64)) | (1 << (PtxParser.KI_VSET - 64)) | (1 << (PtxParser.KI_VSHL - 64)) | (1 << (PtxParser.KI_VSHR - 64)) | (1 << (PtxParser.KI_VSUB - 64)) | (1 << (PtxParser.KI_XOR - 64)) | (1 << (PtxParser.T_TILDE - 64)) | (1 << (PtxParser.T_FLT_LITERAL - 64)) | (1 << (PtxParser.T_HEX_LITERAL - 64)) | (1 << (PtxParser.T_OCT_LITERAL - 64)) | (1 << (PtxParser.T_DEC_LITERAL - 64)) | (1 << (PtxParser.T_PLUS - 64)) | (1 << (PtxParser.T_OP - 64)) | (1 << (PtxParser.T_OC - 64)) | (1 << (PtxParser.T_NOT - 64)) | (1 << (PtxParser.T_MINUS - 64)))) != 0) or _la==PtxParser.T_WORD:
                self.state = 1257
                self.variable_initializer()
                self.state = 1262
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==PtxParser.T_COMMA:
                    self.state = 1258
                    self.match(PtxParser.T_COMMA)
                    self.state = 1259
                    self.variable_initializer()
                    self.state = 1264
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1267
            self.match(PtxParser.T_CC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fundamental_type(self):
            return self.getTypedRuleContext(PtxParser.Fundamental_typeContext,0)


        def vector_type(self):
            return self.getTypedRuleContext(PtxParser.Vector_typeContext,0)


        def opaque_type(self):
            return self.getTypedRuleContext(PtxParser.Opaque_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_typet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypet" ):
                listener.enterTypet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypet" ):
                listener.exitTypet(self)




    def typet(self):

        localctx = PtxParser.TypetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_typet)
        try:
            self.state = 1272
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_U8, PtxParser.K_U64, PtxParser.K_U32, PtxParser.K_U16, PtxParser.K_S8, PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16, PtxParser.K_PRED, PtxParser.K_F64, PtxParser.K_F32, PtxParser.K_F16, PtxParser.K_B8, PtxParser.K_B64, PtxParser.K_B32, PtxParser.K_B16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1269
                self.fundamental_type()
                pass
            elif token in [PtxParser.K_V4, PtxParser.K_V2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1270
                self.vector_type()
                pass
            elif token in [PtxParser.K_TEXREF, PtxParser.K_SURFREF, PtxParser.K_SAMPLERREF]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1271
                self.opaque_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdiContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self):
            return self.getTypedRuleContext(PtxParser.OprContext,0)


        def array_spec(self):
            return self.getTypedRuleContext(PtxParser.Array_specContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_idi

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdi" ):
                listener.enterIdi(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdi" ):
                listener.exitIdi(self)




    def idi(self):

        localctx = PtxParser.IdiContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_idi)
        try:
            self.state = 1276
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR, PtxParser.T_TILDE, PtxParser.T_FLT_LITERAL, PtxParser.T_HEX_LITERAL, PtxParser.T_OCT_LITERAL, PtxParser.T_DEC_LITERAL, PtxParser.T_PLUS, PtxParser.T_OP, PtxParser.T_OC, PtxParser.T_NOT, PtxParser.T_MINUS, PtxParser.T_WORD, PtxParser.T_UNDERSCORE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1274
                self.opr()
                pass
            elif token in [PtxParser.T_OB]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1275
                self.array_spec()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class State_space_specifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def state_space_specifier_aux(self):
            return self.getTypedRuleContext(PtxParser.State_space_specifier_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_state_space_specifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_space_specifier" ):
                listener.enterState_space_specifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_space_specifier" ):
                listener.exitState_space_specifier(self)




    def state_space_specifier(self):

        localctx = PtxParser.State_space_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_state_space_specifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1278
            self.state_space_specifier_aux()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class State_space_specifier_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def align(self):
            return self.getTypedRuleContext(PtxParser.AlignContext,0)


        def local(self):
            return self.getTypedRuleContext(PtxParser.LocalContext,0)


        def param(self):
            return self.getTypedRuleContext(PtxParser.ParamContext,0)


        def reg(self):
            return self.getTypedRuleContext(PtxParser.RegContext,0)


        def shared(self):
            return self.getTypedRuleContext(PtxParser.SharedContext,0)


        def sreg(self):
            return self.getTypedRuleContext(PtxParser.SregContext,0)


        def tex(self):
            return self.getTypedRuleContext(PtxParser.TexContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_state_space_specifier_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_space_specifier_aux" ):
                listener.enterState_space_specifier_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_space_specifier_aux" ):
                listener.exitState_space_specifier_aux(self)




    def state_space_specifier_aux(self):

        localctx = PtxParser.State_space_specifier_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_state_space_specifier_aux)
        try:
            self.state = 1287
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_ALIGN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1280
                self.align()
                pass
            elif token in [PtxParser.K_LOCAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1281
                self.local()
                pass
            elif token in [PtxParser.K_PARAM]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1282
                self.param()
                pass
            elif token in [PtxParser.K_REG]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1283
                self.reg()
                pass
            elif token in [PtxParser.K_SHARED]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1284
                self.shared()
                pass
            elif token in [PtxParser.K_SREG]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1285
                self.sreg()
                pass
            elif token in [PtxParser.K_TEX]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1286
                self.tex()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Global_space_specifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def globalg(self):
            return self.getTypedRuleContext(PtxParser.GlobalgContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_global_space_specifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGlobal_space_specifier" ):
                listener.enterGlobal_space_specifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGlobal_space_specifier" ):
                listener.exitGlobal_space_specifier(self)




    def global_space_specifier(self):

        localctx = PtxParser.Global_space_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_global_space_specifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1289
            self.globalg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Const_space_specifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def const_(self):
            return self.getTypedRuleContext(PtxParser.Const_Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_const_space_specifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConst_space_specifier" ):
                listener.enterConst_space_specifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConst_space_specifier" ):
                listener.exitConst_space_specifier(self)




    def const_space_specifier(self):

        localctx = PtxParser.Const_space_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_const_space_specifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1291
            self.const_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Const_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_CONST(self):
            return self.getToken(PtxParser.K_CONST, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_const_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConst_" ):
                listener.enterConst_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConst_" ):
                listener.exitConst_(self)




    def const_(self):

        localctx = PtxParser.Const_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_const_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1293
            self.match(PtxParser.K_CONST)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GlobalgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_GLOBAL(self):
            return self.getToken(PtxParser.K_GLOBAL, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_globalg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGlobalg" ):
                listener.enterGlobalg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGlobalg" ):
                listener.exitGlobalg(self)




    def globalg(self):

        localctx = PtxParser.GlobalgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_globalg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1295
            self.match(PtxParser.K_GLOBAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LocalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_LOCAL(self):
            return self.getToken(PtxParser.K_LOCAL, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_local

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocal" ):
                listener.enterLocal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocal" ):
                listener.exitLocal(self)




    def local(self):

        localctx = PtxParser.LocalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_local)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1297
            self.match(PtxParser.K_LOCAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParamContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PARAM(self):
            return self.getToken(PtxParser.K_PARAM, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_param

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParam" ):
                listener.enterParam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParam" ):
                listener.exitParam(self)




    def param(self):

        localctx = PtxParser.ParamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_param)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1299
            self.match(PtxParser.K_PARAM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RegContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_REG(self):
            return self.getToken(PtxParser.K_REG, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_reg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReg" ):
                listener.enterReg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReg" ):
                listener.exitReg(self)




    def reg(self):

        localctx = PtxParser.RegContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_reg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1301
            self.match(PtxParser.K_REG)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SharedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SHARED(self):
            return self.getToken(PtxParser.K_SHARED, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_shared

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShared" ):
                listener.enterShared(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShared" ):
                listener.exitShared(self)




    def shared(self):

        localctx = PtxParser.SharedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_shared)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1303
            self.match(PtxParser.K_SHARED)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SregContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SREG(self):
            return self.getToken(PtxParser.K_SREG, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_sreg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSreg" ):
                listener.enterSreg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSreg" ):
                listener.exitSreg(self)




    def sreg(self):

        localctx = PtxParser.SregContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_sreg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1305
            self.match(PtxParser.K_SREG)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TexContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_TEX(self):
            return self.getToken(PtxParser.K_TEX, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_tex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTex" ):
                listener.enterTex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTex" ):
                listener.exitTex(self)




    def tex(self):

        localctx = PtxParser.TexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_tex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1307
            self.match(PtxParser.K_TEX)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InstructionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def instruction_aux(self):
            return self.getTypedRuleContext(PtxParser.Instruction_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_instruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstruction" ):
                listener.enterInstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstruction" ):
                listener.exitInstruction(self)




    def instruction(self):

        localctx = PtxParser.InstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_instruction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1309
            self.instruction_aux()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Instruction_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def i_abs(self):
            return self.getTypedRuleContext(PtxParser.I_absContext,0)


        def i_add(self):
            return self.getTypedRuleContext(PtxParser.I_addContext,0)


        def i_addc(self):
            return self.getTypedRuleContext(PtxParser.I_addcContext,0)


        def i_and(self):
            return self.getTypedRuleContext(PtxParser.I_andContext,0)


        def i_atom(self):
            return self.getTypedRuleContext(PtxParser.I_atomContext,0)


        def i_bar(self):
            return self.getTypedRuleContext(PtxParser.I_barContext,0)


        def i_bfe(self):
            return self.getTypedRuleContext(PtxParser.I_bfeContext,0)


        def i_bfi(self):
            return self.getTypedRuleContext(PtxParser.I_bfiContext,0)


        def i_bfind(self):
            return self.getTypedRuleContext(PtxParser.I_bfindContext,0)


        def i_bra(self):
            return self.getTypedRuleContext(PtxParser.I_braContext,0)


        def i_brev(self):
            return self.getTypedRuleContext(PtxParser.I_brevContext,0)


        def i_brkpt(self):
            return self.getTypedRuleContext(PtxParser.I_brkptContext,0)


        def i_call(self):
            return self.getTypedRuleContext(PtxParser.I_callContext,0)


        def i_clz(self):
            return self.getTypedRuleContext(PtxParser.I_clzContext,0)


        def i_cnot(self):
            return self.getTypedRuleContext(PtxParser.I_cnotContext,0)


        def i_copysign(self):
            return self.getTypedRuleContext(PtxParser.I_copysignContext,0)


        def i_cos(self):
            return self.getTypedRuleContext(PtxParser.I_cosContext,0)


        def i_cvt(self):
            return self.getTypedRuleContext(PtxParser.I_cvtContext,0)


        def i_cvta(self):
            return self.getTypedRuleContext(PtxParser.I_cvtaContext,0)


        def i_div(self):
            return self.getTypedRuleContext(PtxParser.I_divContext,0)


        def i_ex2(self):
            return self.getTypedRuleContext(PtxParser.I_ex2Context,0)


        def i_exit(self):
            return self.getTypedRuleContext(PtxParser.I_exitContext,0)


        def i_fma(self):
            return self.getTypedRuleContext(PtxParser.I_fmaContext,0)


        def i_isspacep(self):
            return self.getTypedRuleContext(PtxParser.I_isspacepContext,0)


        def i_ld(self):
            return self.getTypedRuleContext(PtxParser.I_ldContext,0)


        def i_ldu(self):
            return self.getTypedRuleContext(PtxParser.I_lduContext,0)


        def i_lg2(self):
            return self.getTypedRuleContext(PtxParser.I_lg2Context,0)


        def i_mad(self):
            return self.getTypedRuleContext(PtxParser.I_madContext,0)


        def i_madc(self):
            return self.getTypedRuleContext(PtxParser.I_madcContext,0)


        def i_mad24(self):
            return self.getTypedRuleContext(PtxParser.I_mad24Context,0)


        def i_max(self):
            return self.getTypedRuleContext(PtxParser.I_maxContext,0)


        def i_membar(self):
            return self.getTypedRuleContext(PtxParser.I_membarContext,0)


        def i_min(self):
            return self.getTypedRuleContext(PtxParser.I_minContext,0)


        def i_mov(self):
            return self.getTypedRuleContext(PtxParser.I_movContext,0)


        def i_mul(self):
            return self.getTypedRuleContext(PtxParser.I_mulContext,0)


        def i_mul24(self):
            return self.getTypedRuleContext(PtxParser.I_mul24Context,0)


        def i_neg(self):
            return self.getTypedRuleContext(PtxParser.I_negContext,0)


        def i_not(self):
            return self.getTypedRuleContext(PtxParser.I_notContext,0)


        def i_or(self):
            return self.getTypedRuleContext(PtxParser.I_orContext,0)


        def i_pmevent(self):
            return self.getTypedRuleContext(PtxParser.I_pmeventContext,0)


        def i_popc(self):
            return self.getTypedRuleContext(PtxParser.I_popcContext,0)


        def i_prefetch(self):
            return self.getTypedRuleContext(PtxParser.I_prefetchContext,0)


        def i_prefetchu(self):
            return self.getTypedRuleContext(PtxParser.I_prefetchuContext,0)


        def i_prmt(self):
            return self.getTypedRuleContext(PtxParser.I_prmtContext,0)


        def i_rcp(self):
            return self.getTypedRuleContext(PtxParser.I_rcpContext,0)


        def i_red(self):
            return self.getTypedRuleContext(PtxParser.I_redContext,0)


        def i_rem(self):
            return self.getTypedRuleContext(PtxParser.I_remContext,0)


        def i_ret(self):
            return self.getTypedRuleContext(PtxParser.I_retContext,0)


        def i_rsqrt(self):
            return self.getTypedRuleContext(PtxParser.I_rsqrtContext,0)


        def i_sad(self):
            return self.getTypedRuleContext(PtxParser.I_sadContext,0)


        def i_selp(self):
            return self.getTypedRuleContext(PtxParser.I_selpContext,0)


        def i_set(self):
            return self.getTypedRuleContext(PtxParser.I_setContext,0)


        def i_setp(self):
            return self.getTypedRuleContext(PtxParser.I_setpContext,0)


        def i_shl(self):
            return self.getTypedRuleContext(PtxParser.I_shlContext,0)


        def i_shr(self):
            return self.getTypedRuleContext(PtxParser.I_shrContext,0)


        def i_sin(self):
            return self.getTypedRuleContext(PtxParser.I_sinContext,0)


        def i_slct(self):
            return self.getTypedRuleContext(PtxParser.I_slctContext,0)


        def i_sqrt(self):
            return self.getTypedRuleContext(PtxParser.I_sqrtContext,0)


        def i_st(self):
            return self.getTypedRuleContext(PtxParser.I_stContext,0)


        def i_sub(self):
            return self.getTypedRuleContext(PtxParser.I_subContext,0)


        def i_subc(self):
            return self.getTypedRuleContext(PtxParser.I_subcContext,0)


        def i_suld(self):
            return self.getTypedRuleContext(PtxParser.I_suldContext,0)


        def i_sured(self):
            return self.getTypedRuleContext(PtxParser.I_suredContext,0)


        def i_sust(self):
            return self.getTypedRuleContext(PtxParser.I_sustContext,0)


        def i_suq(self):
            return self.getTypedRuleContext(PtxParser.I_suqContext,0)


        def i_testp(self):
            return self.getTypedRuleContext(PtxParser.I_testpContext,0)


        def i_tex(self):
            return self.getTypedRuleContext(PtxParser.I_texContext,0)


        def i_txq(self):
            return self.getTypedRuleContext(PtxParser.I_txqContext,0)


        def i_trap(self):
            return self.getTypedRuleContext(PtxParser.I_trapContext,0)


        def i_vabsdiff(self):
            return self.getTypedRuleContext(PtxParser.I_vabsdiffContext,0)


        def i_vadd(self):
            return self.getTypedRuleContext(PtxParser.I_vaddContext,0)


        def i_vmad(self):
            return self.getTypedRuleContext(PtxParser.I_vmadContext,0)


        def i_vmax(self):
            return self.getTypedRuleContext(PtxParser.I_vmaxContext,0)


        def i_vmin(self):
            return self.getTypedRuleContext(PtxParser.I_vminContext,0)


        def i_vset(self):
            return self.getTypedRuleContext(PtxParser.I_vsetContext,0)


        def i_vshl(self):
            return self.getTypedRuleContext(PtxParser.I_vshlContext,0)


        def i_vshr(self):
            return self.getTypedRuleContext(PtxParser.I_vshrContext,0)


        def i_vsub(self):
            return self.getTypedRuleContext(PtxParser.I_vsubContext,0)


        def i_vote(self):
            return self.getTypedRuleContext(PtxParser.I_voteContext,0)


        def i_xor(self):
            return self.getTypedRuleContext(PtxParser.I_xorContext,0)


        def predicate(self):
            return self.getTypedRuleContext(PtxParser.PredicateContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_instruction_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstruction_aux" ):
                listener.enterInstruction_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstruction_aux" ):
                listener.exitInstruction_aux(self)




    def instruction_aux(self):

        localctx = PtxParser.Instruction_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_instruction_aux)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1312
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_AT:
                self.state = 1311
                self.predicate()


            self.state = 1394
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.KI_ABS]:
                self.state = 1314
                self.i_abs()
                pass
            elif token in [PtxParser.KI_ADD]:
                self.state = 1315
                self.i_add()
                pass
            elif token in [PtxParser.KI_ADDC]:
                self.state = 1316
                self.i_addc()
                pass
            elif token in [PtxParser.KI_AND]:
                self.state = 1317
                self.i_and()
                pass
            elif token in [PtxParser.KI_ATOM]:
                self.state = 1318
                self.i_atom()
                pass
            elif token in [PtxParser.KI_BAR]:
                self.state = 1319
                self.i_bar()
                pass
            elif token in [PtxParser.KI_BFE]:
                self.state = 1320
                self.i_bfe()
                pass
            elif token in [PtxParser.KI_BFI]:
                self.state = 1321
                self.i_bfi()
                pass
            elif token in [PtxParser.KI_BFIND]:
                self.state = 1322
                self.i_bfind()
                pass
            elif token in [PtxParser.KI_BRA]:
                self.state = 1323
                self.i_bra()
                pass
            elif token in [PtxParser.KI_BREV]:
                self.state = 1324
                self.i_brev()
                pass
            elif token in [PtxParser.KI_BRKPT]:
                self.state = 1325
                self.i_brkpt()
                pass
            elif token in [PtxParser.KI_CALL]:
                self.state = 1326
                self.i_call()
                pass
            elif token in [PtxParser.KI_CLZ]:
                self.state = 1327
                self.i_clz()
                pass
            elif token in [PtxParser.KI_CNOT]:
                self.state = 1328
                self.i_cnot()
                pass
            elif token in [PtxParser.KI_COPYSIGN]:
                self.state = 1329
                self.i_copysign()
                pass
            elif token in [PtxParser.KI_COS]:
                self.state = 1330
                self.i_cos()
                pass
            elif token in [PtxParser.KI_CVT]:
                self.state = 1331
                self.i_cvt()
                pass
            elif token in [PtxParser.KI_CVTA]:
                self.state = 1332
                self.i_cvta()
                pass
            elif token in [PtxParser.KI_DIV]:
                self.state = 1333
                self.i_div()
                pass
            elif token in [PtxParser.KI_EX2]:
                self.state = 1334
                self.i_ex2()
                pass
            elif token in [PtxParser.KI_EXIT]:
                self.state = 1335
                self.i_exit()
                pass
            elif token in [PtxParser.KI_FMA]:
                self.state = 1336
                self.i_fma()
                pass
            elif token in [PtxParser.KI_ISSPACEP]:
                self.state = 1337
                self.i_isspacep()
                pass
            elif token in [PtxParser.KI_LD]:
                self.state = 1338
                self.i_ld()
                pass
            elif token in [PtxParser.KI_LDU]:
                self.state = 1339
                self.i_ldu()
                pass
            elif token in [PtxParser.KI_LG2]:
                self.state = 1340
                self.i_lg2()
                pass
            elif token in [PtxParser.KI_MAD]:
                self.state = 1341
                self.i_mad()
                pass
            elif token in [PtxParser.KI_MADC]:
                self.state = 1342
                self.i_madc()
                pass
            elif token in [PtxParser.KI_MAD24]:
                self.state = 1343
                self.i_mad24()
                pass
            elif token in [PtxParser.KI_MAX]:
                self.state = 1344
                self.i_max()
                pass
            elif token in [PtxParser.KI_MEMBAR]:
                self.state = 1345
                self.i_membar()
                pass
            elif token in [PtxParser.KI_MIN]:
                self.state = 1346
                self.i_min()
                pass
            elif token in [PtxParser.KI_MOV]:
                self.state = 1347
                self.i_mov()
                pass
            elif token in [PtxParser.KI_MUL]:
                self.state = 1348
                self.i_mul()
                pass
            elif token in [PtxParser.KI_MUL24]:
                self.state = 1349
                self.i_mul24()
                pass
            elif token in [PtxParser.KI_NEG]:
                self.state = 1350
                self.i_neg()
                pass
            elif token in [PtxParser.KI_NOT]:
                self.state = 1351
                self.i_not()
                pass
            elif token in [PtxParser.KI_OR]:
                self.state = 1352
                self.i_or()
                pass
            elif token in [PtxParser.KI_PMEVENT]:
                self.state = 1353
                self.i_pmevent()
                pass
            elif token in [PtxParser.KI_POPC]:
                self.state = 1354
                self.i_popc()
                pass
            elif token in [PtxParser.KI_PREFETCH]:
                self.state = 1355
                self.i_prefetch()
                pass
            elif token in [PtxParser.KI_PREFETCHU]:
                self.state = 1356
                self.i_prefetchu()
                pass
            elif token in [PtxParser.KI_PRMT]:
                self.state = 1357
                self.i_prmt()
                pass
            elif token in [PtxParser.KI_RCP]:
                self.state = 1358
                self.i_rcp()
                pass
            elif token in [PtxParser.KI_RED]:
                self.state = 1359
                self.i_red()
                pass
            elif token in [PtxParser.KI_REM]:
                self.state = 1360
                self.i_rem()
                pass
            elif token in [PtxParser.KI_RET]:
                self.state = 1361
                self.i_ret()
                pass
            elif token in [PtxParser.KI_RSQRT]:
                self.state = 1362
                self.i_rsqrt()
                pass
            elif token in [PtxParser.KI_SAD]:
                self.state = 1363
                self.i_sad()
                pass
            elif token in [PtxParser.KI_SELP]:
                self.state = 1364
                self.i_selp()
                pass
            elif token in [PtxParser.KI_SET]:
                self.state = 1365
                self.i_set()
                pass
            elif token in [PtxParser.KI_SETP]:
                self.state = 1366
                self.i_setp()
                pass
            elif token in [PtxParser.KI_SHL]:
                self.state = 1367
                self.i_shl()
                pass
            elif token in [PtxParser.KI_SHR]:
                self.state = 1368
                self.i_shr()
                pass
            elif token in [PtxParser.KI_SIN]:
                self.state = 1369
                self.i_sin()
                pass
            elif token in [PtxParser.KI_SLCT]:
                self.state = 1370
                self.i_slct()
                pass
            elif token in [PtxParser.KI_SQRT]:
                self.state = 1371
                self.i_sqrt()
                pass
            elif token in [PtxParser.KI_ST]:
                self.state = 1372
                self.i_st()
                pass
            elif token in [PtxParser.KI_SUB]:
                self.state = 1373
                self.i_sub()
                pass
            elif token in [PtxParser.KI_SUBC]:
                self.state = 1374
                self.i_subc()
                pass
            elif token in [PtxParser.KI_SULD]:
                self.state = 1375
                self.i_suld()
                pass
            elif token in [PtxParser.KI_SURED]:
                self.state = 1376
                self.i_sured()
                pass
            elif token in [PtxParser.KI_SUST]:
                self.state = 1377
                self.i_sust()
                pass
            elif token in [PtxParser.KI_SUQ]:
                self.state = 1378
                self.i_suq()
                pass
            elif token in [PtxParser.KI_TESTP]:
                self.state = 1379
                self.i_testp()
                pass
            elif token in [PtxParser.KI_TEX]:
                self.state = 1380
                self.i_tex()
                pass
            elif token in [PtxParser.KI_TXQ]:
                self.state = 1381
                self.i_txq()
                pass
            elif token in [PtxParser.KI_TRAP]:
                self.state = 1382
                self.i_trap()
                pass
            elif token in [PtxParser.KI_VABSDIFF]:
                self.state = 1383
                self.i_vabsdiff()
                pass
            elif token in [PtxParser.KI_VADD]:
                self.state = 1384
                self.i_vadd()
                pass
            elif token in [PtxParser.KI_VMAD]:
                self.state = 1385
                self.i_vmad()
                pass
            elif token in [PtxParser.KI_VMAX]:
                self.state = 1386
                self.i_vmax()
                pass
            elif token in [PtxParser.KI_VMIN]:
                self.state = 1387
                self.i_vmin()
                pass
            elif token in [PtxParser.KI_VSET]:
                self.state = 1388
                self.i_vset()
                pass
            elif token in [PtxParser.KI_VSHL]:
                self.state = 1389
                self.i_vshl()
                pass
            elif token in [PtxParser.KI_VSHR]:
                self.state = 1390
                self.i_vshr()
                pass
            elif token in [PtxParser.KI_VSUB]:
                self.state = 1391
                self.i_vsub()
                pass
            elif token in [PtxParser.KI_VOTE]:
                self.state = 1392
                self.i_vote()
                pass
            elif token in [PtxParser.KI_XOR]:
                self.state = 1393
                self.i_xor()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_AT(self):
            return self.getToken(PtxParser.T_AT, 0)

        def T_WORD(self):
            return self.getToken(PtxParser.T_WORD, 0)

        def T_NOT(self):
            return self.getToken(PtxParser.T_NOT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)




    def predicate(self):

        localctx = PtxParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_predicate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1396
            self.match(PtxParser.T_AT)
            self.state = 1398
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_NOT:
                self.state = 1397
                self.match(PtxParser.T_NOT)


            self.state = 1400
            self.match(PtxParser.T_WORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_absContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_ABS(self):
            return self.getToken(PtxParser.KI_ABS, 0)

        def i_abs_opr(self):
            return self.getTypedRuleContext(PtxParser.I_abs_oprContext,0)


        def i_abs_type(self):
            return self.getTypedRuleContext(PtxParser.I_abs_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_abs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_abs" ):
                listener.enterI_abs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_abs" ):
                listener.exitI_abs(self)




    def i_abs(self):

        localctx = PtxParser.I_absContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_i_abs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1402
            self.match(PtxParser.KI_ABS)

            self.state = 1403
            self.i_abs_type()
            self.state = 1404
            self.i_abs_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_abs_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_abs_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_abs_type" ):
                listener.enterI_abs_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_abs_type" ):
                listener.exitI_abs_type(self)




    def i_abs_type(self):

        localctx = PtxParser.I_abs_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_i_abs_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1412
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16]:
                self.state = 1406
                _la = self._input.LA(1)
                if not(((((_la - 160)) & ~0x3f) == 0 and ((1 << (_la - 160)) & ((1 << (PtxParser.K_S64 - 160)) | (1 << (PtxParser.K_S32 - 160)) | (1 << (PtxParser.K_S16 - 160)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [PtxParser.K_FTZ, PtxParser.K_F32]:
                self.state = 1408
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 1407
                    self.match(PtxParser.K_FTZ)


                self.state = 1410
                self.match(PtxParser.K_F32)
                pass
            elif token in [PtxParser.K_F64]:
                self.state = 1411
                self.match(PtxParser.K_F64)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_abs_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constantContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_abs_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_abs_opr" ):
                listener.enterI_abs_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_abs_opr" ):
                listener.exitI_abs_opr(self)




    def i_abs_opr(self):

        localctx = PtxParser.I_abs_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_i_abs_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1414
            self.opr_register()
            self.state = 1415
            self.match(PtxParser.T_COMMA)
            self.state = 1416
            self.opr_register_or_constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_addContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_ADD(self):
            return self.getToken(PtxParser.KI_ADD, 0)

        def i_add_type(self):
            return self.getTypedRuleContext(PtxParser.I_add_typeContext,0)


        def i_add_opr(self):
            return self.getTypedRuleContext(PtxParser.I_add_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_add

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_add" ):
                listener.enterI_add(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_add" ):
                listener.exitI_add(self)




    def i_add(self):

        localctx = PtxParser.I_addContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_i_add)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1418
            self.match(PtxParser.KI_ADD)
            self.state = 1419
            self.i_add_type()
            self.state = 1420
            self.i_add_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_add_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_CC(self):
            return self.getToken(PtxParser.K_CC, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def K_SAT(self):
            return self.getToken(PtxParser.K_SAT, 0)

        def K_RN(self):
            return self.getToken(PtxParser.K_RN, 0)

        def K_RZ(self):
            return self.getToken(PtxParser.K_RZ, 0)

        def K_RM(self):
            return self.getToken(PtxParser.K_RM, 0)

        def K_RP(self):
            return self.getToken(PtxParser.K_RP, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_add_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_add_type" ):
                listener.enterI_add_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_add_type" ):
                listener.exitI_add_type(self)




    def i_add_type(self):

        localctx = PtxParser.I_add_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_i_add_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1445
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
            if la_ == 1:
                self.state = 1429
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PtxParser.K_U64, PtxParser.K_U32, PtxParser.K_U16, PtxParser.K_SAT, PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16]:
                    self.state = 1425
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [PtxParser.K_SAT]:
                        self.state = 1422
                        self.match(PtxParser.K_SAT)
                        self.state = 1423
                        self.match(PtxParser.K_S32)
                        pass
                    elif token in [PtxParser.K_U64, PtxParser.K_U32, PtxParser.K_U16, PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16]:
                        self.state = 1424
                        _la = self._input.LA(1)
                        if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass
                elif token in [PtxParser.K_CC]:
                    self.state = 1427
                    self.match(PtxParser.K_CC)
                    self.state = 1428
                    _la = self._input.LA(1)
                    if not(_la==PtxParser.K_U32 or _la==PtxParser.K_S32):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                self.state = 1432
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0):
                    self.state = 1431
                    _la = self._input.LA(1)
                    if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1435
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 1434
                    self.match(PtxParser.K_FTZ)


                self.state = 1438
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_SAT:
                    self.state = 1437
                    self.match(PtxParser.K_SAT)


                self.state = 1440
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 3:
                self.state = 1442
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0):
                    self.state = 1441
                    _la = self._input.LA(1)
                    if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1444
                self.match(PtxParser.K_F64)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_add_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant2(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_add_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_add_opr" ):
                listener.enterI_add_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_add_opr" ):
                listener.exitI_add_opr(self)




    def i_add_opr(self):

        localctx = PtxParser.I_add_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_i_add_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1447
            self.opr_register()
            self.state = 1448
            self.match(PtxParser.T_COMMA)
            self.state = 1449
            self.opr_register_or_constant2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_addcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_ADDC(self):
            return self.getToken(PtxParser.KI_ADDC, 0)

        def i_addc_type(self):
            return self.getTypedRuleContext(PtxParser.I_addc_typeContext,0)


        def i_addc_opr(self):
            return self.getTypedRuleContext(PtxParser.I_addc_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_addc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_addc" ):
                listener.enterI_addc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_addc" ):
                listener.exitI_addc(self)




    def i_addc(self):

        localctx = PtxParser.I_addcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_i_addc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1451
            self.match(PtxParser.KI_ADDC)
            self.state = 1452
            self.i_addc_type()
            self.state = 1453
            self.i_addc_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_addc_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_CC(self):
            return self.getToken(PtxParser.K_CC, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_addc_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_addc_type" ):
                listener.enterI_addc_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_addc_type" ):
                listener.exitI_addc_type(self)




    def i_addc_type(self):

        localctx = PtxParser.I_addc_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_i_addc_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1456
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_CC:
                self.state = 1455
                self.match(PtxParser.K_CC)


            self.state = 1458
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_addc_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant2(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_addc_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_addc_opr" ):
                listener.enterI_addc_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_addc_opr" ):
                listener.exitI_addc_opr(self)




    def i_addc_opr(self):

        localctx = PtxParser.I_addc_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_i_addc_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1460
            self.opr_register()
            self.state = 1461
            self.match(PtxParser.T_COMMA)
            self.state = 1462
            self.opr_register_or_constant2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_andContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_AND(self):
            return self.getToken(PtxParser.KI_AND, 0)

        def i_and_opr(self):
            return self.getTypedRuleContext(PtxParser.I_and_oprContext,0)


        def i_and_type(self):
            return self.getTypedRuleContext(PtxParser.I_and_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_and

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_and" ):
                listener.enterI_and(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_and" ):
                listener.exitI_and(self)




    def i_and(self):

        localctx = PtxParser.I_andContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_i_and)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1464
            self.match(PtxParser.KI_AND)

            self.state = 1465
            self.i_and_type()
            self.state = 1466
            self.i_and_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_and_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PRED(self):
            return self.getToken(PtxParser.K_PRED, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_and_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_and_type" ):
                listener.enterI_and_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_and_type" ):
                listener.exitI_and_type(self)




    def i_and_type(self):

        localctx = PtxParser.I_and_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_i_and_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1468
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_PRED or ((((_la - 261)) & ~0x3f) == 0 and ((1 << (_la - 261)) & ((1 << (PtxParser.K_B64 - 261)) | (1 << (PtxParser.K_B32 - 261)) | (1 << (PtxParser.K_B16 - 261)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_and_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr3(self):
            return self.getTypedRuleContext(PtxParser.Opr3Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_and_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_and_opr" ):
                listener.enterI_and_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_and_opr" ):
                listener.exitI_and_opr(self)




    def i_and_opr(self):

        localctx = PtxParser.I_and_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_i_and_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1470
            self.opr3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_atomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_ATOM(self):
            return self.getToken(PtxParser.KI_ATOM, 0)

        def i_atom_opr(self):
            return self.getTypedRuleContext(PtxParser.I_atom_oprContext,0)


        def i_atom_type(self):
            return self.getTypedRuleContext(PtxParser.I_atom_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_atom" ):
                listener.enterI_atom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_atom" ):
                listener.exitI_atom(self)




    def i_atom(self):

        localctx = PtxParser.I_atomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_i_atom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1472
            self.match(PtxParser.KI_ATOM)

            self.state = 1473
            self.i_atom_type()
            self.state = 1474
            self.i_atom_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_atom_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_AND(self):
            return self.getToken(PtxParser.K_AND, 0)

        def K_OR(self):
            return self.getToken(PtxParser.K_OR, 0)

        def K_XOR(self):
            return self.getToken(PtxParser.K_XOR, 0)

        def K_CAS(self):
            return self.getToken(PtxParser.K_CAS, 0)

        def K_EXCH(self):
            return self.getToken(PtxParser.K_EXCH, 0)

        def K_ADD(self):
            return self.getToken(PtxParser.K_ADD, 0)

        def K_INC(self):
            return self.getToken(PtxParser.K_INC, 0)

        def K_DEC(self):
            return self.getToken(PtxParser.K_DEC, 0)

        def K_MIN(self):
            return self.getToken(PtxParser.K_MIN, 0)

        def K_MAX(self):
            return self.getToken(PtxParser.K_MAX, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_GLOBAL(self):
            return self.getToken(PtxParser.K_GLOBAL, 0)

        def K_SHARED(self):
            return self.getToken(PtxParser.K_SHARED, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_atom_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_atom_type" ):
                listener.enterI_atom_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_atom_type" ):
                listener.exitI_atom_type(self)




    def i_atom_type(self):

        localctx = PtxParser.I_atom_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_i_atom_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1477
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_SHARED or _la==PtxParser.K_GLOBAL:
                self.state = 1476
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_SHARED or _la==PtxParser.K_GLOBAL):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1479
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_XOR or _la==PtxParser.K_OR or ((((_la - 196)) & ~0x3f) == 0 and ((1 << (_la - 196)) & ((1 << (PtxParser.K_MIN - 196)) | (1 << (PtxParser.K_MAX - 196)) | (1 << (PtxParser.K_INC - 196)) | (1 << (PtxParser.K_EXCH - 196)) | (1 << (PtxParser.K_DEC - 196)) | (1 << (PtxParser.K_CAS - 196)))) != 0) or _la==PtxParser.K_AND or _la==PtxParser.K_ADD):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1480
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_S32 - 141)))) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & ((1 << (PtxParser.K_F32 - 232)) | (1 << (PtxParser.K_B64 - 232)) | (1 << (PtxParser.K_B32 - 232)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_atom_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_atom_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_atom_opr" ):
                listener.enterI_atom_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_atom_opr" ):
                listener.exitI_atom_opr(self)




    def i_atom_opr(self):

        localctx = PtxParser.I_atom_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_i_atom_opr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1482
            self.opr()
            self.state = 1483
            self.match(PtxParser.T_COMMA)
            self.state = 1484
            self.match(PtxParser.T_OB)
            self.state = 1485
            self.opr()
            self.state = 1486
            self.match(PtxParser.T_CB)
            self.state = 1487
            self.match(PtxParser.T_COMMA)
            self.state = 1488
            self.opr()
            self.state = 1491
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_COMMA:
                self.state = 1489
                self.match(PtxParser.T_COMMA)
                self.state = 1490
                self.opr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_barContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def i_bar1(self):
            return self.getTypedRuleContext(PtxParser.I_bar1Context,0)


        def i_bar2(self):
            return self.getTypedRuleContext(PtxParser.I_bar2Context,0)


        def i_bar3(self):
            return self.getTypedRuleContext(PtxParser.I_bar3Context,0)


        def i_bar4(self):
            return self.getTypedRuleContext(PtxParser.I_bar4Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar" ):
                listener.enterI_bar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar" ):
                listener.exitI_bar(self)




    def i_bar(self):

        localctx = PtxParser.I_barContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_i_bar)
        try:
            self.state = 1497
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,96,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1493
                self.i_bar1()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1494
                self.i_bar2()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1495
                self.i_bar3()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1496
                self.i_bar4()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bar1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_BAR(self):
            return self.getToken(PtxParser.KI_BAR, 0)

        def i_bar1_type(self):
            return self.getTypedRuleContext(PtxParser.I_bar1_typeContext,0)


        def i_bar1_opr(self):
            return self.getTypedRuleContext(PtxParser.I_bar1_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bar1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar1" ):
                listener.enterI_bar1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar1" ):
                listener.exitI_bar1(self)




    def i_bar1(self):

        localctx = PtxParser.I_bar1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_i_bar1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1499
            self.match(PtxParser.KI_BAR)
            self.state = 1500
            self.i_bar1_type()
            self.state = 1501
            self.i_bar1_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bar1_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_SYNC(self):
            return self.getToken(PtxParser.K_SYNC, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_bar1_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar1_type" ):
                listener.enterI_bar1_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar1_type" ):
                listener.exitI_bar1_type(self)




    def i_bar1_type(self):

        localctx = PtxParser.I_bar1_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_i_bar1_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1503
            self.match(PtxParser.K_SYNC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bar1_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_bar1_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar1_opr" ):
                listener.enterI_bar1_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar1_opr" ):
                listener.exitI_bar1_opr(self)




    def i_bar1_opr(self):

        localctx = PtxParser.I_bar1_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_i_bar1_opr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1505
            self.opr()
            self.state = 1508
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_COMMA:
                self.state = 1506
                self.match(PtxParser.T_COMMA)
                self.state = 1507
                self.opr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bar2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_BAR(self):
            return self.getToken(PtxParser.KI_BAR, 0)

        def i_bar2_type(self):
            return self.getTypedRuleContext(PtxParser.I_bar2_typeContext,0)


        def i_bar2_opr(self):
            return self.getTypedRuleContext(PtxParser.I_bar2_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bar2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar2" ):
                listener.enterI_bar2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar2" ):
                listener.exitI_bar2(self)




    def i_bar2(self):

        localctx = PtxParser.I_bar2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_i_bar2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1510
            self.match(PtxParser.KI_BAR)
            self.state = 1511
            self.i_bar2_type()
            self.state = 1512
            self.i_bar2_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bar2_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_ARRIVE(self):
            return self.getToken(PtxParser.K_ARRIVE, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_bar2_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar2_type" ):
                listener.enterI_bar2_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar2_type" ):
                listener.exitI_bar2_type(self)




    def i_bar2_type(self):

        localctx = PtxParser.I_bar2_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_i_bar2_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1514
            self.match(PtxParser.K_ARRIVE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bar2_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bar2_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar2_opr" ):
                listener.enterI_bar2_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar2_opr" ):
                listener.exitI_bar2_opr(self)




    def i_bar2_opr(self):

        localctx = PtxParser.I_bar2_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_i_bar2_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1516
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bar3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_BAR(self):
            return self.getToken(PtxParser.KI_BAR, 0)

        def i_bar3_type(self):
            return self.getTypedRuleContext(PtxParser.I_bar3_typeContext,0)


        def i_bar3_opr(self):
            return self.getTypedRuleContext(PtxParser.I_bar3_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bar3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar3" ):
                listener.enterI_bar3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar3" ):
                listener.exitI_bar3(self)




    def i_bar3(self):

        localctx = PtxParser.I_bar3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_i_bar3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1518
            self.match(PtxParser.KI_BAR)
            self.state = 1519
            self.i_bar3_type()
            self.state = 1520
            self.i_bar3_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bar3_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_RED(self):
            return self.getToken(PtxParser.K_RED, 0)

        def K_POPC(self):
            return self.getToken(PtxParser.K_POPC, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_bar3_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar3_type" ):
                listener.enterI_bar3_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar3_type" ):
                listener.exitI_bar3_type(self)




    def i_bar3_type(self):

        localctx = PtxParser.I_bar3_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_i_bar3_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1522
            self.match(PtxParser.K_RED)
            self.state = 1523
            self.match(PtxParser.K_POPC)
            self.state = 1524
            self.match(PtxParser.K_U32)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bar3_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def T_NOT(self):
            return self.getToken(PtxParser.T_NOT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_bar3_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar3_opr" ):
                listener.enterI_bar3_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar3_opr" ):
                listener.exitI_bar3_opr(self)




    def i_bar3_opr(self):

        localctx = PtxParser.I_bar3_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_i_bar3_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1526
            self.opr()
            self.state = 1527
            self.match(PtxParser.T_COMMA)
            self.state = 1528
            self.opr()
            self.state = 1531
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
            if la_ == 1:
                self.state = 1529
                self.match(PtxParser.T_COMMA)
                self.state = 1530
                self.opr()


            self.state = 1533
            self.match(PtxParser.T_COMMA)
            self.state = 1535
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 1534
                self.match(PtxParser.T_NOT)


            self.state = 1537
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bar4Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_BAR(self):
            return self.getToken(PtxParser.KI_BAR, 0)

        def i_bar4_type(self):
            return self.getTypedRuleContext(PtxParser.I_bar4_typeContext,0)


        def i_bar4_opr(self):
            return self.getTypedRuleContext(PtxParser.I_bar4_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bar4

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar4" ):
                listener.enterI_bar4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar4" ):
                listener.exitI_bar4(self)




    def i_bar4(self):

        localctx = PtxParser.I_bar4Context(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_i_bar4)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1539
            self.match(PtxParser.KI_BAR)
            self.state = 1540
            self.i_bar4_type()
            self.state = 1541
            self.i_bar4_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bar4_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_RED(self):
            return self.getToken(PtxParser.K_RED, 0)

        def K_PRED(self):
            return self.getToken(PtxParser.K_PRED, 0)

        def K_AND(self):
            return self.getToken(PtxParser.K_AND, 0)

        def K_OR(self):
            return self.getToken(PtxParser.K_OR, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_bar4_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar4_type" ):
                listener.enterI_bar4_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar4_type" ):
                listener.exitI_bar4_type(self)




    def i_bar4_type(self):

        localctx = PtxParser.I_bar4_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_i_bar4_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1543
            self.match(PtxParser.K_RED)
            self.state = 1544
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_OR or _la==PtxParser.K_AND):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1545
            self.match(PtxParser.K_PRED)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bar4_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def T_NOT(self):
            return self.getToken(PtxParser.T_NOT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_bar4_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bar4_opr" ):
                listener.enterI_bar4_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bar4_opr" ):
                listener.exitI_bar4_opr(self)




    def i_bar4_opr(self):

        localctx = PtxParser.I_bar4_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_i_bar4_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1547
            self.opr()
            self.state = 1548
            self.match(PtxParser.T_COMMA)
            self.state = 1549
            self.opr()
            self.state = 1552
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.state = 1550
                self.match(PtxParser.T_COMMA)
                self.state = 1551
                self.opr()


            self.state = 1554
            self.match(PtxParser.T_COMMA)
            self.state = 1556
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.state = 1555
                self.match(PtxParser.T_NOT)


            self.state = 1558
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bfeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_BFE(self):
            return self.getToken(PtxParser.KI_BFE, 0)

        def i_bfe_type(self):
            return self.getTypedRuleContext(PtxParser.I_bfe_typeContext,0)


        def i_bfe_opr(self):
            return self.getTypedRuleContext(PtxParser.I_bfe_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bfe

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bfe" ):
                listener.enterI_bfe(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bfe" ):
                listener.exitI_bfe(self)




    def i_bfe(self):

        localctx = PtxParser.I_bfeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_i_bfe)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1560
            self.match(PtxParser.KI_BFE)
            self.state = 1561
            self.i_bfe_type()
            self.state = 1562
            self.i_bfe_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bfe_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_bfe_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bfe_type" ):
                listener.enterI_bfe_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bfe_type" ):
                listener.exitI_bfe_type(self)




    def i_bfe_type(self):

        localctx = PtxParser.I_bfe_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_i_bfe_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1564
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bfe_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant3(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant3Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bfe_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bfe_opr" ):
                listener.enterI_bfe_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bfe_opr" ):
                listener.exitI_bfe_opr(self)




    def i_bfe_opr(self):

        localctx = PtxParser.I_bfe_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_i_bfe_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1566
            self.opr_register()
            self.state = 1567
            self.match(PtxParser.T_COMMA)
            self.state = 1568
            self.opr_register_or_constant3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bfiContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_BFI(self):
            return self.getToken(PtxParser.KI_BFI, 0)

        def i_bfi_type(self):
            return self.getTypedRuleContext(PtxParser.I_bfi_typeContext,0)


        def i_bfi_opr(self):
            return self.getTypedRuleContext(PtxParser.I_bfi_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bfi

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bfi" ):
                listener.enterI_bfi(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bfi" ):
                listener.exitI_bfi(self)




    def i_bfi(self):

        localctx = PtxParser.I_bfiContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_i_bfi)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1570
            self.match(PtxParser.KI_BFI)
            self.state = 1571
            self.i_bfi_type()
            self.state = 1572
            self.i_bfi_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bfi_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_bfi_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bfi_type" ):
                listener.enterI_bfi_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bfi_type" ):
                listener.exitI_bfi_type(self)




    def i_bfi_type(self):

        localctx = PtxParser.I_bfi_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_i_bfi_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1574
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_B64 or _la==PtxParser.K_B32):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bfi_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant4(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant4Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bfi_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bfi_opr" ):
                listener.enterI_bfi_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bfi_opr" ):
                listener.exitI_bfi_opr(self)




    def i_bfi_opr(self):

        localctx = PtxParser.I_bfi_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_i_bfi_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1576
            self.opr_register()
            self.state = 1577
            self.match(PtxParser.T_COMMA)
            self.state = 1578
            self.opr_register_or_constant4()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bfindContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_BFIND(self):
            return self.getToken(PtxParser.KI_BFIND, 0)

        def i_bfind_type(self):
            return self.getTypedRuleContext(PtxParser.I_bfind_typeContext,0)


        def i_bfind_opr(self):
            return self.getTypedRuleContext(PtxParser.I_bfind_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bfind

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bfind" ):
                listener.enterI_bfind(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bfind" ):
                listener.exitI_bfind(self)




    def i_bfind(self):

        localctx = PtxParser.I_bfindContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_i_bfind)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1580
            self.match(PtxParser.KI_BFIND)
            self.state = 1581
            self.i_bfind_type()
            self.state = 1582
            self.i_bfind_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bfind_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_SHIFTAMT(self):
            return self.getToken(PtxParser.K_SHIFTAMT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_bfind_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bfind_type" ):
                listener.enterI_bfind_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bfind_type" ):
                listener.exitI_bfind_type(self)




    def i_bfind_type(self):

        localctx = PtxParser.I_bfind_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_i_bfind_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1585
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_SHIFTAMT:
                self.state = 1584
                self.match(PtxParser.K_SHIFTAMT)


            self.state = 1587
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bfind_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constantContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bfind_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bfind_opr" ):
                listener.enterI_bfind_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bfind_opr" ):
                listener.exitI_bfind_opr(self)




    def i_bfind_opr(self):

        localctx = PtxParser.I_bfind_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_i_bfind_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1589
            self.opr_register()
            self.state = 1590
            self.match(PtxParser.T_COMMA)
            self.state = 1591
            self.opr_register_or_constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_braContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_BRA(self):
            return self.getToken(PtxParser.KI_BRA, 0)

        def i_bra_type(self):
            return self.getTypedRuleContext(PtxParser.I_bra_typeContext,0)


        def i_bra_opr(self):
            return self.getTypedRuleContext(PtxParser.I_bra_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_bra

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bra" ):
                listener.enterI_bra(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bra" ):
                listener.exitI_bra(self)




    def i_bra(self):

        localctx = PtxParser.I_braContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_i_bra)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1593
            self.match(PtxParser.KI_BRA)
            self.state = 1594
            self.i_bra_type()
            self.state = 1595
            self.i_bra_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bra_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_UNI(self):
            return self.getToken(PtxParser.K_UNI, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_bra_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bra_type" ):
                listener.enterI_bra_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bra_type" ):
                listener.exitI_bra_type(self)




    def i_bra_type(self):

        localctx = PtxParser.I_bra_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_i_bra_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1598
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_UNI:
                self.state = 1597
                self.match(PtxParser.K_UNI)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_bra_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_label(self):
            return self.getTypedRuleContext(PtxParser.Opr_labelContext,0)


        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_bra_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_bra_opr" ):
                listener.enterI_bra_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_bra_opr" ):
                listener.exitI_bra_opr(self)




    def i_bra_opr(self):

        localctx = PtxParser.I_bra_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_i_bra_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1605
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
            if la_ == 1:
                self.state = 1600
                self.opr_label()
                pass

            elif la_ == 2:
                self.state = 1601
                self.opr_register()
                self.state = 1602
                self.match(PtxParser.T_COMMA)
                self.state = 1603
                self.opr_label()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_brevContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_BREV(self):
            return self.getToken(PtxParser.KI_BREV, 0)

        def i_brev_type(self):
            return self.getTypedRuleContext(PtxParser.I_brev_typeContext,0)


        def i_brev_opr(self):
            return self.getTypedRuleContext(PtxParser.I_brev_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_brev

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_brev" ):
                listener.enterI_brev(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_brev" ):
                listener.exitI_brev(self)




    def i_brev(self):

        localctx = PtxParser.I_brevContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_i_brev)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1607
            self.match(PtxParser.KI_BREV)
            self.state = 1608
            self.i_brev_type()
            self.state = 1609
            self.i_brev_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_brev_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_brev_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_brev_type" ):
                listener.enterI_brev_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_brev_type" ):
                listener.exitI_brev_type(self)




    def i_brev_type(self):

        localctx = PtxParser.I_brev_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_i_brev_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1611
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_B64 or _la==PtxParser.K_B32):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_brev_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constantContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_brev_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_brev_opr" ):
                listener.enterI_brev_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_brev_opr" ):
                listener.exitI_brev_opr(self)




    def i_brev_opr(self):

        localctx = PtxParser.I_brev_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_i_brev_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1613
            self.opr_register()
            self.state = 1614
            self.match(PtxParser.T_COMMA)
            self.state = 1615
            self.opr_register_or_constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_brkptContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_BRKPT(self):
            return self.getToken(PtxParser.KI_BRKPT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_brkpt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_brkpt" ):
                listener.enterI_brkpt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_brkpt" ):
                listener.exitI_brkpt(self)




    def i_brkpt(self):

        localctx = PtxParser.I_brkptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_i_brkpt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1617
            self.match(PtxParser.KI_BRKPT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_callContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_CALL(self):
            return self.getToken(PtxParser.KI_CALL, 0)

        def i_call_type(self):
            return self.getTypedRuleContext(PtxParser.I_call_typeContext,0)


        def func_name(self):
            return self.getTypedRuleContext(PtxParser.Func_nameContext,0)


        def T_OP(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_OP)
            else:
                return self.getToken(PtxParser.T_OP, i)

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_CP(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_CP)
            else:
                return self.getToken(PtxParser.T_CP, i)

        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def flist(self):
            return self.getTypedRuleContext(PtxParser.FlistContext,0)


        def fproto(self):
            return self.getTypedRuleContext(PtxParser.FprotoContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_call

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_call" ):
                listener.enterI_call(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_call" ):
                listener.exitI_call(self)




    def i_call(self):

        localctx = PtxParser.I_callContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_i_call)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1619
            self.match(PtxParser.KI_CALL)
            self.state = 1620
            self.i_call_type()
            self.state = 1633
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_OP:
                self.state = 1621
                self.match(PtxParser.T_OP)
                self.state = 1622
                self.opr()
                self.state = 1627
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==PtxParser.T_COMMA:
                    self.state = 1623
                    self.match(PtxParser.T_COMMA)
                    self.state = 1624
                    self.opr()
                    self.state = 1629
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1630
                self.match(PtxParser.T_CP)
                self.state = 1631
                self.match(PtxParser.T_COMMA)


            self.state = 1635
            self.func_name()
            self.state = 1648
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                self.state = 1636
                self.match(PtxParser.T_COMMA)
                self.state = 1637
                self.match(PtxParser.T_OP)
                self.state = 1638
                self.opr()
                self.state = 1643
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==PtxParser.T_COMMA:
                    self.state = 1639
                    self.match(PtxParser.T_COMMA)
                    self.state = 1640
                    self.opr()
                    self.state = 1645
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1646
                self.match(PtxParser.T_CP)


            self.state = 1654
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
            if la_ == 1:
                self.state = 1650
                self.match(PtxParser.T_COMMA)
                self.state = 1651
                self.flist()

            elif la_ == 2:
                self.state = 1652
                self.match(PtxParser.T_COMMA)
                self.state = 1653
                self.fproto()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_call_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_UNI(self):
            return self.getToken(PtxParser.K_UNI, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_call_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_call_type" ):
                listener.enterI_call_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_call_type" ):
                listener.exitI_call_type(self)




    def i_call_type(self):

        localctx = PtxParser.I_call_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_i_call_type)
        try:
            self.state = 1658
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_UNI]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1656
                self.match(PtxParser.K_UNI)
                pass
            elif token in [PtxParser.T_OP, PtxParser.T_WORD]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FlistContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_WORD(self):
            return self.getToken(PtxParser.T_WORD, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_flist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFlist" ):
                listener.enterFlist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFlist" ):
                listener.exitFlist(self)




    def flist(self):

        localctx = PtxParser.FlistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_flist)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1660
            self.match(PtxParser.T_WORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FprotoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_WORD(self):
            return self.getToken(PtxParser.T_WORD, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_fproto

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFproto" ):
                listener.enterFproto(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFproto" ):
                listener.exitFproto(self)




    def fproto(self):

        localctx = PtxParser.FprotoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_fproto)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1662
            self.match(PtxParser.T_WORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_clzContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_CLZ(self):
            return self.getToken(PtxParser.KI_CLZ, 0)

        def i_clz_type(self):
            return self.getTypedRuleContext(PtxParser.I_clz_typeContext,0)


        def i_clz_opr(self):
            return self.getTypedRuleContext(PtxParser.I_clz_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_clz

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_clz" ):
                listener.enterI_clz(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_clz" ):
                listener.exitI_clz(self)




    def i_clz(self):

        localctx = PtxParser.I_clzContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_i_clz)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1664
            self.match(PtxParser.KI_CLZ)
            self.state = 1665
            self.i_clz_type()
            self.state = 1666
            self.i_clz_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_clz_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_clz_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_clz_type" ):
                listener.enterI_clz_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_clz_type" ):
                listener.exitI_clz_type(self)




    def i_clz_type(self):

        localctx = PtxParser.I_clz_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_i_clz_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1668
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_B64 or _la==PtxParser.K_B32):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_clz_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constantContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_clz_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_clz_opr" ):
                listener.enterI_clz_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_clz_opr" ):
                listener.exitI_clz_opr(self)




    def i_clz_opr(self):

        localctx = PtxParser.I_clz_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_i_clz_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1670
            self.opr_register()
            self.state = 1671
            self.match(PtxParser.T_COMMA)
            self.state = 1672
            self.opr_register_or_constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cnotContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_CNOT(self):
            return self.getToken(PtxParser.KI_CNOT, 0)

        def i_cnot_type(self):
            return self.getTypedRuleContext(PtxParser.I_cnot_typeContext,0)


        def i_cnot_opr(self):
            return self.getTypedRuleContext(PtxParser.I_cnot_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_cnot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cnot" ):
                listener.enterI_cnot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cnot" ):
                listener.exitI_cnot(self)




    def i_cnot(self):

        localctx = PtxParser.I_cnotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_i_cnot)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1674
            self.match(PtxParser.KI_CNOT)
            self.state = 1675
            self.i_cnot_type()
            self.state = 1676
            self.i_cnot_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cnot_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_cnot_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cnot_type" ):
                listener.enterI_cnot_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cnot_type" ):
                listener.exitI_cnot_type(self)




    def i_cnot_type(self):

        localctx = PtxParser.I_cnot_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_i_cnot_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1678
            _la = self._input.LA(1)
            if not(((((_la - 261)) & ~0x3f) == 0 and ((1 << (_la - 261)) & ((1 << (PtxParser.K_B64 - 261)) | (1 << (PtxParser.K_B32 - 261)) | (1 << (PtxParser.K_B16 - 261)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cnot_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_cnot_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cnot_opr" ):
                listener.enterI_cnot_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cnot_opr" ):
                listener.exitI_cnot_opr(self)




    def i_cnot_opr(self):

        localctx = PtxParser.I_cnot_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_i_cnot_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1680
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_copysignContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_COPYSIGN(self):
            return self.getToken(PtxParser.KI_COPYSIGN, 0)

        def i_copysign_type(self):
            return self.getTypedRuleContext(PtxParser.I_copysign_typeContext,0)


        def i_copysign_opr(self):
            return self.getTypedRuleContext(PtxParser.I_copysign_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_copysign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_copysign" ):
                listener.enterI_copysign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_copysign" ):
                listener.exitI_copysign(self)




    def i_copysign(self):

        localctx = PtxParser.I_copysignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_i_copysign)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1682
            self.match(PtxParser.KI_COPYSIGN)
            self.state = 1683
            self.i_copysign_type()
            self.state = 1684
            self.i_copysign_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_copysign_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_copysign_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_copysign_type" ):
                listener.enterI_copysign_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_copysign_type" ):
                listener.exitI_copysign_type(self)




    def i_copysign_type(self):

        localctx = PtxParser.I_copysign_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_i_copysign_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1686
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_F64 or _la==PtxParser.K_F32):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_copysign_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Opr_registerContext)
            else:
                return self.getTypedRuleContext(PtxParser.Opr_registerContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_i_copysign_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_copysign_opr" ):
                listener.enterI_copysign_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_copysign_opr" ):
                listener.exitI_copysign_opr(self)




    def i_copysign_opr(self):

        localctx = PtxParser.I_copysign_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_i_copysign_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1688
            self.opr_register()
            self.state = 1689
            self.match(PtxParser.T_COMMA)
            self.state = 1690
            self.opr_register()
            self.state = 1691
            self.match(PtxParser.T_COMMA)
            self.state = 1692
            self.opr_register()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cosContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_COS(self):
            return self.getToken(PtxParser.KI_COS, 0)

        def i_cos_type(self):
            return self.getTypedRuleContext(PtxParser.I_cos_typeContext,0)


        def i_cos_opr(self):
            return self.getTypedRuleContext(PtxParser.I_cos_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_cos

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cos" ):
                listener.enterI_cos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cos" ):
                listener.exitI_cos(self)




    def i_cos(self):

        localctx = PtxParser.I_cosContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_i_cos)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1694
            self.match(PtxParser.KI_COS)
            self.state = 1695
            self.i_cos_type()
            self.state = 1696
            self.i_cos_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cos_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_APPROX(self):
            return self.getToken(PtxParser.K_APPROX, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_cos_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cos_type" ):
                listener.enterI_cos_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cos_type" ):
                listener.exitI_cos_type(self)




    def i_cos_type(self):

        localctx = PtxParser.I_cos_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_i_cos_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1698
            self.match(PtxParser.K_APPROX)
            self.state = 1700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_FTZ:
                self.state = 1699
                self.match(PtxParser.K_FTZ)


            self.state = 1702
            self.match(PtxParser.K_F32)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cos_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_cos_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cos_opr" ):
                listener.enterI_cos_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cos_opr" ):
                listener.exitI_cos_opr(self)




    def i_cos_opr(self):

        localctx = PtxParser.I_cos_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_i_cos_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1704
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cvtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_CVT(self):
            return self.getToken(PtxParser.KI_CVT, 0)

        def i_cvt_type(self):
            return self.getTypedRuleContext(PtxParser.I_cvt_typeContext,0)


        def i_cvt_opr(self):
            return self.getTypedRuleContext(PtxParser.I_cvt_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_cvt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cvt" ):
                listener.enterI_cvt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cvt" ):
                listener.exitI_cvt(self)




    def i_cvt(self):

        localctx = PtxParser.I_cvtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_i_cvt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1706
            self.match(PtxParser.KI_CVT)
            self.state = 1707
            self.i_cvt_type()
            self.state = 1708
            self.i_cvt_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cvt_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_U8(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_U8)
            else:
                return self.getToken(PtxParser.K_U8, i)

        def K_U16(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_U16)
            else:
                return self.getToken(PtxParser.K_U16, i)

        def K_U32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_U32)
            else:
                return self.getToken(PtxParser.K_U32, i)

        def K_U64(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_U64)
            else:
                return self.getToken(PtxParser.K_U64, i)

        def K_S8(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_S8)
            else:
                return self.getToken(PtxParser.K_S8, i)

        def K_S16(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_S16)
            else:
                return self.getToken(PtxParser.K_S16, i)

        def K_S32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_S32)
            else:
                return self.getToken(PtxParser.K_S32, i)

        def K_S64(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_S64)
            else:
                return self.getToken(PtxParser.K_S64, i)

        def K_F16(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_F16)
            else:
                return self.getToken(PtxParser.K_F16, i)

        def K_F32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_F32)
            else:
                return self.getToken(PtxParser.K_F32, i)

        def K_F64(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_F64)
            else:
                return self.getToken(PtxParser.K_F64, i)

        def i_cvt_irnd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.I_cvt_irndContext)
            else:
                return self.getTypedRuleContext(PtxParser.I_cvt_irndContext,i)


        def i_cvt_frnd(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.I_cvt_frndContext)
            else:
                return self.getTypedRuleContext(PtxParser.I_cvt_frndContext,i)


        def K_FTZ(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_FTZ)
            else:
                return self.getToken(PtxParser.K_FTZ, i)

        def K_SAT(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_SAT)
            else:
                return self.getToken(PtxParser.K_SAT, i)

        def getRuleIndex(self):
            return PtxParser.RULE_i_cvt_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cvt_type" ):
                listener.enterI_cvt_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cvt_type" ):
                listener.exitI_cvt_type(self)




    def i_cvt_type(self):

        localctx = PtxParser.I_cvt_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_i_cvt_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1712
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,112,self._ctx)
            if la_ == 1:
                self.state = 1710
                self.i_cvt_irnd()
                pass

            elif la_ == 2:
                self.state = 1711
                self.i_cvt_frnd()
                pass


            self.state = 1715
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_FTZ:
                self.state = 1714
                self.match(PtxParser.K_FTZ)


            self.state = 1718
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_SAT:
                self.state = 1717
                self.match(PtxParser.K_SAT)


            self.state = 1720
            _la = self._input.LA(1)
            if not(((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_F16 - 230)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1721
            _la = self._input.LA(1)
            if not(((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_F16 - 230)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1724
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
            if la_ == 1:
                self.state = 1722
                self.i_cvt_irnd()
                pass

            elif la_ == 2:
                self.state = 1723
                self.i_cvt_frnd()
                pass


            self.state = 1727
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_FTZ:
                self.state = 1726
                self.match(PtxParser.K_FTZ)


            self.state = 1730
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_SAT:
                self.state = 1729
                self.match(PtxParser.K_SAT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cvt_irndContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def i_cvt_irnd_aux(self):
            return self.getTypedRuleContext(PtxParser.I_cvt_irnd_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_cvt_irnd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cvt_irnd" ):
                listener.enterI_cvt_irnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cvt_irnd" ):
                listener.exitI_cvt_irnd(self)




    def i_cvt_irnd(self):

        localctx = PtxParser.I_cvt_irndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_i_cvt_irnd)
        try:
            self.state = 1734
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_RZI, PtxParser.K_RPI, PtxParser.K_RNI, PtxParser.K_RMI]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1732
                self.i_cvt_irnd_aux()
                pass
            elif token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR, PtxParser.T_TILDE, PtxParser.T_FLT_LITERAL, PtxParser.T_HEX_LITERAL, PtxParser.T_OCT_LITERAL, PtxParser.T_DEC_LITERAL, PtxParser.T_PLUS, PtxParser.T_OP, PtxParser.T_OC, PtxParser.T_NOT, PtxParser.T_MINUS, PtxParser.K_U8, PtxParser.K_U64, PtxParser.K_U32, PtxParser.K_U16, PtxParser.K_SAT, PtxParser.K_S8, PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16, PtxParser.K_FTZ, PtxParser.K_F64, PtxParser.K_F32, PtxParser.K_F16, PtxParser.T_WORD, PtxParser.T_UNDERSCORE]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cvt_irnd_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_RNI(self):
            return self.getToken(PtxParser.K_RNI, 0)

        def K_RZI(self):
            return self.getToken(PtxParser.K_RZI, 0)

        def K_RMI(self):
            return self.getToken(PtxParser.K_RMI, 0)

        def K_RPI(self):
            return self.getToken(PtxParser.K_RPI, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_cvt_irnd_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cvt_irnd_aux" ):
                listener.enterI_cvt_irnd_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cvt_irnd_aux" ):
                listener.exitI_cvt_irnd_aux(self)




    def i_cvt_irnd_aux(self):

        localctx = PtxParser.I_cvt_irnd_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_i_cvt_irnd_aux)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1736
            _la = self._input.LA(1)
            if not(((((_la - 163)) & ~0x3f) == 0 and ((1 << (_la - 163)) & ((1 << (PtxParser.K_RZI - 163)) | (1 << (PtxParser.K_RPI - 163)) | (1 << (PtxParser.K_RNI - 163)) | (1 << (PtxParser.K_RMI - 163)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cvt_frndContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def i_cvt_frnd_aux(self):
            return self.getTypedRuleContext(PtxParser.I_cvt_frnd_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_cvt_frnd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cvt_frnd" ):
                listener.enterI_cvt_frnd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cvt_frnd" ):
                listener.exitI_cvt_frnd(self)




    def i_cvt_frnd(self):

        localctx = PtxParser.I_cvt_frndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_i_cvt_frnd)
        try:
            self.state = 1740
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_RZ, PtxParser.K_RP, PtxParser.K_RN, PtxParser.K_RM]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1738
                self.i_cvt_frnd_aux()
                pass
            elif token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR, PtxParser.T_TILDE, PtxParser.T_FLT_LITERAL, PtxParser.T_HEX_LITERAL, PtxParser.T_OCT_LITERAL, PtxParser.T_DEC_LITERAL, PtxParser.T_PLUS, PtxParser.T_OP, PtxParser.T_OC, PtxParser.T_NOT, PtxParser.T_MINUS, PtxParser.K_U8, PtxParser.K_U64, PtxParser.K_U32, PtxParser.K_U16, PtxParser.K_SAT, PtxParser.K_S8, PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16, PtxParser.K_FTZ, PtxParser.K_F64, PtxParser.K_F32, PtxParser.K_F16, PtxParser.T_WORD, PtxParser.T_UNDERSCORE]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cvt_frnd_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_RN(self):
            return self.getToken(PtxParser.K_RN, 0)

        def K_RZ(self):
            return self.getToken(PtxParser.K_RZ, 0)

        def K_RM(self):
            return self.getToken(PtxParser.K_RM, 0)

        def K_RP(self):
            return self.getToken(PtxParser.K_RP, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_cvt_frnd_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cvt_frnd_aux" ):
                listener.enterI_cvt_frnd_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cvt_frnd_aux" ):
                listener.exitI_cvt_frnd_aux(self)




    def i_cvt_frnd_aux(self):

        localctx = PtxParser.I_cvt_frnd_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_i_cvt_frnd_aux)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1742
            _la = self._input.LA(1)
            if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cvt_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_cvt_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cvt_opr" ):
                listener.enterI_cvt_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cvt_opr" ):
                listener.exitI_cvt_opr(self)




    def i_cvt_opr(self):

        localctx = PtxParser.I_cvt_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_i_cvt_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1744
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cvtaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_CVTA(self):
            return self.getToken(PtxParser.KI_CVTA, 0)

        def i_cvta_opr(self):
            return self.getTypedRuleContext(PtxParser.I_cvta_oprContext,0)


        def i_cvta_type(self):
            return self.getTypedRuleContext(PtxParser.I_cvta_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_cvta

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cvta" ):
                listener.enterI_cvta(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cvta" ):
                listener.exitI_cvta(self)




    def i_cvta(self):

        localctx = PtxParser.I_cvtaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_i_cvta)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1746
            self.match(PtxParser.KI_CVTA)

            self.state = 1747
            self.i_cvta_type()
            self.state = 1748
            self.i_cvta_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cvta_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_GLOBAL(self):
            return self.getToken(PtxParser.K_GLOBAL, 0)

        def K_LOCAL(self):
            return self.getToken(PtxParser.K_LOCAL, 0)

        def K_SHARED(self):
            return self.getToken(PtxParser.K_SHARED, 0)

        def K_CONST(self):
            return self.getToken(PtxParser.K_CONST, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_TO(self):
            return self.getToken(PtxParser.K_TO, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_cvta_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cvta_type" ):
                listener.enterI_cvta_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cvta_type" ):
                listener.exitI_cvta_type(self)




    def i_cvta_type(self):

        localctx = PtxParser.I_cvta_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_i_cvta_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1751
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_TO:
                self.state = 1750
                self.match(PtxParser.K_TO)


            self.state = 1753
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_SHARED or _la==PtxParser.K_LOCAL or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1754
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_U64 or _la==PtxParser.K_U32):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_cvta_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def T_PLUS(self):
            return self.getToken(PtxParser.T_PLUS, 0)

        def integer(self):
            return self.getTypedRuleContext(PtxParser.IntegerContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_cvta_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_cvta_opr" ):
                listener.enterI_cvta_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_cvta_opr" ):
                listener.exitI_cvta_opr(self)




    def i_cvta_opr(self):

        localctx = PtxParser.I_cvta_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_i_cvta_opr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1756
            self.opr()
            self.state = 1757
            self.match(PtxParser.T_COMMA)
            self.state = 1758
            self.opr()
            self.state = 1761
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_PLUS:
                self.state = 1759
                self.match(PtxParser.T_PLUS)
                self.state = 1760
                self.integer()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_divContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_DIV(self):
            return self.getToken(PtxParser.KI_DIV, 0)

        def i_div_opr(self):
            return self.getTypedRuleContext(PtxParser.I_div_oprContext,0)


        def i_div_type(self):
            return self.getTypedRuleContext(PtxParser.I_div_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_div

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_div" ):
                listener.enterI_div(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_div" ):
                listener.exitI_div(self)




    def i_div(self):

        localctx = PtxParser.I_divContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_i_div)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1763
            self.match(PtxParser.KI_DIV)

            self.state = 1764
            self.i_div_type()
            self.state = 1765
            self.i_div_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_div_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_APPROX(self):
            return self.getToken(PtxParser.K_APPROX, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_FULL(self):
            return self.getToken(PtxParser.K_FULL, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_RN(self):
            return self.getToken(PtxParser.K_RN, 0)

        def K_RZ(self):
            return self.getToken(PtxParser.K_RZ, 0)

        def K_RM(self):
            return self.getToken(PtxParser.K_RM, 0)

        def K_RP(self):
            return self.getToken(PtxParser.K_RP, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_div_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_div_type" ):
                listener.enterI_div_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_div_type" ):
                listener.exitI_div_type(self)




    def i_div_type(self):

        localctx = PtxParser.I_div_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_i_div_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1785
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,125,self._ctx)
            if la_ == 1:
                self.state = 1767
                _la = self._input.LA(1)
                if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.state = 1768
                self.match(PtxParser.K_APPROX)
                self.state = 1770
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 1769
                    self.match(PtxParser.K_FTZ)


                self.state = 1772
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 3:
                self.state = 1773
                self.match(PtxParser.K_FULL)
                self.state = 1775
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 1774
                    self.match(PtxParser.K_FTZ)


                self.state = 1777
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 4:
                self.state = 1778
                _la = self._input.LA(1)
                if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1780
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 1779
                    self.match(PtxParser.K_FTZ)


                self.state = 1782
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 5:
                self.state = 1783
                _la = self._input.LA(1)
                if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1784
                self.match(PtxParser.K_F64)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_div_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant2(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_div_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_div_opr" ):
                listener.enterI_div_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_div_opr" ):
                listener.exitI_div_opr(self)




    def i_div_opr(self):

        localctx = PtxParser.I_div_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_i_div_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1787
            self.opr_register()
            self.state = 1788
            self.match(PtxParser.T_COMMA)
            self.state = 1789
            self.opr_register_or_constant2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_ex2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_EX2(self):
            return self.getToken(PtxParser.KI_EX2, 0)

        def i_ex2_type(self):
            return self.getTypedRuleContext(PtxParser.I_ex2_typeContext,0)


        def i_ex2_opr(self):
            return self.getTypedRuleContext(PtxParser.I_ex2_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_ex2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_ex2" ):
                listener.enterI_ex2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_ex2" ):
                listener.exitI_ex2(self)




    def i_ex2(self):

        localctx = PtxParser.I_ex2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 342, self.RULE_i_ex2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1791
            self.match(PtxParser.KI_EX2)
            self.state = 1792
            self.i_ex2_type()
            self.state = 1793
            self.i_ex2_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_ex2_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_APPROX(self):
            return self.getToken(PtxParser.K_APPROX, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_ex2_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_ex2_type" ):
                listener.enterI_ex2_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_ex2_type" ):
                listener.exitI_ex2_type(self)




    def i_ex2_type(self):

        localctx = PtxParser.I_ex2_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 344, self.RULE_i_ex2_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1795
            self.match(PtxParser.K_APPROX)
            self.state = 1797
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_FTZ:
                self.state = 1796
                self.match(PtxParser.K_FTZ)


            self.state = 1799
            self.match(PtxParser.K_F32)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_ex2_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_ex2_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_ex2_opr" ):
                listener.enterI_ex2_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_ex2_opr" ):
                listener.exitI_ex2_opr(self)




    def i_ex2_opr(self):

        localctx = PtxParser.I_ex2_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 346, self.RULE_i_ex2_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1801
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_exitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_EXIT(self):
            return self.getToken(PtxParser.KI_EXIT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_exit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_exit" ):
                listener.enterI_exit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_exit" ):
                listener.exitI_exit(self)




    def i_exit(self):

        localctx = PtxParser.I_exitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 348, self.RULE_i_exit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1803
            self.match(PtxParser.KI_EXIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_fmaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_FMA(self):
            return self.getToken(PtxParser.KI_FMA, 0)

        def i_fma_type(self):
            return self.getTypedRuleContext(PtxParser.I_fma_typeContext,0)


        def i_fma_opr(self):
            return self.getTypedRuleContext(PtxParser.I_fma_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_fma

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_fma" ):
                listener.enterI_fma(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_fma" ):
                listener.exitI_fma(self)




    def i_fma(self):

        localctx = PtxParser.I_fmaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 350, self.RULE_i_fma)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1805
            self.match(PtxParser.KI_FMA)
            self.state = 1806
            self.i_fma_type()
            self.state = 1807
            self.i_fma_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_fma_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_RN(self):
            return self.getToken(PtxParser.K_RN, 0)

        def K_RZ(self):
            return self.getToken(PtxParser.K_RZ, 0)

        def K_RM(self):
            return self.getToken(PtxParser.K_RM, 0)

        def K_RP(self):
            return self.getToken(PtxParser.K_RP, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def K_SAT(self):
            return self.getToken(PtxParser.K_SAT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_fma_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_fma_type" ):
                listener.enterI_fma_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_fma_type" ):
                listener.exitI_fma_type(self)




    def i_fma_type(self):

        localctx = PtxParser.I_fma_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 352, self.RULE_i_fma_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1809
            _la = self._input.LA(1)
            if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1818
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_SAT, PtxParser.K_FTZ, PtxParser.K_F32]:
                self.state = 1811
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 1810
                    self.match(PtxParser.K_FTZ)


                self.state = 1814
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_SAT:
                    self.state = 1813
                    self.match(PtxParser.K_SAT)


                self.state = 1816
                self.match(PtxParser.K_F32)
                pass
            elif token in [PtxParser.K_F64]:
                self.state = 1817
                self.match(PtxParser.K_F64)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_fma_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr4(self):
            return self.getTypedRuleContext(PtxParser.Opr4Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_fma_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_fma_opr" ):
                listener.enterI_fma_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_fma_opr" ):
                listener.exitI_fma_opr(self)




    def i_fma_opr(self):

        localctx = PtxParser.I_fma_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 354, self.RULE_i_fma_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1820
            self.opr4()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_isspacepContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_ISSPACEP(self):
            return self.getToken(PtxParser.KI_ISSPACEP, 0)

        def i_isspacep_type(self):
            return self.getTypedRuleContext(PtxParser.I_isspacep_typeContext,0)


        def i_isspacep_opr(self):
            return self.getTypedRuleContext(PtxParser.I_isspacep_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_isspacep

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_isspacep" ):
                listener.enterI_isspacep(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_isspacep" ):
                listener.exitI_isspacep(self)




    def i_isspacep(self):

        localctx = PtxParser.I_isspacepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 356, self.RULE_i_isspacep)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1822
            self.match(PtxParser.KI_ISSPACEP)
            self.state = 1823
            self.i_isspacep_type()
            self.state = 1824
            self.i_isspacep_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_isspacep_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_GLOBAL(self):
            return self.getToken(PtxParser.K_GLOBAL, 0)

        def K_LOCAL(self):
            return self.getToken(PtxParser.K_LOCAL, 0)

        def K_SHARED(self):
            return self.getToken(PtxParser.K_SHARED, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_isspacep_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_isspacep_type" ):
                listener.enterI_isspacep_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_isspacep_type" ):
                listener.exitI_isspacep_type(self)




    def i_isspacep_type(self):

        localctx = PtxParser.I_isspacep_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 358, self.RULE_i_isspacep_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1826
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_SHARED or _la==PtxParser.K_LOCAL or _la==PtxParser.K_GLOBAL):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_isspacep_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_isspacep_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_isspacep_opr" ):
                listener.enterI_isspacep_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_isspacep_opr" ):
                listener.exitI_isspacep_opr(self)




    def i_isspacep_opr(self):

        localctx = PtxParser.I_isspacep_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 360, self.RULE_i_isspacep_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1828
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_ldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_LD(self):
            return self.getToken(PtxParser.KI_LD, 0)

        def i_ld_type(self):
            return self.getTypedRuleContext(PtxParser.I_ld_typeContext,0)


        def i_ld_opr(self):
            return self.getTypedRuleContext(PtxParser.I_ld_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_ld

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_ld" ):
                listener.enterI_ld(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_ld" ):
                listener.exitI_ld(self)




    def i_ld(self):

        localctx = PtxParser.I_ldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 362, self.RULE_i_ld)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1830
            self.match(PtxParser.KI_LD)
            self.state = 1831
            self.i_ld_type()
            self.state = 1832
            self.i_ld_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_ld_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_VOLATILE(self):
            return self.getToken(PtxParser.K_VOLATILE, 0)

        def K_B8(self):
            return self.getToken(PtxParser.K_B8, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U8(self):
            return self.getToken(PtxParser.K_U8, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S8(self):
            return self.getToken(PtxParser.K_S8, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_V2(self):
            return self.getToken(PtxParser.K_V2, 0)

        def K_V4(self):
            return self.getToken(PtxParser.K_V4, 0)

        def K_CONST(self):
            return self.getToken(PtxParser.K_CONST, 0)

        def K_GLOBAL(self):
            return self.getToken(PtxParser.K_GLOBAL, 0)

        def K_LOCAL(self):
            return self.getToken(PtxParser.K_LOCAL, 0)

        def K_PARAM(self):
            return self.getToken(PtxParser.K_PARAM, 0)

        def K_SHARED(self):
            return self.getToken(PtxParser.K_SHARED, 0)

        def K_CA(self):
            return self.getToken(PtxParser.K_CA, 0)

        def K_CG(self):
            return self.getToken(PtxParser.K_CG, 0)

        def K_CS(self):
            return self.getToken(PtxParser.K_CS, 0)

        def K_LU(self):
            return self.getToken(PtxParser.K_LU, 0)

        def K_CV(self):
            return self.getToken(PtxParser.K_CV, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_ld_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_ld_type" ):
                listener.enterI_ld_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_ld_type" ):
                listener.exitI_ld_type(self)




    def i_ld_type(self):

        localctx = PtxParser.I_ld_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 364, self.RULE_i_ld_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1860
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,136,self._ctx)
            if la_ == 1:
                self.state = 1835
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST:
                    self.state = 1834
                    _la = self._input.LA(1)
                    if not(((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1838
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & ((1 << (PtxParser.K_LU - 201)) | (1 << (PtxParser.K_CV - 201)) | (1 << (PtxParser.K_CS - 201)) | (1 << (PtxParser.K_CG - 201)) | (1 << (PtxParser.K_CA - 201)))) != 0):
                    self.state = 1837
                    _la = self._input.LA(1)
                    if not(((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & ((1 << (PtxParser.K_LU - 201)) | (1 << (PtxParser.K_CV - 201)) | (1 << (PtxParser.K_CS - 201)) | (1 << (PtxParser.K_CG - 201)) | (1 << (PtxParser.K_CA - 201)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1840
                _la = self._input.LA(1)
                if not(((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B8 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.state = 1842
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST:
                    self.state = 1841
                    _la = self._input.LA(1)
                    if not(((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1845
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & ((1 << (PtxParser.K_LU - 201)) | (1 << (PtxParser.K_CV - 201)) | (1 << (PtxParser.K_CS - 201)) | (1 << (PtxParser.K_CG - 201)) | (1 << (PtxParser.K_CA - 201)))) != 0):
                    self.state = 1844
                    _la = self._input.LA(1)
                    if not(((((_la - 201)) & ~0x3f) == 0 and ((1 << (_la - 201)) & ((1 << (PtxParser.K_LU - 201)) | (1 << (PtxParser.K_CV - 201)) | (1 << (PtxParser.K_CS - 201)) | (1 << (PtxParser.K_CG - 201)) | (1 << (PtxParser.K_CA - 201)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1847
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_V4 or _la==PtxParser.K_V2):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1848
                _la = self._input.LA(1)
                if not(((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B8 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 3:
                self.state = 1849
                self.match(PtxParser.K_VOLATILE)
                self.state = 1851
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST:
                    self.state = 1850
                    _la = self._input.LA(1)
                    if not(((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1853
                _la = self._input.LA(1)
                if not(((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B8 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 4:
                self.state = 1854
                self.match(PtxParser.K_VOLATILE)
                self.state = 1856
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST:
                    self.state = 1855
                    _la = self._input.LA(1)
                    if not(((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1858
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_V4 or _la==PtxParser.K_V2):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1859
                _la = self._input.LA(1)
                if not(((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B8 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_ld_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_ld_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_ld_opr" ):
                listener.enterI_ld_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_ld_opr" ):
                listener.exitI_ld_opr(self)




    def i_ld_opr(self):

        localctx = PtxParser.I_ld_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 366, self.RULE_i_ld_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1862
            self.opr()
            self.state = 1863
            self.match(PtxParser.T_COMMA)
            self.state = 1864
            self.match(PtxParser.T_OB)
            self.state = 1865
            self.opr()
            self.state = 1866
            self.match(PtxParser.T_CB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_lduContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_LDU(self):
            return self.getToken(PtxParser.KI_LDU, 0)

        def i_ldu_type(self):
            return self.getTypedRuleContext(PtxParser.I_ldu_typeContext,0)


        def i_ldu_opr(self):
            return self.getTypedRuleContext(PtxParser.I_ldu_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_ldu

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_ldu" ):
                listener.enterI_ldu(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_ldu" ):
                listener.exitI_ldu(self)




    def i_ldu(self):

        localctx = PtxParser.I_lduContext(self, self._ctx, self.state)
        self.enterRule(localctx, 368, self.RULE_i_ldu)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1868
            self.match(PtxParser.KI_LDU)
            self.state = 1869
            self.i_ldu_type()
            self.state = 1870
            self.i_ldu_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_ldu_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B8(self):
            return self.getToken(PtxParser.K_B8, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U8(self):
            return self.getToken(PtxParser.K_U8, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S8(self):
            return self.getToken(PtxParser.K_S8, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_V2(self):
            return self.getToken(PtxParser.K_V2, 0)

        def K_V4(self):
            return self.getToken(PtxParser.K_V4, 0)

        def K_GLOBAL(self):
            return self.getToken(PtxParser.K_GLOBAL, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_ldu_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_ldu_type" ):
                listener.enterI_ldu_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_ldu_type" ):
                listener.exitI_ldu_type(self)




    def i_ldu_type(self):

        localctx = PtxParser.I_ldu_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 370, self.RULE_i_ldu_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1881
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,139,self._ctx)
            if la_ == 1:
                self.state = 1873
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_GLOBAL:
                    self.state = 1872
                    self.match(PtxParser.K_GLOBAL)


                self.state = 1875
                _la = self._input.LA(1)
                if not(((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B8 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.state = 1877
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_GLOBAL:
                    self.state = 1876
                    self.match(PtxParser.K_GLOBAL)


                self.state = 1879
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_V4 or _la==PtxParser.K_V2):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1880
                _la = self._input.LA(1)
                if not(((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B8 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_ldu_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_ldu_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_ldu_opr" ):
                listener.enterI_ldu_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_ldu_opr" ):
                listener.exitI_ldu_opr(self)




    def i_ldu_opr(self):

        localctx = PtxParser.I_ldu_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 372, self.RULE_i_ldu_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1883
            self.opr()
            self.state = 1884
            self.match(PtxParser.T_COMMA)
            self.state = 1885
            self.match(PtxParser.T_OB)
            self.state = 1886
            self.opr()
            self.state = 1887
            self.match(PtxParser.T_CB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_lg2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_LG2(self):
            return self.getToken(PtxParser.KI_LG2, 0)

        def i_lg2_type(self):
            return self.getTypedRuleContext(PtxParser.I_lg2_typeContext,0)


        def i_lg2_opr(self):
            return self.getTypedRuleContext(PtxParser.I_lg2_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_lg2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_lg2" ):
                listener.enterI_lg2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_lg2" ):
                listener.exitI_lg2(self)




    def i_lg2(self):

        localctx = PtxParser.I_lg2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 374, self.RULE_i_lg2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1889
            self.match(PtxParser.KI_LG2)
            self.state = 1890
            self.i_lg2_type()
            self.state = 1891
            self.i_lg2_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_lg2_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_APPROX(self):
            return self.getToken(PtxParser.K_APPROX, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_lg2_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_lg2_type" ):
                listener.enterI_lg2_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_lg2_type" ):
                listener.exitI_lg2_type(self)




    def i_lg2_type(self):

        localctx = PtxParser.I_lg2_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 376, self.RULE_i_lg2_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1893
            self.match(PtxParser.K_APPROX)
            self.state = 1895
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_FTZ:
                self.state = 1894
                self.match(PtxParser.K_FTZ)


            self.state = 1897
            self.match(PtxParser.K_F32)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_lg2_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_lg2_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_lg2_opr" ):
                listener.enterI_lg2_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_lg2_opr" ):
                listener.exitI_lg2_opr(self)




    def i_lg2_opr(self):

        localctx = PtxParser.I_lg2_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 378, self.RULE_i_lg2_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1899
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_madContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_MAD(self):
            return self.getToken(PtxParser.KI_MAD, 0)

        def i_mad_type(self):
            return self.getTypedRuleContext(PtxParser.I_mad_typeContext,0)


        def i_mad_opr(self):
            return self.getTypedRuleContext(PtxParser.I_mad_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_mad

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mad" ):
                listener.enterI_mad(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mad" ):
                listener.exitI_mad(self)




    def i_mad(self):

        localctx = PtxParser.I_madContext(self, self._ctx, self.state)
        self.enterRule(localctx, 380, self.RULE_i_mad)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1901
            self.match(PtxParser.KI_MAD)
            self.state = 1902
            self.i_mad_type()
            self.state = 1903
            self.i_mad_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mad_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_HI(self):
            return self.getToken(PtxParser.K_HI, 0)

        def K_SAT(self):
            return self.getToken(PtxParser.K_SAT, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_LO(self):
            return self.getToken(PtxParser.K_LO, 0)

        def K_WIDE(self):
            return self.getToken(PtxParser.K_WIDE, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_RN(self):
            return self.getToken(PtxParser.K_RN, 0)

        def K_RZ(self):
            return self.getToken(PtxParser.K_RZ, 0)

        def K_RM(self):
            return self.getToken(PtxParser.K_RM, 0)

        def K_RP(self):
            return self.getToken(PtxParser.K_RP, 0)

        def K_CC(self):
            return self.getToken(PtxParser.K_CC, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_mad_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mad_type" ):
                listener.enterI_mad_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mad_type" ):
                listener.exitI_mad_type(self)




    def i_mad_type(self):

        localctx = PtxParser.I_mad_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 382, self.RULE_i_mad_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1930
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,146,self._ctx)
            if la_ == 1:
                self.state = 1905
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_WIDE or _la==PtxParser.K_LO or _la==PtxParser.K_HI):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1907
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_CC:
                    self.state = 1906
                    self.match(PtxParser.K_CC)


                self.state = 1909
                _la = self._input.LA(1)
                if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.state = 1910
                self.match(PtxParser.K_HI)
                self.state = 1911
                self.match(PtxParser.K_SAT)
                self.state = 1912
                self.match(PtxParser.K_S32)
                pass

            elif la_ == 3:
                self.state = 1914
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 1913
                    self.match(PtxParser.K_FTZ)


                self.state = 1917
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_SAT:
                    self.state = 1916
                    self.match(PtxParser.K_SAT)


                self.state = 1919
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 4:
                self.state = 1920
                _la = self._input.LA(1)
                if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1922
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 1921
                    self.match(PtxParser.K_FTZ)


                self.state = 1925
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_SAT:
                    self.state = 1924
                    self.match(PtxParser.K_SAT)


                self.state = 1927
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 5:
                self.state = 1928
                _la = self._input.LA(1)
                if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1929
                self.match(PtxParser.K_F64)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mad_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant3(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant3Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_mad_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mad_opr" ):
                listener.enterI_mad_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mad_opr" ):
                listener.exitI_mad_opr(self)




    def i_mad_opr(self):

        localctx = PtxParser.I_mad_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 384, self.RULE_i_mad_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1932
            self.opr_register()
            self.state = 1933
            self.match(PtxParser.T_COMMA)
            self.state = 1934
            self.opr_register_or_constant3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_madcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_MADC(self):
            return self.getToken(PtxParser.KI_MADC, 0)

        def i_madc_type(self):
            return self.getTypedRuleContext(PtxParser.I_madc_typeContext,0)


        def i_madc_opr(self):
            return self.getTypedRuleContext(PtxParser.I_madc_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_madc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_madc" ):
                listener.enterI_madc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_madc" ):
                listener.exitI_madc(self)




    def i_madc(self):

        localctx = PtxParser.I_madcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 386, self.RULE_i_madc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1936
            self.match(PtxParser.KI_MADC)
            self.state = 1937
            self.i_madc_type()
            self.state = 1938
            self.i_madc_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_madc_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_HI(self):
            return self.getToken(PtxParser.K_HI, 0)

        def K_SAT(self):
            return self.getToken(PtxParser.K_SAT, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_LO(self):
            return self.getToken(PtxParser.K_LO, 0)

        def K_WIDE(self):
            return self.getToken(PtxParser.K_WIDE, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_RN(self):
            return self.getToken(PtxParser.K_RN, 0)

        def K_RZ(self):
            return self.getToken(PtxParser.K_RZ, 0)

        def K_RM(self):
            return self.getToken(PtxParser.K_RM, 0)

        def K_RP(self):
            return self.getToken(PtxParser.K_RP, 0)

        def K_CC(self):
            return self.getToken(PtxParser.K_CC, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_madc_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_madc_type" ):
                listener.enterI_madc_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_madc_type" ):
                listener.exitI_madc_type(self)




    def i_madc_type(self):

        localctx = PtxParser.I_madc_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 388, self.RULE_i_madc_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1965
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,152,self._ctx)
            if la_ == 1:
                self.state = 1940
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_WIDE or _la==PtxParser.K_LO or _la==PtxParser.K_HI):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1942
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_CC:
                    self.state = 1941
                    self.match(PtxParser.K_CC)


                self.state = 1944
                _la = self._input.LA(1)
                if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.state = 1945
                self.match(PtxParser.K_HI)
                self.state = 1946
                self.match(PtxParser.K_SAT)
                self.state = 1947
                self.match(PtxParser.K_S32)
                pass

            elif la_ == 3:
                self.state = 1949
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 1948
                    self.match(PtxParser.K_FTZ)


                self.state = 1952
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_SAT:
                    self.state = 1951
                    self.match(PtxParser.K_SAT)


                self.state = 1954
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 4:
                self.state = 1955
                _la = self._input.LA(1)
                if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1957
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 1956
                    self.match(PtxParser.K_FTZ)


                self.state = 1960
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_SAT:
                    self.state = 1959
                    self.match(PtxParser.K_SAT)


                self.state = 1962
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 5:
                self.state = 1963
                _la = self._input.LA(1)
                if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1964
                self.match(PtxParser.K_F64)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_madc_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant3(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant3Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_madc_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_madc_opr" ):
                listener.enterI_madc_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_madc_opr" ):
                listener.exitI_madc_opr(self)




    def i_madc_opr(self):

        localctx = PtxParser.I_madc_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 390, self.RULE_i_madc_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1967
            self.opr_register()
            self.state = 1968
            self.match(PtxParser.T_COMMA)
            self.state = 1969
            self.opr_register_or_constant3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mad24Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_MAD24(self):
            return self.getToken(PtxParser.KI_MAD24, 0)

        def i_mad24_type(self):
            return self.getTypedRuleContext(PtxParser.I_mad24_typeContext,0)


        def i_mad24_opr(self):
            return self.getTypedRuleContext(PtxParser.I_mad24_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_mad24

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mad24" ):
                listener.enterI_mad24(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mad24" ):
                listener.exitI_mad24(self)




    def i_mad24(self):

        localctx = PtxParser.I_mad24Context(self, self._ctx, self.state)
        self.enterRule(localctx, 392, self.RULE_i_mad24)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1971
            self.match(PtxParser.KI_MAD24)
            self.state = 1972
            self.i_mad24_type()
            self.state = 1973
            self.i_mad24_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mad24_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_HI(self):
            return self.getToken(PtxParser.K_HI, 0)

        def K_SAT(self):
            return self.getToken(PtxParser.K_SAT, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_LO(self):
            return self.getToken(PtxParser.K_LO, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_mad24_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mad24_type" ):
                listener.enterI_mad24_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mad24_type" ):
                listener.exitI_mad24_type(self)




    def i_mad24_type(self):

        localctx = PtxParser.I_mad24_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 394, self.RULE_i_mad24_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1980
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,153,self._ctx)
            if la_ == 1:
                self.state = 1975
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_LO or _la==PtxParser.K_HI):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1976
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_U32 or _la==PtxParser.K_S32):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.state = 1977
                self.match(PtxParser.K_HI)
                self.state = 1978
                self.match(PtxParser.K_SAT)
                self.state = 1979
                self.match(PtxParser.K_S32)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mad24_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant3(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant3Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_mad24_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mad24_opr" ):
                listener.enterI_mad24_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mad24_opr" ):
                listener.exitI_mad24_opr(self)




    def i_mad24_opr(self):

        localctx = PtxParser.I_mad24_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 396, self.RULE_i_mad24_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1982
            self.opr_register()
            self.state = 1983
            self.match(PtxParser.T_COMMA)
            self.state = 1984
            self.opr_register_or_constant3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_maxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_MAX(self):
            return self.getToken(PtxParser.KI_MAX, 0)

        def i_max_type(self):
            return self.getTypedRuleContext(PtxParser.I_max_typeContext,0)


        def i_max_opr(self):
            return self.getTypedRuleContext(PtxParser.I_max_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_max

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_max" ):
                listener.enterI_max(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_max" ):
                listener.exitI_max(self)




    def i_max(self):

        localctx = PtxParser.I_maxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 398, self.RULE_i_max)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1986
            self.match(PtxParser.KI_MAX)
            self.state = 1987
            self.i_max_type()
            self.state = 1988
            self.i_max_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_max_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_max_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_max_type" ):
                listener.enterI_max_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_max_type" ):
                listener.exitI_max_type(self)




    def i_max_type(self):

        localctx = PtxParser.I_max_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 400, self.RULE_i_max_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1996
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_U64, PtxParser.K_U32, PtxParser.K_U16, PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16]:
                self.state = 1990
                _la = self._input.LA(1)
                if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [PtxParser.K_FTZ, PtxParser.K_F32]:
                self.state = 1992
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 1991
                    self.match(PtxParser.K_FTZ)


                self.state = 1994
                self.match(PtxParser.K_F32)
                pass
            elif token in [PtxParser.K_F64]:
                self.state = 1995
                self.match(PtxParser.K_F64)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_max_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant2(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_max_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_max_opr" ):
                listener.enterI_max_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_max_opr" ):
                listener.exitI_max_opr(self)




    def i_max_opr(self):

        localctx = PtxParser.I_max_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 402, self.RULE_i_max_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1998
            self.opr_register()
            self.state = 1999
            self.match(PtxParser.T_COMMA)
            self.state = 2000
            self.opr_register_or_constant2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_membarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_MEMBAR(self):
            return self.getToken(PtxParser.KI_MEMBAR, 0)

        def i_membar_type(self):
            return self.getTypedRuleContext(PtxParser.I_membar_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_membar

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_membar" ):
                listener.enterI_membar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_membar" ):
                listener.exitI_membar(self)




    def i_membar(self):

        localctx = PtxParser.I_membarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 404, self.RULE_i_membar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2002
            self.match(PtxParser.KI_MEMBAR)
            self.state = 2003
            self.i_membar_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_membar_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_CTA(self):
            return self.getToken(PtxParser.K_CTA, 0)

        def K_GL(self):
            return self.getToken(PtxParser.K_GL, 0)

        def K_SYS(self):
            return self.getToken(PtxParser.K_SYS, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_membar_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_membar_type" ):
                listener.enterI_membar_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_membar_type" ):
                listener.exitI_membar_type(self)




    def i_membar_type(self):

        localctx = PtxParser.I_membar_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 406, self.RULE_i_membar_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2005
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_SYS or _la==PtxParser.K_GL or _la==PtxParser.K_CTA):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_minContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_MIN(self):
            return self.getToken(PtxParser.KI_MIN, 0)

        def i_min_type(self):
            return self.getTypedRuleContext(PtxParser.I_min_typeContext,0)


        def i_min_opr(self):
            return self.getTypedRuleContext(PtxParser.I_min_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_min

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_min" ):
                listener.enterI_min(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_min" ):
                listener.exitI_min(self)




    def i_min(self):

        localctx = PtxParser.I_minContext(self, self._ctx, self.state)
        self.enterRule(localctx, 408, self.RULE_i_min)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2007
            self.match(PtxParser.KI_MIN)
            self.state = 2008
            self.i_min_type()
            self.state = 2009
            self.i_min_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_min_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_min_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_min_type" ):
                listener.enterI_min_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_min_type" ):
                listener.exitI_min_type(self)




    def i_min_type(self):

        localctx = PtxParser.I_min_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 410, self.RULE_i_min_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2017
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_U64, PtxParser.K_U32, PtxParser.K_U16, PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16]:
                self.state = 2011
                _la = self._input.LA(1)
                if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [PtxParser.K_FTZ, PtxParser.K_F32]:
                self.state = 2013
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 2012
                    self.match(PtxParser.K_FTZ)


                self.state = 2015
                self.match(PtxParser.K_F32)
                pass
            elif token in [PtxParser.K_F64]:
                self.state = 2016
                self.match(PtxParser.K_F64)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_min_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant2(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_min_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_min_opr" ):
                listener.enterI_min_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_min_opr" ):
                listener.exitI_min_opr(self)




    def i_min_opr(self):

        localctx = PtxParser.I_min_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 412, self.RULE_i_min_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2019
            self.opr_register()
            self.state = 2020
            self.match(PtxParser.T_COMMA)
            self.state = 2021
            self.opr_register_or_constant2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_movContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_MOV(self):
            return self.getToken(PtxParser.KI_MOV, 0)

        def i_mov_type(self):
            return self.getTypedRuleContext(PtxParser.I_mov_typeContext,0)


        def i_mov_opr(self):
            return self.getTypedRuleContext(PtxParser.I_mov_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_mov

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mov" ):
                listener.enterI_mov(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mov" ):
                listener.exitI_mov(self)




    def i_mov(self):

        localctx = PtxParser.I_movContext(self, self._ctx, self.state)
        self.enterRule(localctx, 414, self.RULE_i_mov)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2023
            self.match(PtxParser.KI_MOV)
            self.state = 2024
            self.i_mov_type()
            self.state = 2025
            self.i_mov_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mov_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PRED(self):
            return self.getToken(PtxParser.K_PRED, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_mov_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mov_type" ):
                listener.enterI_mov_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mov_type" ):
                listener.exitI_mov_type(self)




    def i_mov_type(self):

        localctx = PtxParser.I_mov_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 416, self.RULE_i_mov_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2027
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)) | (1 << (PtxParser.K_PRED - 141)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mov_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_mov_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mov_opr" ):
                listener.enterI_mov_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mov_opr" ):
                listener.exitI_mov_opr(self)




    def i_mov_opr(self):

        localctx = PtxParser.I_mov_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 418, self.RULE_i_mov_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2029
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mulContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_MUL(self):
            return self.getToken(PtxParser.KI_MUL, 0)

        def i_mul_type(self):
            return self.getTypedRuleContext(PtxParser.I_mul_typeContext,0)


        def i_mul_opr(self):
            return self.getTypedRuleContext(PtxParser.I_mul_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_mul

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mul" ):
                listener.enterI_mul(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mul" ):
                listener.exitI_mul(self)




    def i_mul(self):

        localctx = PtxParser.I_mulContext(self, self._ctx, self.state)
        self.enterRule(localctx, 420, self.RULE_i_mul)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2031
            self.match(PtxParser.KI_MUL)
            self.state = 2032
            self.i_mul_type()
            self.state = 2033
            self.i_mul_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mul_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def K_SAT(self):
            return self.getToken(PtxParser.K_SAT, 0)

        def K_HI(self):
            return self.getToken(PtxParser.K_HI, 0)

        def K_LO(self):
            return self.getToken(PtxParser.K_LO, 0)

        def K_WIDE(self):
            return self.getToken(PtxParser.K_WIDE, 0)

        def K_RN(self):
            return self.getToken(PtxParser.K_RN, 0)

        def K_RZ(self):
            return self.getToken(PtxParser.K_RZ, 0)

        def K_RM(self):
            return self.getToken(PtxParser.K_RM, 0)

        def K_RP(self):
            return self.getToken(PtxParser.K_RP, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_mul_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mul_type" ):
                listener.enterI_mul_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mul_type" ):
                listener.exitI_mul_type(self)




    def i_mul_type(self):

        localctx = PtxParser.I_mul_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 422, self.RULE_i_mul_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2053
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,163,self._ctx)
            if la_ == 1:
                self.state = 2036
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_WIDE or _la==PtxParser.K_LO or _la==PtxParser.K_HI:
                    self.state = 2035
                    _la = self._input.LA(1)
                    if not(_la==PtxParser.K_WIDE or _la==PtxParser.K_LO or _la==PtxParser.K_HI):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2038
                _la = self._input.LA(1)
                if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.state = 2040
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0):
                    self.state = 2039
                    _la = self._input.LA(1)
                    if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2043
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 2042
                    self.match(PtxParser.K_FTZ)


                self.state = 2046
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_SAT:
                    self.state = 2045
                    self.match(PtxParser.K_SAT)


                self.state = 2048
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 3:
                self.state = 2050
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0):
                    self.state = 2049
                    _la = self._input.LA(1)
                    if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2052
                self.match(PtxParser.K_F64)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mul_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant2(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_mul_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mul_opr" ):
                listener.enterI_mul_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mul_opr" ):
                listener.exitI_mul_opr(self)




    def i_mul_opr(self):

        localctx = PtxParser.I_mul_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 424, self.RULE_i_mul_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2055
            self.opr_register()
            self.state = 2056
            self.match(PtxParser.T_COMMA)
            self.state = 2057
            self.opr_register_or_constant2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mul24Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_MUL24(self):
            return self.getToken(PtxParser.KI_MUL24, 0)

        def i_mul24_opr(self):
            return self.getTypedRuleContext(PtxParser.I_mul24_oprContext,0)


        def i_mul24_type(self):
            return self.getTypedRuleContext(PtxParser.I_mul24_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_mul24

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mul24" ):
                listener.enterI_mul24(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mul24" ):
                listener.exitI_mul24(self)




    def i_mul24(self):

        localctx = PtxParser.I_mul24Context(self, self._ctx, self.state)
        self.enterRule(localctx, 426, self.RULE_i_mul24)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2059
            self.match(PtxParser.KI_MUL24)

            self.state = 2060
            self.i_mul24_type()
            self.state = 2061
            self.i_mul24_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mul24_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_HI(self):
            return self.getToken(PtxParser.K_HI, 0)

        def K_LO(self):
            return self.getToken(PtxParser.K_LO, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_mul24_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mul24_type" ):
                listener.enterI_mul24_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mul24_type" ):
                listener.exitI_mul24_type(self)




    def i_mul24_type(self):

        localctx = PtxParser.I_mul24_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 428, self.RULE_i_mul24_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2063
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_LO or _la==PtxParser.K_HI):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2064
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_U32 or _la==PtxParser.K_S32):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_mul24_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant2(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_mul24_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_mul24_opr" ):
                listener.enterI_mul24_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_mul24_opr" ):
                listener.exitI_mul24_opr(self)




    def i_mul24_opr(self):

        localctx = PtxParser.I_mul24_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 430, self.RULE_i_mul24_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2066
            self.opr_register()
            self.state = 2067
            self.match(PtxParser.T_COMMA)
            self.state = 2068
            self.opr_register_or_constant2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_negContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_NEG(self):
            return self.getToken(PtxParser.KI_NEG, 0)

        def i_neg_opr(self):
            return self.getTypedRuleContext(PtxParser.I_neg_oprContext,0)


        def i_neg_type(self):
            return self.getTypedRuleContext(PtxParser.I_neg_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_neg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_neg" ):
                listener.enterI_neg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_neg" ):
                listener.exitI_neg(self)




    def i_neg(self):

        localctx = PtxParser.I_negContext(self, self._ctx, self.state)
        self.enterRule(localctx, 432, self.RULE_i_neg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2070
            self.match(PtxParser.KI_NEG)

            self.state = 2071
            self.i_neg_type()
            self.state = 2072
            self.i_neg_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_neg_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_neg_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_neg_type" ):
                listener.enterI_neg_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_neg_type" ):
                listener.exitI_neg_type(self)




    def i_neg_type(self):

        localctx = PtxParser.I_neg_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 434, self.RULE_i_neg_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2080
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16]:
                self.state = 2074
                _la = self._input.LA(1)
                if not(((((_la - 160)) & ~0x3f) == 0 and ((1 << (_la - 160)) & ((1 << (PtxParser.K_S64 - 160)) | (1 << (PtxParser.K_S32 - 160)) | (1 << (PtxParser.K_S16 - 160)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [PtxParser.K_FTZ, PtxParser.K_F32]:
                self.state = 2076
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 2075
                    self.match(PtxParser.K_FTZ)


                self.state = 2078
                self.match(PtxParser.K_F32)
                pass
            elif token in [PtxParser.K_F64]:
                self.state = 2079
                self.match(PtxParser.K_F64)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_neg_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constantContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_neg_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_neg_opr" ):
                listener.enterI_neg_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_neg_opr" ):
                listener.exitI_neg_opr(self)




    def i_neg_opr(self):

        localctx = PtxParser.I_neg_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 436, self.RULE_i_neg_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2082
            self.opr_register()
            self.state = 2083
            self.match(PtxParser.T_COMMA)
            self.state = 2084
            self.opr_register_or_constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_notContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_NOT(self):
            return self.getToken(PtxParser.KI_NOT, 0)

        def i_not_opr(self):
            return self.getTypedRuleContext(PtxParser.I_not_oprContext,0)


        def i_not_type(self):
            return self.getTypedRuleContext(PtxParser.I_not_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_not

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_not" ):
                listener.enterI_not(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_not" ):
                listener.exitI_not(self)




    def i_not(self):

        localctx = PtxParser.I_notContext(self, self._ctx, self.state)
        self.enterRule(localctx, 438, self.RULE_i_not)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2086
            self.match(PtxParser.KI_NOT)

            self.state = 2087
            self.i_not_type()
            self.state = 2088
            self.i_not_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_not_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PRED(self):
            return self.getToken(PtxParser.K_PRED, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_not_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_not_type" ):
                listener.enterI_not_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_not_type" ):
                listener.exitI_not_type(self)




    def i_not_type(self):

        localctx = PtxParser.I_not_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 440, self.RULE_i_not_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2090
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_PRED or ((((_la - 261)) & ~0x3f) == 0 and ((1 << (_la - 261)) & ((1 << (PtxParser.K_B64 - 261)) | (1 << (PtxParser.K_B32 - 261)) | (1 << (PtxParser.K_B16 - 261)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_not_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_not_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_not_opr" ):
                listener.enterI_not_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_not_opr" ):
                listener.exitI_not_opr(self)




    def i_not_opr(self):

        localctx = PtxParser.I_not_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 442, self.RULE_i_not_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2092
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_orContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_OR(self):
            return self.getToken(PtxParser.KI_OR, 0)

        def i_or_opr(self):
            return self.getTypedRuleContext(PtxParser.I_or_oprContext,0)


        def i_or_type(self):
            return self.getTypedRuleContext(PtxParser.I_or_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_or

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_or" ):
                listener.enterI_or(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_or" ):
                listener.exitI_or(self)




    def i_or(self):

        localctx = PtxParser.I_orContext(self, self._ctx, self.state)
        self.enterRule(localctx, 444, self.RULE_i_or)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2094
            self.match(PtxParser.KI_OR)

            self.state = 2095
            self.i_or_type()
            self.state = 2096
            self.i_or_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_or_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PRED(self):
            return self.getToken(PtxParser.K_PRED, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_or_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_or_type" ):
                listener.enterI_or_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_or_type" ):
                listener.exitI_or_type(self)




    def i_or_type(self):

        localctx = PtxParser.I_or_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 446, self.RULE_i_or_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2098
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_PRED or ((((_la - 261)) & ~0x3f) == 0 and ((1 << (_la - 261)) & ((1 << (PtxParser.K_B64 - 261)) | (1 << (PtxParser.K_B32 - 261)) | (1 << (PtxParser.K_B16 - 261)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_or_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr3(self):
            return self.getTypedRuleContext(PtxParser.Opr3Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_or_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_or_opr" ):
                listener.enterI_or_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_or_opr" ):
                listener.exitI_or_opr(self)




    def i_or_opr(self):

        localctx = PtxParser.I_or_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 448, self.RULE_i_or_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2100
            self.opr3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_pmeventContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_PMEVENT(self):
            return self.getToken(PtxParser.KI_PMEVENT, 0)

        def i_pmevent_opr(self):
            return self.getTypedRuleContext(PtxParser.I_pmevent_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_pmevent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_pmevent" ):
                listener.enterI_pmevent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_pmevent" ):
                listener.exitI_pmevent(self)




    def i_pmevent(self):

        localctx = PtxParser.I_pmeventContext(self, self._ctx, self.state)
        self.enterRule(localctx, 450, self.RULE_i_pmevent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2102
            self.match(PtxParser.KI_PMEVENT)
            self.state = 2103
            self.i_pmevent_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_pmevent_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self):
            return self.getTypedRuleContext(PtxParser.OprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_pmevent_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_pmevent_opr" ):
                listener.enterI_pmevent_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_pmevent_opr" ):
                listener.exitI_pmevent_opr(self)




    def i_pmevent_opr(self):

        localctx = PtxParser.I_pmevent_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 452, self.RULE_i_pmevent_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2105
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_popcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_POPC(self):
            return self.getToken(PtxParser.KI_POPC, 0)

        def i_popc_opr(self):
            return self.getTypedRuleContext(PtxParser.I_popc_oprContext,0)


        def i_popc_type(self):
            return self.getTypedRuleContext(PtxParser.I_popc_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_popc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_popc" ):
                listener.enterI_popc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_popc" ):
                listener.exitI_popc(self)




    def i_popc(self):

        localctx = PtxParser.I_popcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 454, self.RULE_i_popc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2107
            self.match(PtxParser.KI_POPC)

            self.state = 2108
            self.i_popc_type()
            self.state = 2109
            self.i_popc_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_popc_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_popc_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_popc_type" ):
                listener.enterI_popc_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_popc_type" ):
                listener.exitI_popc_type(self)




    def i_popc_type(self):

        localctx = PtxParser.I_popc_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 456, self.RULE_i_popc_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2111
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_B64 or _la==PtxParser.K_B32):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_popc_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constantContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_popc_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_popc_opr" ):
                listener.enterI_popc_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_popc_opr" ):
                listener.exitI_popc_opr(self)




    def i_popc_opr(self):

        localctx = PtxParser.I_popc_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 458, self.RULE_i_popc_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2113
            self.opr_register()
            self.state = 2114
            self.match(PtxParser.T_COMMA)
            self.state = 2115
            self.opr_register_or_constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_prefetchContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_PREFETCH(self):
            return self.getToken(PtxParser.KI_PREFETCH, 0)

        def i_prefetch_opr(self):
            return self.getTypedRuleContext(PtxParser.I_prefetch_oprContext,0)


        def i_prefetch_type(self):
            return self.getTypedRuleContext(PtxParser.I_prefetch_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_prefetch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_prefetch" ):
                listener.enterI_prefetch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_prefetch" ):
                listener.exitI_prefetch(self)




    def i_prefetch(self):

        localctx = PtxParser.I_prefetchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 460, self.RULE_i_prefetch)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2117
            self.match(PtxParser.KI_PREFETCH)

            self.state = 2118
            self.i_prefetch_type()
            self.state = 2119
            self.i_prefetch_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_prefetch_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_L1(self):
            return self.getToken(PtxParser.K_L1, 0)

        def K_L2(self):
            return self.getToken(PtxParser.K_L2, 0)

        def K_GLOBAL(self):
            return self.getToken(PtxParser.K_GLOBAL, 0)

        def K_LOCAL(self):
            return self.getToken(PtxParser.K_LOCAL, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_prefetch_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_prefetch_type" ):
                listener.enterI_prefetch_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_prefetch_type" ):
                listener.exitI_prefetch_type(self)




    def i_prefetch_type(self):

        localctx = PtxParser.I_prefetch_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 462, self.RULE_i_prefetch_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2122
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_LOCAL or _la==PtxParser.K_GLOBAL:
                self.state = 2121
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_LOCAL or _la==PtxParser.K_GLOBAL):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 2124
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_L2 or _la==PtxParser.K_L1):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_prefetch_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def opr(self):
            return self.getTypedRuleContext(PtxParser.OprContext,0)


        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_prefetch_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_prefetch_opr" ):
                listener.enterI_prefetch_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_prefetch_opr" ):
                listener.exitI_prefetch_opr(self)




    def i_prefetch_opr(self):

        localctx = PtxParser.I_prefetch_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 464, self.RULE_i_prefetch_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2126
            self.match(PtxParser.T_OB)
            self.state = 2127
            self.opr()
            self.state = 2128
            self.match(PtxParser.T_CB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_prefetchuContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_PREFETCHU(self):
            return self.getToken(PtxParser.KI_PREFETCHU, 0)

        def i_prefetchu_opr(self):
            return self.getTypedRuleContext(PtxParser.I_prefetchu_oprContext,0)


        def i_prefetchu_type(self):
            return self.getTypedRuleContext(PtxParser.I_prefetchu_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_prefetchu

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_prefetchu" ):
                listener.enterI_prefetchu(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_prefetchu" ):
                listener.exitI_prefetchu(self)




    def i_prefetchu(self):

        localctx = PtxParser.I_prefetchuContext(self, self._ctx, self.state)
        self.enterRule(localctx, 466, self.RULE_i_prefetchu)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2130
            self.match(PtxParser.KI_PREFETCHU)

            self.state = 2131
            self.i_prefetchu_type()
            self.state = 2132
            self.i_prefetchu_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_prefetchu_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_L1(self):
            return self.getToken(PtxParser.K_L1, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_prefetchu_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_prefetchu_type" ):
                listener.enterI_prefetchu_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_prefetchu_type" ):
                listener.exitI_prefetchu_type(self)




    def i_prefetchu_type(self):

        localctx = PtxParser.I_prefetchu_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 468, self.RULE_i_prefetchu_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2134
            self.match(PtxParser.K_L1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_prefetchu_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def opr(self):
            return self.getTypedRuleContext(PtxParser.OprContext,0)


        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_prefetchu_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_prefetchu_opr" ):
                listener.enterI_prefetchu_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_prefetchu_opr" ):
                listener.exitI_prefetchu_opr(self)




    def i_prefetchu_opr(self):

        localctx = PtxParser.I_prefetchu_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 470, self.RULE_i_prefetchu_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2136
            self.match(PtxParser.T_OB)
            self.state = 2137
            self.opr()
            self.state = 2138
            self.match(PtxParser.T_CB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_prmtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_PRMT(self):
            return self.getToken(PtxParser.KI_PRMT, 0)

        def i_prmt_type(self):
            return self.getTypedRuleContext(PtxParser.I_prmt_typeContext,0)


        def i_prmt_opr(self):
            return self.getTypedRuleContext(PtxParser.I_prmt_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_prmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_prmt" ):
                listener.enterI_prmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_prmt" ):
                listener.exitI_prmt(self)




    def i_prmt(self):

        localctx = PtxParser.I_prmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 472, self.RULE_i_prmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2140
            self.match(PtxParser.KI_PRMT)
            self.state = 2141
            self.i_prmt_type()
            self.state = 2142
            self.i_prmt_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_prmt_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_F4E(self):
            return self.getToken(PtxParser.K_F4E, 0)

        def K_B4E(self):
            return self.getToken(PtxParser.K_B4E, 0)

        def K_RC8(self):
            return self.getToken(PtxParser.K_RC8, 0)

        def K_ECL(self):
            return self.getToken(PtxParser.K_ECL, 0)

        def K_ECR(self):
            return self.getToken(PtxParser.K_ECR, 0)

        def K_RC16(self):
            return self.getToken(PtxParser.K_RC16, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_prmt_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_prmt_type" ):
                listener.enterI_prmt_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_prmt_type" ):
                listener.exitI_prmt_type(self)




    def i_prmt_type(self):

        localctx = PtxParser.I_prmt_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 474, self.RULE_i_prmt_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2144
            self.match(PtxParser.K_B32)
            self.state = 2146
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 175)) & ~0x3f) == 0 and ((1 << (_la - 175)) & ((1 << (PtxParser.K_RC8 - 175)) | (1 << (PtxParser.K_RC16 - 175)) | (1 << (PtxParser.K_F4E - 175)))) != 0) or ((((_la - 239)) & ~0x3f) == 0 and ((1 << (_la - 239)) & ((1 << (PtxParser.K_ECR - 239)) | (1 << (PtxParser.K_ECL - 239)) | (1 << (PtxParser.K_B4E - 239)))) != 0):
                self.state = 2145
                _la = self._input.LA(1)
                if not(((((_la - 175)) & ~0x3f) == 0 and ((1 << (_la - 175)) & ((1 << (PtxParser.K_RC8 - 175)) | (1 << (PtxParser.K_RC16 - 175)) | (1 << (PtxParser.K_F4E - 175)))) != 0) or ((((_la - 239)) & ~0x3f) == 0 and ((1 << (_la - 239)) & ((1 << (PtxParser.K_ECR - 239)) | (1 << (PtxParser.K_ECL - 239)) | (1 << (PtxParser.K_B4E - 239)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_prmt_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Opr_registerContext)
            else:
                return self.getTypedRuleContext(PtxParser.Opr_registerContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def base_10_integer(self):
            return self.getTypedRuleContext(PtxParser.Base_10_integerContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_prmt_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_prmt_opr" ):
                listener.enterI_prmt_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_prmt_opr" ):
                listener.exitI_prmt_opr(self)




    def i_prmt_opr(self):

        localctx = PtxParser.I_prmt_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 476, self.RULE_i_prmt_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2148
            self.opr_register()
            self.state = 2149
            self.match(PtxParser.T_COMMA)
            self.state = 2150
            self.opr_register()
            self.state = 2151
            self.match(PtxParser.T_COMMA)
            self.state = 2152
            self.opr_register()
            self.state = 2153
            self.match(PtxParser.T_COMMA)
            self.state = 2156
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR, PtxParser.T_WORD]:
                self.state = 2154
                self.opr_register()
                pass
            elif token in [PtxParser.T_DEC_LITERAL]:
                self.state = 2155
                self.base_10_integer()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_rcpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_RCP(self):
            return self.getToken(PtxParser.KI_RCP, 0)

        def i_rcp_opr(self):
            return self.getTypedRuleContext(PtxParser.I_rcp_oprContext,0)


        def i_rcp_type(self):
            return self.getTypedRuleContext(PtxParser.I_rcp_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_rcp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_rcp" ):
                listener.enterI_rcp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_rcp" ):
                listener.exitI_rcp(self)




    def i_rcp(self):

        localctx = PtxParser.I_rcpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 478, self.RULE_i_rcp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2158
            self.match(PtxParser.KI_RCP)

            self.state = 2159
            self.i_rcp_type()
            self.state = 2160
            self.i_rcp_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_rcp_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_APPROX(self):
            return self.getToken(PtxParser.K_APPROX, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_FTZ(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_FTZ)
            else:
                return self.getToken(PtxParser.K_FTZ, i)

        def K_RN(self):
            return self.getToken(PtxParser.K_RN, 0)

        def K_RZ(self):
            return self.getToken(PtxParser.K_RZ, 0)

        def K_RM(self):
            return self.getToken(PtxParser.K_RM, 0)

        def K_RP(self):
            return self.getToken(PtxParser.K_RP, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_rcp_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_rcp_type" ):
                listener.enterI_rcp_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_rcp_type" ):
                listener.exitI_rcp_type(self)




    def i_rcp_type(self):

        localctx = PtxParser.I_rcp_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 480, self.RULE_i_rcp_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2180
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,172,self._ctx)
            if la_ == 1:
                self.state = 2162
                self.match(PtxParser.K_APPROX)
                self.state = 2164
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 2163
                    self.match(PtxParser.K_FTZ)


                self.state = 2166
                self.match(PtxParser.K_F32)
                self.state = 2168
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 2167
                    self.match(PtxParser.K_FTZ)


                pass

            elif la_ == 2:
                self.state = 2170
                _la = self._input.LA(1)
                if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2172
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 2171
                    self.match(PtxParser.K_FTZ)


                self.state = 2174
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 3:
                self.state = 2175
                _la = self._input.LA(1)
                if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2176
                self.match(PtxParser.K_F64)
                pass

            elif la_ == 4:
                self.state = 2177
                self.match(PtxParser.K_APPROX)
                self.state = 2178
                self.match(PtxParser.K_FTZ)
                self.state = 2179
                self.match(PtxParser.K_F64)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_rcp_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_rcp_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_rcp_opr" ):
                listener.enterI_rcp_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_rcp_opr" ):
                listener.exitI_rcp_opr(self)




    def i_rcp_opr(self):

        localctx = PtxParser.I_rcp_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 482, self.RULE_i_rcp_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2182
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_redContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_RED(self):
            return self.getToken(PtxParser.KI_RED, 0)

        def i_red_opr(self):
            return self.getTypedRuleContext(PtxParser.I_red_oprContext,0)


        def i_red_type(self):
            return self.getTypedRuleContext(PtxParser.I_red_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_red

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_red" ):
                listener.enterI_red(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_red" ):
                listener.exitI_red(self)




    def i_red(self):

        localctx = PtxParser.I_redContext(self, self._ctx, self.state)
        self.enterRule(localctx, 484, self.RULE_i_red)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2184
            self.match(PtxParser.KI_RED)

            self.state = 2185
            self.i_red_type()
            self.state = 2186
            self.i_red_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_red_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_AND(self):
            return self.getToken(PtxParser.K_AND, 0)

        def K_OR(self):
            return self.getToken(PtxParser.K_OR, 0)

        def K_XOR(self):
            return self.getToken(PtxParser.K_XOR, 0)

        def K_ADD(self):
            return self.getToken(PtxParser.K_ADD, 0)

        def K_INC(self):
            return self.getToken(PtxParser.K_INC, 0)

        def K_DEC(self):
            return self.getToken(PtxParser.K_DEC, 0)

        def K_MIN(self):
            return self.getToken(PtxParser.K_MIN, 0)

        def K_MAX(self):
            return self.getToken(PtxParser.K_MAX, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_GLOBAL(self):
            return self.getToken(PtxParser.K_GLOBAL, 0)

        def K_SHARED(self):
            return self.getToken(PtxParser.K_SHARED, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_red_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_red_type" ):
                listener.enterI_red_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_red_type" ):
                listener.exitI_red_type(self)




    def i_red_type(self):

        localctx = PtxParser.I_red_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 486, self.RULE_i_red_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2189
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_SHARED or _la==PtxParser.K_GLOBAL:
                self.state = 2188
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_SHARED or _la==PtxParser.K_GLOBAL):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 2191
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_XOR or _la==PtxParser.K_OR or ((((_la - 196)) & ~0x3f) == 0 and ((1 << (_la - 196)) & ((1 << (PtxParser.K_MIN - 196)) | (1 << (PtxParser.K_MAX - 196)) | (1 << (PtxParser.K_INC - 196)) | (1 << (PtxParser.K_DEC - 196)))) != 0) or _la==PtxParser.K_AND or _la==PtxParser.K_ADD):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2192
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_S32 - 141)))) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & ((1 << (PtxParser.K_F32 - 232)) | (1 << (PtxParser.K_B64 - 232)) | (1 << (PtxParser.K_B32 - 232)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_red_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_red_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_red_opr" ):
                listener.enterI_red_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_red_opr" ):
                listener.exitI_red_opr(self)




    def i_red_opr(self):

        localctx = PtxParser.I_red_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 488, self.RULE_i_red_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2194
            self.match(PtxParser.T_OB)
            self.state = 2195
            self.opr()
            self.state = 2196
            self.match(PtxParser.T_CB)
            self.state = 2197
            self.match(PtxParser.T_COMMA)
            self.state = 2198
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_remContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_REM(self):
            return self.getToken(PtxParser.KI_REM, 0)

        def i_rem_opr(self):
            return self.getTypedRuleContext(PtxParser.I_rem_oprContext,0)


        def i_rem_type(self):
            return self.getTypedRuleContext(PtxParser.I_rem_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_rem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_rem" ):
                listener.enterI_rem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_rem" ):
                listener.exitI_rem(self)




    def i_rem(self):

        localctx = PtxParser.I_remContext(self, self._ctx, self.state)
        self.enterRule(localctx, 490, self.RULE_i_rem)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2200
            self.match(PtxParser.KI_REM)

            self.state = 2201
            self.i_rem_type()
            self.state = 2202
            self.i_rem_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_rem_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_rem_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_rem_type" ):
                listener.enterI_rem_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_rem_type" ):
                listener.exitI_rem_type(self)




    def i_rem_type(self):

        localctx = PtxParser.I_rem_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 492, self.RULE_i_rem_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2204
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_rem_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant2(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_rem_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_rem_opr" ):
                listener.enterI_rem_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_rem_opr" ):
                listener.exitI_rem_opr(self)




    def i_rem_opr(self):

        localctx = PtxParser.I_rem_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 494, self.RULE_i_rem_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2206
            self.opr_register()
            self.state = 2207
            self.match(PtxParser.T_COMMA)
            self.state = 2208
            self.opr_register_or_constant2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_retContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_RET(self):
            return self.getToken(PtxParser.KI_RET, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_ret

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_ret" ):
                listener.enterI_ret(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_ret" ):
                listener.exitI_ret(self)




    def i_ret(self):

        localctx = PtxParser.I_retContext(self, self._ctx, self.state)
        self.enterRule(localctx, 496, self.RULE_i_ret)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2210
            self.match(PtxParser.KI_RET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_ret_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_UNI(self):
            return self.getToken(PtxParser.K_UNI, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_ret_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_ret_type" ):
                listener.enterI_ret_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_ret_type" ):
                listener.exitI_ret_type(self)




    def i_ret_type(self):

        localctx = PtxParser.I_ret_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 498, self.RULE_i_ret_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2212
            self.match(PtxParser.K_UNI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_rsqrtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_RSQRT(self):
            return self.getToken(PtxParser.KI_RSQRT, 0)

        def i_rsqrt_opr(self):
            return self.getTypedRuleContext(PtxParser.I_rsqrt_oprContext,0)


        def i_rsqrt_type(self):
            return self.getTypedRuleContext(PtxParser.I_rsqrt_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_rsqrt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_rsqrt" ):
                listener.enterI_rsqrt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_rsqrt" ):
                listener.exitI_rsqrt(self)




    def i_rsqrt(self):

        localctx = PtxParser.I_rsqrtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 500, self.RULE_i_rsqrt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2214
            self.match(PtxParser.KI_RSQRT)

            self.state = 2215
            self.i_rsqrt_type()
            self.state = 2216
            self.i_rsqrt_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_rsqrt_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_APPROX(self):
            return self.getToken(PtxParser.K_APPROX, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_rsqrt_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_rsqrt_type" ):
                listener.enterI_rsqrt_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_rsqrt_type" ):
                listener.exitI_rsqrt_type(self)




    def i_rsqrt_type(self):

        localctx = PtxParser.I_rsqrt_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 502, self.RULE_i_rsqrt_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2225
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,175,self._ctx)
            if la_ == 1:
                self.state = 2218
                self.match(PtxParser.K_APPROX)
                self.state = 2220
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 2219
                    self.match(PtxParser.K_FTZ)


                self.state = 2222
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 2:
                self.state = 2223
                self.match(PtxParser.K_APPROX)
                self.state = 2224
                self.match(PtxParser.K_F64)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_rsqrt_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_rsqrt_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_rsqrt_opr" ):
                listener.enterI_rsqrt_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_rsqrt_opr" ):
                listener.exitI_rsqrt_opr(self)




    def i_rsqrt_opr(self):

        localctx = PtxParser.I_rsqrt_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 504, self.RULE_i_rsqrt_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2227
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SAD(self):
            return self.getToken(PtxParser.KI_SAD, 0)

        def i_sad_opr(self):
            return self.getTypedRuleContext(PtxParser.I_sad_oprContext,0)


        def i_sad_type(self):
            return self.getTypedRuleContext(PtxParser.I_sad_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_sad

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sad" ):
                listener.enterI_sad(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sad" ):
                listener.exitI_sad(self)




    def i_sad(self):

        localctx = PtxParser.I_sadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 506, self.RULE_i_sad)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2229
            self.match(PtxParser.KI_SAD)

            self.state = 2230
            self.i_sad_type()
            self.state = 2231
            self.i_sad_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sad_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_sad_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sad_type" ):
                listener.enterI_sad_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sad_type" ):
                listener.exitI_sad_type(self)




    def i_sad_type(self):

        localctx = PtxParser.I_sad_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 508, self.RULE_i_sad_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2233
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sad_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant3(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant3Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_sad_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sad_opr" ):
                listener.enterI_sad_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sad_opr" ):
                listener.exitI_sad_opr(self)




    def i_sad_opr(self):

        localctx = PtxParser.I_sad_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 510, self.RULE_i_sad_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2235
            self.opr_register()
            self.state = 2236
            self.match(PtxParser.T_COMMA)
            self.state = 2237
            self.opr_register_or_constant3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_selpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SELP(self):
            return self.getToken(PtxParser.KI_SELP, 0)

        def i_selp_opr(self):
            return self.getTypedRuleContext(PtxParser.I_selp_oprContext,0)


        def i_selp_type(self):
            return self.getTypedRuleContext(PtxParser.I_selp_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_selp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_selp" ):
                listener.enterI_selp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_selp" ):
                listener.exitI_selp(self)




    def i_selp(self):

        localctx = PtxParser.I_selpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 512, self.RULE_i_selp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2239
            self.match(PtxParser.KI_SELP)

            self.state = 2240
            self.i_selp_type()
            self.state = 2241
            self.i_selp_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_selp_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_selp_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_selp_type" ):
                listener.enterI_selp_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_selp_type" ):
                listener.exitI_selp_type(self)




    def i_selp_type(self):

        localctx = PtxParser.I_selp_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 514, self.RULE_i_selp_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2243
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_selp_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr4(self):
            return self.getTypedRuleContext(PtxParser.Opr4Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_selp_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_selp_opr" ):
                listener.enterI_selp_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_selp_opr" ):
                listener.exitI_selp_opr(self)




    def i_selp_opr(self):

        localctx = PtxParser.I_selp_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 516, self.RULE_i_selp_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2245
            self.opr4()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_setContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def i_set1(self):
            return self.getTypedRuleContext(PtxParser.I_set1Context,0)


        def i_set2(self):
            return self.getTypedRuleContext(PtxParser.I_set2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_set

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_set" ):
                listener.enterI_set(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_set" ):
                listener.exitI_set(self)




    def i_set(self):

        localctx = PtxParser.I_setContext(self, self._ctx, self.state)
        self.enterRule(localctx, 518, self.RULE_i_set)
        try:
            self.state = 2249
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,176,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2247
                self.i_set1()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2248
                self.i_set2()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_set1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SET(self):
            return self.getToken(PtxParser.KI_SET, 0)

        def i_set1_opr(self):
            return self.getTypedRuleContext(PtxParser.I_set1_oprContext,0)


        def i_set1_type(self):
            return self.getTypedRuleContext(PtxParser.I_set1_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_set1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_set1" ):
                listener.enterI_set1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_set1" ):
                listener.exitI_set1(self)




    def i_set1(self):

        localctx = PtxParser.I_set1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 520, self.RULE_i_set1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2251
            self.match(PtxParser.KI_SET)

            self.state = 2252
            self.i_set1_type()
            self.state = 2253
            self.i_set1_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_set1_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_EQ(self):
            return self.getToken(PtxParser.K_EQ, 0)

        def K_NE(self):
            return self.getToken(PtxParser.K_NE, 0)

        def K_LT(self):
            return self.getToken(PtxParser.K_LT, 0)

        def K_LE(self):
            return self.getToken(PtxParser.K_LE, 0)

        def K_GT(self):
            return self.getToken(PtxParser.K_GT, 0)

        def K_GE(self):
            return self.getToken(PtxParser.K_GE, 0)

        def K_LO(self):
            return self.getToken(PtxParser.K_LO, 0)

        def K_LS(self):
            return self.getToken(PtxParser.K_LS, 0)

        def K_HI(self):
            return self.getToken(PtxParser.K_HI, 0)

        def K_HS(self):
            return self.getToken(PtxParser.K_HS, 0)

        def K_EQU(self):
            return self.getToken(PtxParser.K_EQU, 0)

        def K_NEU(self):
            return self.getToken(PtxParser.K_NEU, 0)

        def K_LTU(self):
            return self.getToken(PtxParser.K_LTU, 0)

        def K_LEU(self):
            return self.getToken(PtxParser.K_LEU, 0)

        def K_GTU(self):
            return self.getToken(PtxParser.K_GTU, 0)

        def K_GEU(self):
            return self.getToken(PtxParser.K_GEU, 0)

        def K_NUM(self):
            return self.getToken(PtxParser.K_NUM, 0)

        def K_NAN(self):
            return self.getToken(PtxParser.K_NAN, 0)

        def K_U32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_U32)
            else:
                return self.getToken(PtxParser.K_U32, i)

        def K_S32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_S32)
            else:
                return self.getToken(PtxParser.K_S32, i)

        def K_F32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_F32)
            else:
                return self.getToken(PtxParser.K_F32, i)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_set1_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_set1_type" ):
                listener.enterI_set1_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_set1_type" ):
                listener.exitI_set1_type(self)




    def i_set1_type(self):

        localctx = PtxParser.I_set1_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 522, self.RULE_i_set1_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2255
            _la = self._input.LA(1)
            if not(((((_la - 185)) & ~0x3f) == 0 and ((1 << (_la - 185)) & ((1 << (PtxParser.K_NUM - 185)) | (1 << (PtxParser.K_NEU - 185)) | (1 << (PtxParser.K_NE - 185)) | (1 << (PtxParser.K_NAN - 185)) | (1 << (PtxParser.K_LTU - 185)) | (1 << (PtxParser.K_LT - 185)) | (1 << (PtxParser.K_LS - 185)) | (1 << (PtxParser.K_LO - 185)) | (1 << (PtxParser.K_LEU - 185)) | (1 << (PtxParser.K_LE - 185)) | (1 << (PtxParser.K_HS - 185)) | (1 << (PtxParser.K_HI - 185)) | (1 << (PtxParser.K_GTU - 185)) | (1 << (PtxParser.K_GT - 185)) | (1 << (PtxParser.K_GEU - 185)) | (1 << (PtxParser.K_GE - 185)) | (1 << (PtxParser.K_EQU - 185)) | (1 << (PtxParser.K_EQ - 185)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_FTZ:
                self.state = 2256
                self.match(PtxParser.K_FTZ)


            self.state = 2259
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_U32 or _la==PtxParser.K_S32 or _la==PtxParser.K_F32):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2260
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_set1_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr3(self):
            return self.getTypedRuleContext(PtxParser.Opr3Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_set1_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_set1_opr" ):
                listener.enterI_set1_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_set1_opr" ):
                listener.exitI_set1_opr(self)




    def i_set1_opr(self):

        localctx = PtxParser.I_set1_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 524, self.RULE_i_set1_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2262
            self.opr3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_set2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SET(self):
            return self.getToken(PtxParser.KI_SET, 0)

        def i_set2_opr(self):
            return self.getTypedRuleContext(PtxParser.I_set2_oprContext,0)


        def i_set2_type(self):
            return self.getTypedRuleContext(PtxParser.I_set2_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_set2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_set2" ):
                listener.enterI_set2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_set2" ):
                listener.exitI_set2(self)




    def i_set2(self):

        localctx = PtxParser.I_set2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 526, self.RULE_i_set2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2264
            self.match(PtxParser.KI_SET)

            self.state = 2265
            self.i_set2_type()
            self.state = 2266
            self.i_set2_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_set2_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_EQ(self):
            return self.getToken(PtxParser.K_EQ, 0)

        def K_NE(self):
            return self.getToken(PtxParser.K_NE, 0)

        def K_LT(self):
            return self.getToken(PtxParser.K_LT, 0)

        def K_LE(self):
            return self.getToken(PtxParser.K_LE, 0)

        def K_GT(self):
            return self.getToken(PtxParser.K_GT, 0)

        def K_GE(self):
            return self.getToken(PtxParser.K_GE, 0)

        def K_LO(self):
            return self.getToken(PtxParser.K_LO, 0)

        def K_LS(self):
            return self.getToken(PtxParser.K_LS, 0)

        def K_HI(self):
            return self.getToken(PtxParser.K_HI, 0)

        def K_HS(self):
            return self.getToken(PtxParser.K_HS, 0)

        def K_EQU(self):
            return self.getToken(PtxParser.K_EQU, 0)

        def K_NEU(self):
            return self.getToken(PtxParser.K_NEU, 0)

        def K_LTU(self):
            return self.getToken(PtxParser.K_LTU, 0)

        def K_LEU(self):
            return self.getToken(PtxParser.K_LEU, 0)

        def K_GTU(self):
            return self.getToken(PtxParser.K_GTU, 0)

        def K_GEU(self):
            return self.getToken(PtxParser.K_GEU, 0)

        def K_NUM(self):
            return self.getToken(PtxParser.K_NUM, 0)

        def K_NAN(self):
            return self.getToken(PtxParser.K_NAN, 0)

        def K_AND(self):
            return self.getToken(PtxParser.K_AND, 0)

        def K_OR(self):
            return self.getToken(PtxParser.K_OR, 0)

        def K_XOR(self):
            return self.getToken(PtxParser.K_XOR, 0)

        def K_U32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_U32)
            else:
                return self.getToken(PtxParser.K_U32, i)

        def K_S32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_S32)
            else:
                return self.getToken(PtxParser.K_S32, i)

        def K_F32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_F32)
            else:
                return self.getToken(PtxParser.K_F32, i)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_set2_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_set2_type" ):
                listener.enterI_set2_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_set2_type" ):
                listener.exitI_set2_type(self)




    def i_set2_type(self):

        localctx = PtxParser.I_set2_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 528, self.RULE_i_set2_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2268
            _la = self._input.LA(1)
            if not(((((_la - 185)) & ~0x3f) == 0 and ((1 << (_la - 185)) & ((1 << (PtxParser.K_NUM - 185)) | (1 << (PtxParser.K_NEU - 185)) | (1 << (PtxParser.K_NE - 185)) | (1 << (PtxParser.K_NAN - 185)) | (1 << (PtxParser.K_LTU - 185)) | (1 << (PtxParser.K_LT - 185)) | (1 << (PtxParser.K_LS - 185)) | (1 << (PtxParser.K_LO - 185)) | (1 << (PtxParser.K_LEU - 185)) | (1 << (PtxParser.K_LE - 185)) | (1 << (PtxParser.K_HS - 185)) | (1 << (PtxParser.K_HI - 185)) | (1 << (PtxParser.K_GTU - 185)) | (1 << (PtxParser.K_GT - 185)) | (1 << (PtxParser.K_GEU - 185)) | (1 << (PtxParser.K_GE - 185)) | (1 << (PtxParser.K_EQU - 185)) | (1 << (PtxParser.K_EQ - 185)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2269
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_XOR or _la==PtxParser.K_OR or _la==PtxParser.K_AND):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_FTZ:
                self.state = 2270
                self.match(PtxParser.K_FTZ)


            self.state = 2273
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_U32 or _la==PtxParser.K_S32 or _la==PtxParser.K_F32):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2274
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_set2_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def T_NOT(self):
            return self.getToken(PtxParser.T_NOT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_set2_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_set2_opr" ):
                listener.enterI_set2_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_set2_opr" ):
                listener.exitI_set2_opr(self)




    def i_set2_opr(self):

        localctx = PtxParser.I_set2_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 530, self.RULE_i_set2_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2276
            self.opr()
            self.state = 2277
            self.match(PtxParser.T_COMMA)
            self.state = 2278
            self.opr()
            self.state = 2279
            self.match(PtxParser.T_COMMA)
            self.state = 2280
            self.opr()
            self.state = 2281
            self.match(PtxParser.T_COMMA)
            self.state = 2283
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,179,self._ctx)
            if la_ == 1:
                self.state = 2282
                self.match(PtxParser.T_NOT)


            self.state = 2285
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_setpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def i_setp1(self):
            return self.getTypedRuleContext(PtxParser.I_setp1Context,0)


        def i_setp2(self):
            return self.getTypedRuleContext(PtxParser.I_setp2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_setp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_setp" ):
                listener.enterI_setp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_setp" ):
                listener.exitI_setp(self)




    def i_setp(self):

        localctx = PtxParser.I_setpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 532, self.RULE_i_setp)
        try:
            self.state = 2289
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,180,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2287
                self.i_setp1()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2288
                self.i_setp2()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_setp1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SETP(self):
            return self.getToken(PtxParser.KI_SETP, 0)

        def i_setp1_opr(self):
            return self.getTypedRuleContext(PtxParser.I_setp1_oprContext,0)


        def i_setp1_type(self):
            return self.getTypedRuleContext(PtxParser.I_setp1_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_setp1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_setp1" ):
                listener.enterI_setp1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_setp1" ):
                listener.exitI_setp1(self)




    def i_setp1(self):

        localctx = PtxParser.I_setp1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 534, self.RULE_i_setp1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2291
            self.match(PtxParser.KI_SETP)

            self.state = 2292
            self.i_setp1_type()
            self.state = 2293
            self.i_setp1_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_setp1_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_EQ(self):
            return self.getToken(PtxParser.K_EQ, 0)

        def K_NE(self):
            return self.getToken(PtxParser.K_NE, 0)

        def K_LT(self):
            return self.getToken(PtxParser.K_LT, 0)

        def K_LE(self):
            return self.getToken(PtxParser.K_LE, 0)

        def K_GT(self):
            return self.getToken(PtxParser.K_GT, 0)

        def K_GE(self):
            return self.getToken(PtxParser.K_GE, 0)

        def K_LO(self):
            return self.getToken(PtxParser.K_LO, 0)

        def K_LS(self):
            return self.getToken(PtxParser.K_LS, 0)

        def K_HI(self):
            return self.getToken(PtxParser.K_HI, 0)

        def K_HS(self):
            return self.getToken(PtxParser.K_HS, 0)

        def K_EQU(self):
            return self.getToken(PtxParser.K_EQU, 0)

        def K_NEU(self):
            return self.getToken(PtxParser.K_NEU, 0)

        def K_LTU(self):
            return self.getToken(PtxParser.K_LTU, 0)

        def K_LEU(self):
            return self.getToken(PtxParser.K_LEU, 0)

        def K_GTU(self):
            return self.getToken(PtxParser.K_GTU, 0)

        def K_GEU(self):
            return self.getToken(PtxParser.K_GEU, 0)

        def K_NUM(self):
            return self.getToken(PtxParser.K_NUM, 0)

        def K_NAN(self):
            return self.getToken(PtxParser.K_NAN, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_setp1_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_setp1_type" ):
                listener.enterI_setp1_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_setp1_type" ):
                listener.exitI_setp1_type(self)




    def i_setp1_type(self):

        localctx = PtxParser.I_setp1_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 536, self.RULE_i_setp1_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2295
            _la = self._input.LA(1)
            if not(((((_la - 185)) & ~0x3f) == 0 and ((1 << (_la - 185)) & ((1 << (PtxParser.K_NUM - 185)) | (1 << (PtxParser.K_NEU - 185)) | (1 << (PtxParser.K_NE - 185)) | (1 << (PtxParser.K_NAN - 185)) | (1 << (PtxParser.K_LTU - 185)) | (1 << (PtxParser.K_LT - 185)) | (1 << (PtxParser.K_LS - 185)) | (1 << (PtxParser.K_LO - 185)) | (1 << (PtxParser.K_LEU - 185)) | (1 << (PtxParser.K_LE - 185)) | (1 << (PtxParser.K_HS - 185)) | (1 << (PtxParser.K_HI - 185)) | (1 << (PtxParser.K_GTU - 185)) | (1 << (PtxParser.K_GT - 185)) | (1 << (PtxParser.K_GEU - 185)) | (1 << (PtxParser.K_GE - 185)) | (1 << (PtxParser.K_EQU - 185)) | (1 << (PtxParser.K_EQ - 185)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2297
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_FTZ:
                self.state = 2296
                self.match(PtxParser.K_FTZ)


            self.state = 2299
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_setp1_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr3(self):
            return self.getTypedRuleContext(PtxParser.Opr3Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_setp1_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_setp1_opr" ):
                listener.enterI_setp1_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_setp1_opr" ):
                listener.exitI_setp1_opr(self)




    def i_setp1_opr(self):

        localctx = PtxParser.I_setp1_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 538, self.RULE_i_setp1_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2301
            self.opr3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_setp2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SETP(self):
            return self.getToken(PtxParser.KI_SETP, 0)

        def i_setp2_opr(self):
            return self.getTypedRuleContext(PtxParser.I_setp2_oprContext,0)


        def i_setp2_type(self):
            return self.getTypedRuleContext(PtxParser.I_setp2_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_setp2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_setp2" ):
                listener.enterI_setp2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_setp2" ):
                listener.exitI_setp2(self)




    def i_setp2(self):

        localctx = PtxParser.I_setp2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 540, self.RULE_i_setp2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2303
            self.match(PtxParser.KI_SETP)

            self.state = 2304
            self.i_setp2_type()
            self.state = 2305
            self.i_setp2_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_setp2_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_EQ(self):
            return self.getToken(PtxParser.K_EQ, 0)

        def K_NE(self):
            return self.getToken(PtxParser.K_NE, 0)

        def K_LT(self):
            return self.getToken(PtxParser.K_LT, 0)

        def K_LE(self):
            return self.getToken(PtxParser.K_LE, 0)

        def K_GT(self):
            return self.getToken(PtxParser.K_GT, 0)

        def K_GE(self):
            return self.getToken(PtxParser.K_GE, 0)

        def K_LO(self):
            return self.getToken(PtxParser.K_LO, 0)

        def K_LS(self):
            return self.getToken(PtxParser.K_LS, 0)

        def K_HI(self):
            return self.getToken(PtxParser.K_HI, 0)

        def K_HS(self):
            return self.getToken(PtxParser.K_HS, 0)

        def K_EQU(self):
            return self.getToken(PtxParser.K_EQU, 0)

        def K_NEU(self):
            return self.getToken(PtxParser.K_NEU, 0)

        def K_LTU(self):
            return self.getToken(PtxParser.K_LTU, 0)

        def K_LEU(self):
            return self.getToken(PtxParser.K_LEU, 0)

        def K_GTU(self):
            return self.getToken(PtxParser.K_GTU, 0)

        def K_GEU(self):
            return self.getToken(PtxParser.K_GEU, 0)

        def K_NUM(self):
            return self.getToken(PtxParser.K_NUM, 0)

        def K_NAN(self):
            return self.getToken(PtxParser.K_NAN, 0)

        def K_AND(self):
            return self.getToken(PtxParser.K_AND, 0)

        def K_OR(self):
            return self.getToken(PtxParser.K_OR, 0)

        def K_XOR(self):
            return self.getToken(PtxParser.K_XOR, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_setp2_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_setp2_type" ):
                listener.enterI_setp2_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_setp2_type" ):
                listener.exitI_setp2_type(self)




    def i_setp2_type(self):

        localctx = PtxParser.I_setp2_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 542, self.RULE_i_setp2_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2307
            _la = self._input.LA(1)
            if not(((((_la - 185)) & ~0x3f) == 0 and ((1 << (_la - 185)) & ((1 << (PtxParser.K_NUM - 185)) | (1 << (PtxParser.K_NEU - 185)) | (1 << (PtxParser.K_NE - 185)) | (1 << (PtxParser.K_NAN - 185)) | (1 << (PtxParser.K_LTU - 185)) | (1 << (PtxParser.K_LT - 185)) | (1 << (PtxParser.K_LS - 185)) | (1 << (PtxParser.K_LO - 185)) | (1 << (PtxParser.K_LEU - 185)) | (1 << (PtxParser.K_LE - 185)) | (1 << (PtxParser.K_HS - 185)) | (1 << (PtxParser.K_HI - 185)) | (1 << (PtxParser.K_GTU - 185)) | (1 << (PtxParser.K_GT - 185)) | (1 << (PtxParser.K_GEU - 185)) | (1 << (PtxParser.K_GE - 185)) | (1 << (PtxParser.K_EQU - 185)) | (1 << (PtxParser.K_EQ - 185)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2308
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_XOR or _la==PtxParser.K_OR or _la==PtxParser.K_AND):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2310
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_FTZ:
                self.state = 2309
                self.match(PtxParser.K_FTZ)


            self.state = 2312
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_setp2_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def T_NOT(self):
            return self.getToken(PtxParser.T_NOT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_setp2_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_setp2_opr" ):
                listener.enterI_setp2_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_setp2_opr" ):
                listener.exitI_setp2_opr(self)




    def i_setp2_opr(self):

        localctx = PtxParser.I_setp2_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 544, self.RULE_i_setp2_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2314
            self.opr()
            self.state = 2315
            self.match(PtxParser.T_COMMA)
            self.state = 2316
            self.opr()
            self.state = 2317
            self.match(PtxParser.T_COMMA)
            self.state = 2318
            self.opr()
            self.state = 2319
            self.match(PtxParser.T_COMMA)
            self.state = 2321
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,183,self._ctx)
            if la_ == 1:
                self.state = 2320
                self.match(PtxParser.T_NOT)


            self.state = 2323
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_shlContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SHL(self):
            return self.getToken(PtxParser.KI_SHL, 0)

        def i_shl_opr(self):
            return self.getTypedRuleContext(PtxParser.I_shl_oprContext,0)


        def i_shl_type(self):
            return self.getTypedRuleContext(PtxParser.I_shl_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_shl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_shl" ):
                listener.enterI_shl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_shl" ):
                listener.exitI_shl(self)




    def i_shl(self):

        localctx = PtxParser.I_shlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 546, self.RULE_i_shl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2325
            self.match(PtxParser.KI_SHL)

            self.state = 2326
            self.i_shl_type()
            self.state = 2327
            self.i_shl_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_shl_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_shl_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_shl_type" ):
                listener.enterI_shl_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_shl_type" ):
                listener.exitI_shl_type(self)




    def i_shl_type(self):

        localctx = PtxParser.I_shl_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 548, self.RULE_i_shl_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2329
            _la = self._input.LA(1)
            if not(((((_la - 261)) & ~0x3f) == 0 and ((1 << (_la - 261)) & ((1 << (PtxParser.K_B64 - 261)) | (1 << (PtxParser.K_B32 - 261)) | (1 << (PtxParser.K_B16 - 261)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_shl_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr3(self):
            return self.getTypedRuleContext(PtxParser.Opr3Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_shl_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_shl_opr" ):
                listener.enterI_shl_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_shl_opr" ):
                listener.exitI_shl_opr(self)




    def i_shl_opr(self):

        localctx = PtxParser.I_shl_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 550, self.RULE_i_shl_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2331
            self.opr3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_shrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SHR(self):
            return self.getToken(PtxParser.KI_SHR, 0)

        def i_shr_type(self):
            return self.getTypedRuleContext(PtxParser.I_shr_typeContext,0)


        def i_shr_opr(self):
            return self.getTypedRuleContext(PtxParser.I_shr_oprContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_shr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_shr" ):
                listener.enterI_shr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_shr" ):
                listener.exitI_shr(self)




    def i_shr(self):

        localctx = PtxParser.I_shrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 552, self.RULE_i_shr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2333
            self.match(PtxParser.KI_SHR)
            self.state = 2334
            self.i_shr_type()
            self.state = 2335
            self.i_shr_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_shr_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_shr_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_shr_type" ):
                listener.enterI_shr_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_shr_type" ):
                listener.exitI_shr_type(self)




    def i_shr_type(self):

        localctx = PtxParser.I_shr_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 554, self.RULE_i_shr_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2337
            _la = self._input.LA(1)
            if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0) or ((((_la - 261)) & ~0x3f) == 0 and ((1 << (_la - 261)) & ((1 << (PtxParser.K_B64 - 261)) | (1 << (PtxParser.K_B32 - 261)) | (1 << (PtxParser.K_B16 - 261)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_shr_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr3(self):
            return self.getTypedRuleContext(PtxParser.Opr3Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_shr_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_shr_opr" ):
                listener.enterI_shr_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_shr_opr" ):
                listener.exitI_shr_opr(self)




    def i_shr_opr(self):

        localctx = PtxParser.I_shr_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 556, self.RULE_i_shr_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2339
            self.opr3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sinContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SIN(self):
            return self.getToken(PtxParser.KI_SIN, 0)

        def i_sin_opr(self):
            return self.getTypedRuleContext(PtxParser.I_sin_oprContext,0)


        def i_sin_type(self):
            return self.getTypedRuleContext(PtxParser.I_sin_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_sin

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sin" ):
                listener.enterI_sin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sin" ):
                listener.exitI_sin(self)




    def i_sin(self):

        localctx = PtxParser.I_sinContext(self, self._ctx, self.state)
        self.enterRule(localctx, 558, self.RULE_i_sin)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2341
            self.match(PtxParser.KI_SIN)

            self.state = 2342
            self.i_sin_type()
            self.state = 2343
            self.i_sin_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sin_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_APPROX(self):
            return self.getToken(PtxParser.K_APPROX, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_sin_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sin_type" ):
                listener.enterI_sin_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sin_type" ):
                listener.exitI_sin_type(self)




    def i_sin_type(self):

        localctx = PtxParser.I_sin_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 560, self.RULE_i_sin_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2345
            self.match(PtxParser.K_APPROX)
            self.state = 2347
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.K_FTZ:
                self.state = 2346
                self.match(PtxParser.K_FTZ)


            self.state = 2349
            self.match(PtxParser.K_F32)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sin_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_sin_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sin_opr" ):
                listener.enterI_sin_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sin_opr" ):
                listener.exitI_sin_opr(self)




    def i_sin_opr(self):

        localctx = PtxParser.I_sin_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 562, self.RULE_i_sin_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2351
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_slctContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SLCT(self):
            return self.getToken(PtxParser.KI_SLCT, 0)

        def i_slct_opr(self):
            return self.getTypedRuleContext(PtxParser.I_slct_oprContext,0)


        def i_slct_type(self):
            return self.getTypedRuleContext(PtxParser.I_slct_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_slct

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_slct" ):
                listener.enterI_slct(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_slct" ):
                listener.exitI_slct(self)




    def i_slct(self):

        localctx = PtxParser.I_slctContext(self, self._ctx, self.state)
        self.enterRule(localctx, 564, self.RULE_i_slct)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2353
            self.match(PtxParser.KI_SLCT)

            self.state = 2354
            self.i_slct_type()
            self.state = 2355
            self.i_slct_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_slct_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_S32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_S32)
            else:
                return self.getToken(PtxParser.K_S32, i)

        def K_F32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_F32)
            else:
                return self.getToken(PtxParser.K_F32, i)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_slct_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_slct_type" ):
                listener.enterI_slct_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_slct_type" ):
                listener.exitI_slct_type(self)




    def i_slct_type(self):

        localctx = PtxParser.I_slct_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 566, self.RULE_i_slct_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2364
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,186,self._ctx)
            if la_ == 1:
                self.state = 2357
                _la = self._input.LA(1)
                if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2358
                self.match(PtxParser.K_S32)
                pass

            elif la_ == 2:
                self.state = 2360
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 2359
                    self.match(PtxParser.K_FTZ)


                self.state = 2362
                _la = self._input.LA(1)
                if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2363
                self.match(PtxParser.K_F32)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_slct_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr4(self):
            return self.getTypedRuleContext(PtxParser.Opr4Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_slct_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_slct_opr" ):
                listener.enterI_slct_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_slct_opr" ):
                listener.exitI_slct_opr(self)




    def i_slct_opr(self):

        localctx = PtxParser.I_slct_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 568, self.RULE_i_slct_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2366
            self.opr4()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sqrtContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SQRT(self):
            return self.getToken(PtxParser.KI_SQRT, 0)

        def i_sqrt_opr(self):
            return self.getTypedRuleContext(PtxParser.I_sqrt_oprContext,0)


        def i_sqrt_type(self):
            return self.getTypedRuleContext(PtxParser.I_sqrt_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_sqrt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sqrt" ):
                listener.enterI_sqrt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sqrt" ):
                listener.exitI_sqrt(self)




    def i_sqrt(self):

        localctx = PtxParser.I_sqrtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 570, self.RULE_i_sqrt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2368
            self.match(PtxParser.KI_SQRT)

            self.state = 2369
            self.i_sqrt_type()
            self.state = 2370
            self.i_sqrt_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sqrt_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_APPROX(self):
            return self.getToken(PtxParser.K_APPROX, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_RN(self):
            return self.getToken(PtxParser.K_RN, 0)

        def K_RZ(self):
            return self.getToken(PtxParser.K_RZ, 0)

        def K_RM(self):
            return self.getToken(PtxParser.K_RM, 0)

        def K_RP(self):
            return self.getToken(PtxParser.K_RP, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_sqrt_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sqrt_type" ):
                listener.enterI_sqrt_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sqrt_type" ):
                listener.exitI_sqrt_type(self)




    def i_sqrt_type(self):

        localctx = PtxParser.I_sqrt_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 572, self.RULE_i_sqrt_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2384
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,189,self._ctx)
            if la_ == 1:
                self.state = 2372
                self.match(PtxParser.K_APPROX)
                self.state = 2374
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 2373
                    self.match(PtxParser.K_FTZ)


                self.state = 2376
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 2:
                self.state = 2377
                _la = self._input.LA(1)
                if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2379
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 2378
                    self.match(PtxParser.K_FTZ)


                self.state = 2381
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 3:
                self.state = 2382
                _la = self._input.LA(1)
                if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2383
                self.match(PtxParser.K_F64)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sqrt_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr2(self):
            return self.getTypedRuleContext(PtxParser.Opr2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_sqrt_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sqrt_opr" ):
                listener.enterI_sqrt_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sqrt_opr" ):
                listener.exitI_sqrt_opr(self)




    def i_sqrt_opr(self):

        localctx = PtxParser.I_sqrt_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 574, self.RULE_i_sqrt_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2386
            self.opr2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_stContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_ST(self):
            return self.getToken(PtxParser.KI_ST, 0)

        def i_st_opr(self):
            return self.getTypedRuleContext(PtxParser.I_st_oprContext,0)


        def i_st_type(self):
            return self.getTypedRuleContext(PtxParser.I_st_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_st

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_st" ):
                listener.enterI_st(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_st" ):
                listener.exitI_st(self)




    def i_st(self):

        localctx = PtxParser.I_stContext(self, self._ctx, self.state)
        self.enterRule(localctx, 576, self.RULE_i_st)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2388
            self.match(PtxParser.KI_ST)

            self.state = 2389
            self.i_st_type()
            self.state = 2390
            self.i_st_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_st_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_VOLATILE(self):
            return self.getToken(PtxParser.K_VOLATILE, 0)

        def K_B8(self):
            return self.getToken(PtxParser.K_B8, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_U8(self):
            return self.getToken(PtxParser.K_U8, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S8(self):
            return self.getToken(PtxParser.K_S8, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_V2(self):
            return self.getToken(PtxParser.K_V2, 0)

        def K_V4(self):
            return self.getToken(PtxParser.K_V4, 0)

        def K_GLOBAL(self):
            return self.getToken(PtxParser.K_GLOBAL, 0)

        def K_LOCAL(self):
            return self.getToken(PtxParser.K_LOCAL, 0)

        def K_SHARED(self):
            return self.getToken(PtxParser.K_SHARED, 0)

        def K_PARAM(self):
            return self.getToken(PtxParser.K_PARAM, 0)

        def K_WB(self):
            return self.getToken(PtxParser.K_WB, 0)

        def K_CG(self):
            return self.getToken(PtxParser.K_CG, 0)

        def K_CS(self):
            return self.getToken(PtxParser.K_CS, 0)

        def K_WT(self):
            return self.getToken(PtxParser.K_WT, 0)

        def K_CONST(self):
            return self.getToken(PtxParser.K_CONST, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_st_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_st_type" ):
                listener.enterI_st_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_st_type" ):
                listener.exitI_st_type(self)




    def i_st_type(self):

        localctx = PtxParser.I_st_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 578, self.RULE_i_st_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2413
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,195,self._ctx)
            if la_ == 1:
                self.state = 2393
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL:
                    self.state = 2392
                    _la = self._input.LA(1)
                    if not(((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2396
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_WT or _la==PtxParser.K_WB or _la==PtxParser.K_CS or _la==PtxParser.K_CG:
                    self.state = 2395
                    _la = self._input.LA(1)
                    if not(_la==PtxParser.K_WT or _la==PtxParser.K_WB or _la==PtxParser.K_CS or _la==PtxParser.K_CG):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2399
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_V4 or _la==PtxParser.K_V2:
                    self.state = 2398
                    _la = self._input.LA(1)
                    if not(_la==PtxParser.K_V4 or _la==PtxParser.K_V2):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2401
                _la = self._input.LA(1)
                if not(((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B8 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.state = 2402
                self.match(PtxParser.K_VOLATILE)
                self.state = 2404
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST:
                    self.state = 2403
                    _la = self._input.LA(1)
                    if not(((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2406
                _la = self._input.LA(1)
                if not(((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B8 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 3:
                self.state = 2407
                self.match(PtxParser.K_VOLATILE)
                self.state = 2409
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST:
                    self.state = 2408
                    _la = self._input.LA(1)
                    if not(((((_la - 155)) & ~0x3f) == 0 and ((1 << (_la - 155)) & ((1 << (PtxParser.K_SHARED - 155)) | (1 << (PtxParser.K_PARAM - 155)) | (1 << (PtxParser.K_LOCAL - 155)))) != 0) or _la==PtxParser.K_GLOBAL or _la==PtxParser.K_CONST):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2411
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_V4 or _la==PtxParser.K_V2):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2412
                _la = self._input.LA(1)
                if not(((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (PtxParser.K_U8 - 140)) | (1 << (PtxParser.K_U64 - 140)) | (1 << (PtxParser.K_U32 - 140)) | (1 << (PtxParser.K_U16 - 140)) | (1 << (PtxParser.K_S8 - 140)) | (1 << (PtxParser.K_S64 - 140)) | (1 << (PtxParser.K_S32 - 140)) | (1 << (PtxParser.K_S16 - 140)))) != 0) or ((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (PtxParser.K_F64 - 230)) | (1 << (PtxParser.K_F32 - 230)) | (1 << (PtxParser.K_B8 - 230)) | (1 << (PtxParser.K_B64 - 230)) | (1 << (PtxParser.K_B32 - 230)) | (1 << (PtxParser.K_B16 - 230)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_st_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_st_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_st_opr" ):
                listener.enterI_st_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_st_opr" ):
                listener.exitI_st_opr(self)




    def i_st_opr(self):

        localctx = PtxParser.I_st_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 580, self.RULE_i_st_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2415
            self.match(PtxParser.T_OB)
            self.state = 2416
            self.opr()
            self.state = 2417
            self.match(PtxParser.T_CB)
            self.state = 2418
            self.match(PtxParser.T_COMMA)
            self.state = 2419
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_subContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SUB(self):
            return self.getToken(PtxParser.KI_SUB, 0)

        def i_sub_opr(self):
            return self.getTypedRuleContext(PtxParser.I_sub_oprContext,0)


        def i_sub_type(self):
            return self.getTypedRuleContext(PtxParser.I_sub_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_sub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sub" ):
                listener.enterI_sub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sub" ):
                listener.exitI_sub(self)




    def i_sub(self):

        localctx = PtxParser.I_subContext(self, self._ctx, self.state)
        self.enterRule(localctx, 582, self.RULE_i_sub)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2421
            self.match(PtxParser.KI_SUB)

            self.state = 2422
            self.i_sub_type()
            self.state = 2423
            self.i_sub_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sub_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def K_CC(self):
            return self.getToken(PtxParser.K_CC, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_FTZ(self):
            return self.getToken(PtxParser.K_FTZ, 0)

        def K_SAT(self):
            return self.getToken(PtxParser.K_SAT, 0)

        def K_RN(self):
            return self.getToken(PtxParser.K_RN, 0)

        def K_RZ(self):
            return self.getToken(PtxParser.K_RZ, 0)

        def K_RM(self):
            return self.getToken(PtxParser.K_RM, 0)

        def K_RP(self):
            return self.getToken(PtxParser.K_RP, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_sub_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sub_type" ):
                listener.enterI_sub_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sub_type" ):
                listener.exitI_sub_type(self)




    def i_sub_type(self):

        localctx = PtxParser.I_sub_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 584, self.RULE_i_sub_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2448
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,202,self._ctx)
            if la_ == 1:
                self.state = 2432
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PtxParser.K_U64, PtxParser.K_U32, PtxParser.K_U16, PtxParser.K_SAT, PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16]:
                    self.state = 2428
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [PtxParser.K_SAT]:
                        self.state = 2425
                        self.match(PtxParser.K_SAT)
                        self.state = 2426
                        self.match(PtxParser.K_S32)
                        pass
                    elif token in [PtxParser.K_U64, PtxParser.K_U32, PtxParser.K_U16, PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16]:
                        self.state = 2427
                        _la = self._input.LA(1)
                        if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass
                elif token in [PtxParser.K_CC]:
                    self.state = 2430
                    self.match(PtxParser.K_CC)
                    self.state = 2431
                    _la = self._input.LA(1)
                    if not(_la==PtxParser.K_U32 or _la==PtxParser.K_S32):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                self.state = 2435
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0):
                    self.state = 2434
                    _la = self._input.LA(1)
                    if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2438
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_FTZ:
                    self.state = 2437
                    self.match(PtxParser.K_FTZ)


                self.state = 2441
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_SAT:
                    self.state = 2440
                    self.match(PtxParser.K_SAT)


                self.state = 2443
                self.match(PtxParser.K_F32)
                pass

            elif la_ == 3:
                self.state = 2445
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0):
                    self.state = 2444
                    _la = self._input.LA(1)
                    if not(((((_la - 164)) & ~0x3f) == 0 and ((1 << (_la - 164)) & ((1 << (PtxParser.K_RZ - 164)) | (1 << (PtxParser.K_RP - 164)) | (1 << (PtxParser.K_RN - 164)) | (1 << (PtxParser.K_RM - 164)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2447
                self.match(PtxParser.K_F64)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sub_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant2(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_sub_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sub_opr" ):
                listener.enterI_sub_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sub_opr" ):
                listener.exitI_sub_opr(self)




    def i_sub_opr(self):

        localctx = PtxParser.I_sub_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 586, self.RULE_i_sub_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2450
            self.opr_register()
            self.state = 2451
            self.match(PtxParser.T_COMMA)
            self.state = 2452
            self.opr_register_or_constant2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_subcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SUBC(self):
            return self.getToken(PtxParser.KI_SUBC, 0)

        def i_subc_opr(self):
            return self.getTypedRuleContext(PtxParser.I_subc_oprContext,0)


        def i_subc_type(self):
            return self.getTypedRuleContext(PtxParser.I_subc_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_subc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_subc" ):
                listener.enterI_subc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_subc" ):
                listener.exitI_subc(self)




    def i_subc(self):

        localctx = PtxParser.I_subcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 588, self.RULE_i_subc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2454
            self.match(PtxParser.KI_SUBC)

            self.state = 2455
            self.i_subc_type()
            self.state = 2456
            self.i_subc_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_subc_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_CC(self):
            return self.getToken(PtxParser.K_CC, 0)

        def K_U16(self):
            return self.getToken(PtxParser.K_U16, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def K_S16(self):
            return self.getToken(PtxParser.K_S16, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_SAT(self):
            return self.getToken(PtxParser.K_SAT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_subc_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_subc_type" ):
                listener.enterI_subc_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_subc_type" ):
                listener.exitI_subc_type(self)




    def i_subc_type(self):

        localctx = PtxParser.I_subc_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 590, self.RULE_i_subc_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2465
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_U64, PtxParser.K_U32, PtxParser.K_U16, PtxParser.K_SAT, PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16]:
                self.state = 2461
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PtxParser.K_SAT]:
                    self.state = 2458
                    self.match(PtxParser.K_SAT)
                    self.state = 2459
                    self.match(PtxParser.K_S32)
                    pass
                elif token in [PtxParser.K_U64, PtxParser.K_U32, PtxParser.K_U16, PtxParser.K_S64, PtxParser.K_S32, PtxParser.K_S16]:
                    self.state = 2460
                    _la = self._input.LA(1)
                    if not(((((_la - 141)) & ~0x3f) == 0 and ((1 << (_la - 141)) & ((1 << (PtxParser.K_U64 - 141)) | (1 << (PtxParser.K_U32 - 141)) | (1 << (PtxParser.K_U16 - 141)) | (1 << (PtxParser.K_S64 - 141)) | (1 << (PtxParser.K_S32 - 141)) | (1 << (PtxParser.K_S16 - 141)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [PtxParser.K_CC]:
                self.state = 2463
                self.match(PtxParser.K_CC)
                self.state = 2464
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_U32 or _la==PtxParser.K_S32):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_subc_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self):
            return self.getTypedRuleContext(PtxParser.Opr_registerContext,0)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def opr_register_or_constant2(self):
            return self.getTypedRuleContext(PtxParser.Opr_register_or_constant2Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_subc_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_subc_opr" ):
                listener.enterI_subc_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_subc_opr" ):
                listener.exitI_subc_opr(self)




    def i_subc_opr(self):

        localctx = PtxParser.I_subc_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 592, self.RULE_i_subc_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2467
            self.opr_register()
            self.state = 2468
            self.match(PtxParser.T_COMMA)
            self.state = 2469
            self.opr_register_or_constant2()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_suldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SULD(self):
            return self.getToken(PtxParser.KI_SULD, 0)

        def i_suld_opr(self):
            return self.getTypedRuleContext(PtxParser.I_suld_oprContext,0)


        def i_suld_type(self):
            return self.getTypedRuleContext(PtxParser.I_suld_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_suld

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_suld" ):
                listener.enterI_suld(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_suld" ):
                listener.exitI_suld(self)




    def i_suld(self):

        localctx = PtxParser.I_suldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 594, self.RULE_i_suld)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2471
            self.match(PtxParser.KI_SULD)

            self.state = 2472
            self.i_suld_type()
            self.state = 2473
            self.i_suld_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_suld_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B(self):
            return self.getToken(PtxParser.K_B, 0)

        def K_P(self):
            return self.getToken(PtxParser.K_P, 0)

        def K_1D(self):
            return self.getToken(PtxParser.K_1D, 0)

        def K_2D(self):
            return self.getToken(PtxParser.K_2D, 0)

        def K_3D(self):
            return self.getToken(PtxParser.K_3D, 0)

        def K_B8(self):
            return self.getToken(PtxParser.K_B8, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_TRAP(self):
            return self.getToken(PtxParser.K_TRAP, 0)

        def K_CLAMP(self):
            return self.getToken(PtxParser.K_CLAMP, 0)

        def K_ZERO(self):
            return self.getToken(PtxParser.K_ZERO, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_CA(self):
            return self.getToken(PtxParser.K_CA, 0)

        def K_CG(self):
            return self.getToken(PtxParser.K_CG, 0)

        def K_CS(self):
            return self.getToken(PtxParser.K_CS, 0)

        def K_CV(self):
            return self.getToken(PtxParser.K_CV, 0)

        def K_V2(self):
            return self.getToken(PtxParser.K_V2, 0)

        def K_V4(self):
            return self.getToken(PtxParser.K_V4, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_suld_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_suld_type" ):
                listener.enterI_suld_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_suld_type" ):
                listener.exitI_suld_type(self)




    def i_suld_type(self):

        localctx = PtxParser.I_suld_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 596, self.RULE_i_suld_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2495
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_B]:
                self.state = 2475
                self.match(PtxParser.K_B)
                self.state = 2476
                _la = self._input.LA(1)
                if not(((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & ((1 << (PtxParser.K_3D - 98)) | (1 << (PtxParser.K_2D - 98)) | (1 << (PtxParser.K_1D - 98)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2478
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & ((1 << (PtxParser.K_CV - 244)) | (1 << (PtxParser.K_CS - 244)) | (1 << (PtxParser.K_CG - 244)) | (1 << (PtxParser.K_CA - 244)))) != 0):
                    self.state = 2477
                    _la = self._input.LA(1)
                    if not(((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & ((1 << (PtxParser.K_CV - 244)) | (1 << (PtxParser.K_CS - 244)) | (1 << (PtxParser.K_CG - 244)) | (1 << (PtxParser.K_CA - 244)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2481
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_V4 or _la==PtxParser.K_V2:
                    self.state = 2480
                    _la = self._input.LA(1)
                    if not(_la==PtxParser.K_V4 or _la==PtxParser.K_V2):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2483
                _la = self._input.LA(1)
                if not(((((_la - 260)) & ~0x3f) == 0 and ((1 << (_la - 260)) & ((1 << (PtxParser.K_B8 - 260)) | (1 << (PtxParser.K_B64 - 260)) | (1 << (PtxParser.K_B32 - 260)) | (1 << (PtxParser.K_B16 - 260)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2484
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_ZERO or _la==PtxParser.K_TRAP or _la==PtxParser.K_CLAMP):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [PtxParser.K_P]:
                self.state = 2485
                self.match(PtxParser.K_P)
                self.state = 2486
                _la = self._input.LA(1)
                if not(((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & ((1 << (PtxParser.K_3D - 98)) | (1 << (PtxParser.K_2D - 98)) | (1 << (PtxParser.K_1D - 98)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2488
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & ((1 << (PtxParser.K_CV - 244)) | (1 << (PtxParser.K_CS - 244)) | (1 << (PtxParser.K_CG - 244)) | (1 << (PtxParser.K_CA - 244)))) != 0):
                    self.state = 2487
                    _la = self._input.LA(1)
                    if not(((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & ((1 << (PtxParser.K_CV - 244)) | (1 << (PtxParser.K_CS - 244)) | (1 << (PtxParser.K_CG - 244)) | (1 << (PtxParser.K_CA - 244)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2491
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_V4 or _la==PtxParser.K_V2:
                    self.state = 2490
                    _la = self._input.LA(1)
                    if not(_la==PtxParser.K_V4 or _la==PtxParser.K_V2):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2493
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_U32 or _la==PtxParser.K_S32 or _la==PtxParser.K_F32 or _la==PtxParser.K_B32):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2494
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_ZERO or _la==PtxParser.K_TRAP or _la==PtxParser.K_CLAMP):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_suld_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_suld_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_suld_opr" ):
                listener.enterI_suld_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_suld_opr" ):
                listener.exitI_suld_opr(self)




    def i_suld_opr(self):

        localctx = PtxParser.I_suld_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 598, self.RULE_i_suld_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2497
            self.opr()
            self.state = 2498
            self.match(PtxParser.T_COMMA)
            self.state = 2499
            self.match(PtxParser.T_OB)
            self.state = 2500
            self.opr()
            self.state = 2501
            self.match(PtxParser.T_COMMA)
            self.state = 2502
            self.opr()
            self.state = 2503
            self.match(PtxParser.T_CB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_suredContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SURED(self):
            return self.getToken(PtxParser.KI_SURED, 0)

        def i_sured_opr(self):
            return self.getTypedRuleContext(PtxParser.I_sured_oprContext,0)


        def i_sured_type(self):
            return self.getTypedRuleContext(PtxParser.I_sured_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_sured

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sured" ):
                listener.enterI_sured(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sured" ):
                listener.exitI_sured(self)




    def i_sured(self):

        localctx = PtxParser.I_suredContext(self, self._ctx, self.state)
        self.enterRule(localctx, 600, self.RULE_i_sured)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2505
            self.match(PtxParser.KI_SURED)

            self.state = 2506
            self.i_sured_type()
            self.state = 2507
            self.i_sured_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sured_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B(self):
            return self.getToken(PtxParser.K_B, 0)

        def K_P(self):
            return self.getToken(PtxParser.K_P, 0)

        def K_1D(self):
            return self.getToken(PtxParser.K_1D, 0)

        def K_2D(self):
            return self.getToken(PtxParser.K_2D, 0)

        def K_3D(self):
            return self.getToken(PtxParser.K_3D, 0)

        def K_B8(self):
            return self.getToken(PtxParser.K_B8, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_TRAP(self):
            return self.getToken(PtxParser.K_TRAP, 0)

        def K_CLAMP(self):
            return self.getToken(PtxParser.K_CLAMP, 0)

        def K_ZERO(self):
            return self.getToken(PtxParser.K_ZERO, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_CA(self):
            return self.getToken(PtxParser.K_CA, 0)

        def K_CG(self):
            return self.getToken(PtxParser.K_CG, 0)

        def K_CS(self):
            return self.getToken(PtxParser.K_CS, 0)

        def K_CV(self):
            return self.getToken(PtxParser.K_CV, 0)

        def K_V2(self):
            return self.getToken(PtxParser.K_V2, 0)

        def K_V4(self):
            return self.getToken(PtxParser.K_V4, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_sured_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sured_type" ):
                listener.enterI_sured_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sured_type" ):
                listener.exitI_sured_type(self)




    def i_sured_type(self):

        localctx = PtxParser.I_sured_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 602, self.RULE_i_sured_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2529
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_B]:
                self.state = 2509
                self.match(PtxParser.K_B)
                self.state = 2510
                _la = self._input.LA(1)
                if not(((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & ((1 << (PtxParser.K_3D - 98)) | (1 << (PtxParser.K_2D - 98)) | (1 << (PtxParser.K_1D - 98)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2512
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & ((1 << (PtxParser.K_CV - 244)) | (1 << (PtxParser.K_CS - 244)) | (1 << (PtxParser.K_CG - 244)) | (1 << (PtxParser.K_CA - 244)))) != 0):
                    self.state = 2511
                    _la = self._input.LA(1)
                    if not(((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & ((1 << (PtxParser.K_CV - 244)) | (1 << (PtxParser.K_CS - 244)) | (1 << (PtxParser.K_CG - 244)) | (1 << (PtxParser.K_CA - 244)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2515
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_V4 or _la==PtxParser.K_V2:
                    self.state = 2514
                    _la = self._input.LA(1)
                    if not(_la==PtxParser.K_V4 or _la==PtxParser.K_V2):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2517
                _la = self._input.LA(1)
                if not(((((_la - 260)) & ~0x3f) == 0 and ((1 << (_la - 260)) & ((1 << (PtxParser.K_B8 - 260)) | (1 << (PtxParser.K_B64 - 260)) | (1 << (PtxParser.K_B32 - 260)) | (1 << (PtxParser.K_B16 - 260)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2518
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_ZERO or _la==PtxParser.K_TRAP or _la==PtxParser.K_CLAMP):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [PtxParser.K_P]:
                self.state = 2519
                self.match(PtxParser.K_P)
                self.state = 2520
                _la = self._input.LA(1)
                if not(((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & ((1 << (PtxParser.K_3D - 98)) | (1 << (PtxParser.K_2D - 98)) | (1 << (PtxParser.K_1D - 98)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2522
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & ((1 << (PtxParser.K_CV - 244)) | (1 << (PtxParser.K_CS - 244)) | (1 << (PtxParser.K_CG - 244)) | (1 << (PtxParser.K_CA - 244)))) != 0):
                    self.state = 2521
                    _la = self._input.LA(1)
                    if not(((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & ((1 << (PtxParser.K_CV - 244)) | (1 << (PtxParser.K_CS - 244)) | (1 << (PtxParser.K_CG - 244)) | (1 << (PtxParser.K_CA - 244)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2525
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_V4 or _la==PtxParser.K_V2:
                    self.state = 2524
                    _la = self._input.LA(1)
                    if not(_la==PtxParser.K_V4 or _la==PtxParser.K_V2):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2527
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_U32 or _la==PtxParser.K_S32 or _la==PtxParser.K_F32 or _la==PtxParser.K_B32):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2528
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_ZERO or _la==PtxParser.K_TRAP or _la==PtxParser.K_CLAMP):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sured_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_sured_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sured_opr" ):
                listener.enterI_sured_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sured_opr" ):
                listener.exitI_sured_opr(self)




    def i_sured_opr(self):

        localctx = PtxParser.I_sured_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 604, self.RULE_i_sured_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2531
            self.match(PtxParser.T_OB)
            self.state = 2532
            self.opr()
            self.state = 2533
            self.match(PtxParser.T_COMMA)
            self.state = 2534
            self.opr()
            self.state = 2535
            self.match(PtxParser.T_CB)
            self.state = 2536
            self.match(PtxParser.T_COMMA)
            self.state = 2537
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sustContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SUST(self):
            return self.getToken(PtxParser.KI_SUST, 0)

        def i_sust_opr(self):
            return self.getTypedRuleContext(PtxParser.I_sust_oprContext,0)


        def i_sust_type(self):
            return self.getTypedRuleContext(PtxParser.I_sust_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_sust

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sust" ):
                listener.enterI_sust(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sust" ):
                listener.exitI_sust(self)




    def i_sust(self):

        localctx = PtxParser.I_sustContext(self, self._ctx, self.state)
        self.enterRule(localctx, 606, self.RULE_i_sust)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2539
            self.match(PtxParser.KI_SUST)

            self.state = 2540
            self.i_sust_type()
            self.state = 2541
            self.i_sust_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sust_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B(self):
            return self.getToken(PtxParser.K_B, 0)

        def K_P(self):
            return self.getToken(PtxParser.K_P, 0)

        def K_1D(self):
            return self.getToken(PtxParser.K_1D, 0)

        def K_2D(self):
            return self.getToken(PtxParser.K_2D, 0)

        def K_3D(self):
            return self.getToken(PtxParser.K_3D, 0)

        def K_B8(self):
            return self.getToken(PtxParser.K_B8, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def K_TRAP(self):
            return self.getToken(PtxParser.K_TRAP, 0)

        def K_CLAMP(self):
            return self.getToken(PtxParser.K_CLAMP, 0)

        def K_ZERO(self):
            return self.getToken(PtxParser.K_ZERO, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_S32(self):
            return self.getToken(PtxParser.K_S32, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_CA(self):
            return self.getToken(PtxParser.K_CA, 0)

        def K_CG(self):
            return self.getToken(PtxParser.K_CG, 0)

        def K_CS(self):
            return self.getToken(PtxParser.K_CS, 0)

        def K_CV(self):
            return self.getToken(PtxParser.K_CV, 0)

        def K_V2(self):
            return self.getToken(PtxParser.K_V2, 0)

        def K_V4(self):
            return self.getToken(PtxParser.K_V4, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_sust_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sust_type" ):
                listener.enterI_sust_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sust_type" ):
                listener.exitI_sust_type(self)




    def i_sust_type(self):

        localctx = PtxParser.I_sust_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 608, self.RULE_i_sust_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2563
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_B]:
                self.state = 2543
                self.match(PtxParser.K_B)
                self.state = 2544
                _la = self._input.LA(1)
                if not(((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & ((1 << (PtxParser.K_3D - 98)) | (1 << (PtxParser.K_2D - 98)) | (1 << (PtxParser.K_1D - 98)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2546
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & ((1 << (PtxParser.K_CV - 244)) | (1 << (PtxParser.K_CS - 244)) | (1 << (PtxParser.K_CG - 244)) | (1 << (PtxParser.K_CA - 244)))) != 0):
                    self.state = 2545
                    _la = self._input.LA(1)
                    if not(((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & ((1 << (PtxParser.K_CV - 244)) | (1 << (PtxParser.K_CS - 244)) | (1 << (PtxParser.K_CG - 244)) | (1 << (PtxParser.K_CA - 244)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2549
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_V4 or _la==PtxParser.K_V2:
                    self.state = 2548
                    _la = self._input.LA(1)
                    if not(_la==PtxParser.K_V4 or _la==PtxParser.K_V2):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2551
                _la = self._input.LA(1)
                if not(((((_la - 260)) & ~0x3f) == 0 and ((1 << (_la - 260)) & ((1 << (PtxParser.K_B8 - 260)) | (1 << (PtxParser.K_B64 - 260)) | (1 << (PtxParser.K_B32 - 260)) | (1 << (PtxParser.K_B16 - 260)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2552
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_ZERO or _la==PtxParser.K_TRAP or _la==PtxParser.K_CLAMP):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [PtxParser.K_P]:
                self.state = 2553
                self.match(PtxParser.K_P)
                self.state = 2554
                _la = self._input.LA(1)
                if not(((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & ((1 << (PtxParser.K_3D - 98)) | (1 << (PtxParser.K_2D - 98)) | (1 << (PtxParser.K_1D - 98)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2556
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & ((1 << (PtxParser.K_CV - 244)) | (1 << (PtxParser.K_CS - 244)) | (1 << (PtxParser.K_CG - 244)) | (1 << (PtxParser.K_CA - 244)))) != 0):
                    self.state = 2555
                    _la = self._input.LA(1)
                    if not(((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & ((1 << (PtxParser.K_CV - 244)) | (1 << (PtxParser.K_CS - 244)) | (1 << (PtxParser.K_CG - 244)) | (1 << (PtxParser.K_CA - 244)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2559
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.K_V4 or _la==PtxParser.K_V2:
                    self.state = 2558
                    _la = self._input.LA(1)
                    if not(_la==PtxParser.K_V4 or _la==PtxParser.K_V2):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2561
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_U32 or _la==PtxParser.K_S32 or _la==PtxParser.K_F32 or _la==PtxParser.K_B32):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2562
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_ZERO or _la==PtxParser.K_TRAP or _la==PtxParser.K_CLAMP):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_sust_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_sust_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_sust_opr" ):
                listener.enterI_sust_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_sust_opr" ):
                listener.exitI_sust_opr(self)




    def i_sust_opr(self):

        localctx = PtxParser.I_sust_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 610, self.RULE_i_sust_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2565
            self.match(PtxParser.T_OB)
            self.state = 2566
            self.opr()
            self.state = 2567
            self.match(PtxParser.T_COMMA)
            self.state = 2568
            self.opr()
            self.state = 2569
            self.match(PtxParser.T_CB)
            self.state = 2570
            self.match(PtxParser.T_COMMA)
            self.state = 2571
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_suqContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_SUQ(self):
            return self.getToken(PtxParser.KI_SUQ, 0)

        def i_suq_opr(self):
            return self.getTypedRuleContext(PtxParser.I_suq_oprContext,0)


        def i_suq_type(self):
            return self.getTypedRuleContext(PtxParser.I_suq_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_suq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_suq" ):
                listener.enterI_suq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_suq" ):
                listener.exitI_suq(self)




    def i_suq(self):

        localctx = PtxParser.I_suqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 612, self.RULE_i_suq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2573
            self.match(PtxParser.KI_SUQ)

            self.state = 2574
            self.i_suq_type()
            self.state = 2575
            self.i_suq_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_suq_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_WIDTH(self):
            return self.getToken(PtxParser.K_WIDTH, 0)

        def K_HEIGHT(self):
            return self.getToken(PtxParser.K_HEIGHT, 0)

        def K_DEPTH(self):
            return self.getToken(PtxParser.K_DEPTH, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_suq_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_suq_type" ):
                listener.enterI_suq_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_suq_type" ):
                listener.exitI_suq_type(self)




    def i_suq_type(self):

        localctx = PtxParser.I_suq_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 614, self.RULE_i_suq_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2577
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_WIDTH or _la==PtxParser.K_HEIGHT or _la==PtxParser.K_DEPTH):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2578
            self.match(PtxParser.K_B32)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_suq_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_suq_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_suq_opr" ):
                listener.enterI_suq_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_suq_opr" ):
                listener.exitI_suq_opr(self)




    def i_suq_opr(self):

        localctx = PtxParser.I_suq_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 616, self.RULE_i_suq_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2580
            self.opr()
            self.state = 2581
            self.match(PtxParser.T_COMMA)
            self.state = 2582
            self.match(PtxParser.T_OB)
            self.state = 2583
            self.opr()
            self.state = 2584
            self.match(PtxParser.T_CB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_testpContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_TESTP(self):
            return self.getToken(PtxParser.KI_TESTP, 0)

        def i_testp_opr(self):
            return self.getTypedRuleContext(PtxParser.I_testp_oprContext,0)


        def i_testp_type(self):
            return self.getTypedRuleContext(PtxParser.I_testp_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_testp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_testp" ):
                listener.enterI_testp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_testp" ):
                listener.exitI_testp(self)




    def i_testp(self):

        localctx = PtxParser.I_testpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 618, self.RULE_i_testp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2586
            self.match(PtxParser.KI_TESTP)

            self.state = 2587
            self.i_testp_type()
            self.state = 2588
            self.i_testp_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_testp_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_FINITE(self):
            return self.getToken(PtxParser.K_FINITE, 0)

        def K_INFINITE(self):
            return self.getToken(PtxParser.K_INFINITE, 0)

        def K_NUMBER(self):
            return self.getToken(PtxParser.K_NUMBER, 0)

        def K_NOTANUMBER(self):
            return self.getToken(PtxParser.K_NOTANUMBER, 0)

        def K_NORMAL(self):
            return self.getToken(PtxParser.K_NORMAL, 0)

        def K_SUBNORMAL(self):
            return self.getToken(PtxParser.K_SUBNORMAL, 0)

        def K_F32(self):
            return self.getToken(PtxParser.K_F32, 0)

        def K_F64(self):
            return self.getToken(PtxParser.K_F64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_testp_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_testp_type" ):
                listener.enterI_testp_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_testp_type" ):
                listener.exitI_testp_type(self)




    def i_testp_type(self):

        localctx = PtxParser.I_testp_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 620, self.RULE_i_testp_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2590
            _la = self._input.LA(1)
            if not(((((_la - 152)) & ~0x3f) == 0 and ((1 << (_la - 152)) & ((1 << (PtxParser.K_SUBNORMAL - 152)) | (1 << (PtxParser.K_NUMBER - 152)) | (1 << (PtxParser.K_NOTANUMBER - 152)) | (1 << (PtxParser.K_NORMAL - 152)) | (1 << (PtxParser.K_INFINITE - 152)))) != 0) or _la==PtxParser.K_FINITE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2591
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_F64 or _la==PtxParser.K_F32):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_testp_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Opr_registerContext)
            else:
                return self.getTypedRuleContext(PtxParser.Opr_registerContext,i)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_testp_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_testp_opr" ):
                listener.enterI_testp_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_testp_opr" ):
                listener.exitI_testp_opr(self)




    def i_testp_opr(self):

        localctx = PtxParser.I_testp_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 622, self.RULE_i_testp_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2593
            self.opr_register()
            self.state = 2594
            self.match(PtxParser.T_COMMA)
            self.state = 2595
            self.opr_register()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_texContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_TEX(self):
            return self.getToken(PtxParser.KI_TEX, 0)

        def i_tex_opr(self):
            return self.getTypedRuleContext(PtxParser.I_tex_oprContext,0)


        def i_tex_type(self):
            return self.getTypedRuleContext(PtxParser.I_tex_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_tex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_tex" ):
                listener.enterI_tex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_tex" ):
                listener.exitI_tex(self)




    def i_tex(self):

        localctx = PtxParser.I_texContext(self, self._ctx, self.state)
        self.enterRule(localctx, 624, self.RULE_i_tex)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2597
            self.match(PtxParser.KI_TEX)

            self.state = 2598
            self.i_tex_type()
            self.state = 2599
            self.i_tex_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_tex_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_V4(self):
            return self.getToken(PtxParser.K_V4, 0)

        def K_1D(self):
            return self.getToken(PtxParser.K_1D, 0)

        def K_2D(self):
            return self.getToken(PtxParser.K_2D, 0)

        def K_3D(self):
            return self.getToken(PtxParser.K_3D, 0)

        def K_U32(self):
            return self.getToken(PtxParser.K_U32, 0)

        def K_S32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_S32)
            else:
                return self.getToken(PtxParser.K_S32, i)

        def K_F32(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.K_F32)
            else:
                return self.getToken(PtxParser.K_F32, i)

        def getRuleIndex(self):
            return PtxParser.RULE_i_tex_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_tex_type" ):
                listener.enterI_tex_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_tex_type" ):
                listener.exitI_tex_type(self)




    def i_tex_type(self):

        localctx = PtxParser.I_tex_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 626, self.RULE_i_tex_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2601
            _la = self._input.LA(1)
            if not(((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & ((1 << (PtxParser.K_3D - 98)) | (1 << (PtxParser.K_2D - 98)) | (1 << (PtxParser.K_1D - 98)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2602
            self.match(PtxParser.K_V4)
            self.state = 2603
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_U32 or _la==PtxParser.K_S32 or _la==PtxParser.K_F32):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2604
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_S32 or _la==PtxParser.K_F32):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_tex_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_tex_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_tex_opr" ):
                listener.enterI_tex_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_tex_opr" ):
                listener.exitI_tex_opr(self)




    def i_tex_opr(self):

        localctx = PtxParser.I_tex_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 628, self.RULE_i_tex_opr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2606
            self.opr()
            self.state = 2607
            self.match(PtxParser.T_COMMA)
            self.state = 2608
            self.match(PtxParser.T_OB)
            self.state = 2609
            self.opr()
            self.state = 2610
            self.match(PtxParser.T_COMMA)
            self.state = 2611
            self.opr()
            self.state = 2614
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_COMMA:
                self.state = 2612
                self.match(PtxParser.T_COMMA)
                self.state = 2613
                self.opr()


            self.state = 2616
            self.match(PtxParser.T_CB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_txqContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_TXQ(self):
            return self.getToken(PtxParser.KI_TXQ, 0)

        def i_txq_opr(self):
            return self.getTypedRuleContext(PtxParser.I_txq_oprContext,0)


        def i_txq_type(self):
            return self.getTypedRuleContext(PtxParser.I_txq_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_txq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_txq" ):
                listener.enterI_txq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_txq" ):
                listener.exitI_txq(self)




    def i_txq(self):

        localctx = PtxParser.I_txqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 630, self.RULE_i_txq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2618
            self.match(PtxParser.KI_TXQ)

            self.state = 2619
            self.i_txq_type()
            self.state = 2620
            self.i_txq_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_txq_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_WIDTH(self):
            return self.getToken(PtxParser.K_WIDTH, 0)

        def K_HEIGHT(self):
            return self.getToken(PtxParser.K_HEIGHT, 0)

        def K_DEPTH(self):
            return self.getToken(PtxParser.K_DEPTH, 0)

        def K_CHANNEL_DATA_TYPE(self):
            return self.getToken(PtxParser.K_CHANNEL_DATA_TYPE, 0)

        def K_CHANNEL_ORDER(self):
            return self.getToken(PtxParser.K_CHANNEL_ORDER, 0)

        def K_NORMALIZED_COORDS(self):
            return self.getToken(PtxParser.K_NORMALIZED_COORDS, 0)

        def K_FILTER_MODE(self):
            return self.getToken(PtxParser.K_FILTER_MODE, 0)

        def K_ADDR_MODE_0(self):
            return self.getToken(PtxParser.K_ADDR_MODE_0, 0)

        def K_ADDR_MODE_1(self):
            return self.getToken(PtxParser.K_ADDR_MODE_1, 0)

        def K_ADDR_MODE_2(self):
            return self.getToken(PtxParser.K_ADDR_MODE_2, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_txq_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_txq_type" ):
                listener.enterI_txq_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_txq_type" ):
                listener.exitI_txq_type(self)




    def i_txq_type(self):

        localctx = PtxParser.I_txq_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 632, self.RULE_i_txq_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2624
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_WIDTH, PtxParser.K_NORMALIZED_COORDS, PtxParser.K_HEIGHT, PtxParser.K_DEPTH, PtxParser.K_CHANNEL_ORDER, PtxParser.K_CHANNEL_DATA_TYPE]:
                self.state = 2622
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_WIDTH or _la==PtxParser.K_NORMALIZED_COORDS or ((((_la - 216)) & ~0x3f) == 0 and ((1 << (_la - 216)) & ((1 << (PtxParser.K_HEIGHT - 216)) | (1 << (PtxParser.K_DEPTH - 216)) | (1 << (PtxParser.K_CHANNEL_ORDER - 216)) | (1 << (PtxParser.K_CHANNEL_DATA_TYPE - 216)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [PtxParser.K_FILTER_MODE, PtxParser.K_ADDR_MODE_2, PtxParser.K_ADDR_MODE_1, PtxParser.K_ADDR_MODE_0]:
                self.state = 2623
                _la = self._input.LA(1)
                if not(((((_la - 228)) & ~0x3f) == 0 and ((1 << (_la - 228)) & ((1 << (PtxParser.K_FILTER_MODE - 228)) | (1 << (PtxParser.K_ADDR_MODE_2 - 228)) | (1 << (PtxParser.K_ADDR_MODE_1 - 228)) | (1 << (PtxParser.K_ADDR_MODE_0 - 228)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2626
            self.match(PtxParser.K_B32)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_txq_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def T_OB(self):
            return self.getToken(PtxParser.T_OB, 0)

        def T_CB(self):
            return self.getToken(PtxParser.T_CB, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_txq_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_txq_opr" ):
                listener.enterI_txq_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_txq_opr" ):
                listener.exitI_txq_opr(self)




    def i_txq_opr(self):

        localctx = PtxParser.I_txq_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 634, self.RULE_i_txq_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2628
            self.opr()
            self.state = 2629
            self.match(PtxParser.T_COMMA)
            self.state = 2630
            self.match(PtxParser.T_OB)
            self.state = 2631
            self.opr()
            self.state = 2632
            self.match(PtxParser.T_CB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_trapContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_TRAP(self):
            return self.getToken(PtxParser.KI_TRAP, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_trap

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_trap" ):
                listener.enterI_trap(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_trap" ):
                listener.exitI_trap(self)




    def i_trap(self):

        localctx = PtxParser.I_trapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 636, self.RULE_i_trap)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2634
            self.match(PtxParser.KI_TRAP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_vabsdiffContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_VABSDIFF(self):
            return self.getToken(PtxParser.KI_VABSDIFF, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_vabsdiff

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_vabsdiff" ):
                listener.enterI_vabsdiff(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_vabsdiff" ):
                listener.exitI_vabsdiff(self)




    def i_vabsdiff(self):

        localctx = PtxParser.I_vabsdiffContext(self, self._ctx, self.state)
        self.enterRule(localctx, 638, self.RULE_i_vabsdiff)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2636
            self.match(PtxParser.KI_VABSDIFF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_vaddContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_VADD(self):
            return self.getToken(PtxParser.KI_VADD, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_vadd

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_vadd" ):
                listener.enterI_vadd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_vadd" ):
                listener.exitI_vadd(self)




    def i_vadd(self):

        localctx = PtxParser.I_vaddContext(self, self._ctx, self.state)
        self.enterRule(localctx, 640, self.RULE_i_vadd)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2638
            self.match(PtxParser.KI_VADD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_vmadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_VMAD(self):
            return self.getToken(PtxParser.KI_VMAD, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_vmad

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_vmad" ):
                listener.enterI_vmad(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_vmad" ):
                listener.exitI_vmad(self)




    def i_vmad(self):

        localctx = PtxParser.I_vmadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 642, self.RULE_i_vmad)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2640
            self.match(PtxParser.KI_VMAD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_vmaxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_VMAX(self):
            return self.getToken(PtxParser.KI_VMAX, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_vmax

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_vmax" ):
                listener.enterI_vmax(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_vmax" ):
                listener.exitI_vmax(self)




    def i_vmax(self):

        localctx = PtxParser.I_vmaxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 644, self.RULE_i_vmax)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2642
            self.match(PtxParser.KI_VMAX)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_vminContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_VMIN(self):
            return self.getToken(PtxParser.KI_VMIN, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_vmin

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_vmin" ):
                listener.enterI_vmin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_vmin" ):
                listener.exitI_vmin(self)




    def i_vmin(self):

        localctx = PtxParser.I_vminContext(self, self._ctx, self.state)
        self.enterRule(localctx, 646, self.RULE_i_vmin)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2644
            self.match(PtxParser.KI_VMIN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_vsetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_VSET(self):
            return self.getToken(PtxParser.KI_VSET, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_vset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_vset" ):
                listener.enterI_vset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_vset" ):
                listener.exitI_vset(self)




    def i_vset(self):

        localctx = PtxParser.I_vsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 648, self.RULE_i_vset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2646
            self.match(PtxParser.KI_VSET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_vshlContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_VSHL(self):
            return self.getToken(PtxParser.KI_VSHL, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_vshl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_vshl" ):
                listener.enterI_vshl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_vshl" ):
                listener.exitI_vshl(self)




    def i_vshl(self):

        localctx = PtxParser.I_vshlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 650, self.RULE_i_vshl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2648
            self.match(PtxParser.KI_VSHL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_vshrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_VSHR(self):
            return self.getToken(PtxParser.KI_VSHR, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_vshr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_vshr" ):
                listener.enterI_vshr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_vshr" ):
                listener.exitI_vshr(self)




    def i_vshr(self):

        localctx = PtxParser.I_vshrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 652, self.RULE_i_vshr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2650
            self.match(PtxParser.KI_VSHR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_vsubContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_VSUB(self):
            return self.getToken(PtxParser.KI_VSUB, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_vsub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_vsub" ):
                listener.enterI_vsub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_vsub" ):
                listener.exitI_vsub(self)




    def i_vsub(self):

        localctx = PtxParser.I_vsubContext(self, self._ctx, self.state)
        self.enterRule(localctx, 654, self.RULE_i_vsub)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2652
            self.match(PtxParser.KI_VSUB)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_voteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_VOTE(self):
            return self.getToken(PtxParser.KI_VOTE, 0)

        def i_vote_opr(self):
            return self.getTypedRuleContext(PtxParser.I_vote_oprContext,0)


        def i_vote_type(self):
            return self.getTypedRuleContext(PtxParser.I_vote_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_vote

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_vote" ):
                listener.enterI_vote(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_vote" ):
                listener.exitI_vote(self)




    def i_vote(self):

        localctx = PtxParser.I_voteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 656, self.RULE_i_vote)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2654
            self.match(PtxParser.KI_VOTE)

            self.state = 2655
            self.i_vote_type()
            self.state = 2656
            self.i_vote_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_vote_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PRED(self):
            return self.getToken(PtxParser.K_PRED, 0)

        def K_BALLOT(self):
            return self.getToken(PtxParser.K_BALLOT, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_ALL(self):
            return self.getToken(PtxParser.K_ALL, 0)

        def K_ANY(self):
            return self.getToken(PtxParser.K_ANY, 0)

        def K_UNI(self):
            return self.getToken(PtxParser.K_UNI, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_vote_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_vote_type" ):
                listener.enterI_vote_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_vote_type" ):
                listener.exitI_vote_type(self)




    def i_vote_type(self):

        localctx = PtxParser.I_vote_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 658, self.RULE_i_vote_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2662
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.K_UNI, PtxParser.K_ANY, PtxParser.K_ALL]:
                self.state = 2658
                _la = self._input.LA(1)
                if not(_la==PtxParser.K_UNI or _la==PtxParser.K_ANY or _la==PtxParser.K_ALL):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2659
                self.match(PtxParser.K_PRED)
                pass
            elif token in [PtxParser.K_BALLOT]:
                self.state = 2660
                self.match(PtxParser.K_BALLOT)
                self.state = 2661
                self.match(PtxParser.K_B32)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_vote_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def T_NOT(self):
            return self.getToken(PtxParser.T_NOT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_vote_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_vote_opr" ):
                listener.enterI_vote_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_vote_opr" ):
                listener.exitI_vote_opr(self)




    def i_vote_opr(self):

        localctx = PtxParser.I_vote_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 660, self.RULE_i_vote_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2664
            self.opr()
            self.state = 2665
            self.match(PtxParser.T_COMMA)
            self.state = 2667
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,223,self._ctx)
            if la_ == 1:
                self.state = 2666
                self.match(PtxParser.T_NOT)


            self.state = 2669
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_xorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KI_XOR(self):
            return self.getToken(PtxParser.KI_XOR, 0)

        def i_xor_opr(self):
            return self.getTypedRuleContext(PtxParser.I_xor_oprContext,0)


        def i_xor_type(self):
            return self.getTypedRuleContext(PtxParser.I_xor_typeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_xor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_xor" ):
                listener.enterI_xor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_xor" ):
                listener.exitI_xor(self)




    def i_xor(self):

        localctx = PtxParser.I_xorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 662, self.RULE_i_xor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2671
            self.match(PtxParser.KI_XOR)

            self.state = 2672
            self.i_xor_type()
            self.state = 2673
            self.i_xor_opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_xor_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def K_PRED(self):
            return self.getToken(PtxParser.K_PRED, 0)

        def K_B16(self):
            return self.getToken(PtxParser.K_B16, 0)

        def K_B32(self):
            return self.getToken(PtxParser.K_B32, 0)

        def K_B64(self):
            return self.getToken(PtxParser.K_B64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_i_xor_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_xor_type" ):
                listener.enterI_xor_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_xor_type" ):
                listener.exitI_xor_type(self)




    def i_xor_type(self):

        localctx = PtxParser.I_xor_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 664, self.RULE_i_xor_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2675
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_PRED or ((((_la - 261)) & ~0x3f) == 0 and ((1 << (_la - 261)) & ((1 << (PtxParser.K_B64 - 261)) | (1 << (PtxParser.K_B32 - 261)) | (1 << (PtxParser.K_B16 - 261)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class I_xor_oprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr3(self):
            return self.getTypedRuleContext(PtxParser.Opr3Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_i_xor_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterI_xor_opr" ):
                listener.enterI_xor_opr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitI_xor_opr" ):
                listener.exitI_xor_opr(self)




    def i_xor_opr(self):

        localctx = PtxParser.I_xor_oprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 666, self.RULE_i_xor_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2677
            self.opr3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opr_registerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def id_or_opcode(self):
            return self.getTypedRuleContext(PtxParser.Id_or_opcodeContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_opr_register

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr_register" ):
                listener.enterOpr_register(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr_register" ):
                listener.exitOpr_register(self)




    def opr_register(self):

        localctx = PtxParser.Opr_registerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 668, self.RULE_opr_register)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2679
            self.id_or_opcode()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opr_register_or_constantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def id_or_opcode(self):
            return self.getTypedRuleContext(PtxParser.Id_or_opcodeContext,0)


        def constant_expression(self):
            return self.getTypedRuleContext(PtxParser.Constant_expressionContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_opr_register_or_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr_register_or_constant" ):
                listener.enterOpr_register_or_constant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr_register_or_constant" ):
                listener.exitOpr_register_or_constant(self)




    def opr_register_or_constant(self):

        localctx = PtxParser.Opr_register_or_constantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 670, self.RULE_opr_register_or_constant)
        try:
            self.state = 2683
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR, PtxParser.T_WORD]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2681
                self.id_or_opcode()
                pass
            elif token in [PtxParser.T_TILDE, PtxParser.T_FLT_LITERAL, PtxParser.T_HEX_LITERAL, PtxParser.T_OCT_LITERAL, PtxParser.T_DEC_LITERAL, PtxParser.T_PLUS, PtxParser.T_OP, PtxParser.T_NOT, PtxParser.T_MINUS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2682
                self.constant_expression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opr_register_or_constant2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register_or_constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Opr_register_or_constantContext)
            else:
                return self.getTypedRuleContext(PtxParser.Opr_register_or_constantContext,i)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_opr_register_or_constant2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr_register_or_constant2" ):
                listener.enterOpr_register_or_constant2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr_register_or_constant2" ):
                listener.exitOpr_register_or_constant2(self)




    def opr_register_or_constant2(self):

        localctx = PtxParser.Opr_register_or_constant2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 672, self.RULE_opr_register_or_constant2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2685
            self.opr_register_or_constant()
            self.state = 2686
            self.match(PtxParser.T_COMMA)
            self.state = 2687
            self.opr_register_or_constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opr_register_or_constant3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register_or_constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Opr_register_or_constantContext)
            else:
                return self.getTypedRuleContext(PtxParser.Opr_register_or_constantContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_opr_register_or_constant3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr_register_or_constant3" ):
                listener.enterOpr_register_or_constant3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr_register_or_constant3" ):
                listener.exitOpr_register_or_constant3(self)




    def opr_register_or_constant3(self):

        localctx = PtxParser.Opr_register_or_constant3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 674, self.RULE_opr_register_or_constant3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2689
            self.opr_register_or_constant()
            self.state = 2690
            self.match(PtxParser.T_COMMA)
            self.state = 2691
            self.opr_register_or_constant()
            self.state = 2692
            self.match(PtxParser.T_COMMA)
            self.state = 2693
            self.opr_register_or_constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opr_register_or_constant4Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register_or_constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Opr_register_or_constantContext)
            else:
                return self.getTypedRuleContext(PtxParser.Opr_register_or_constantContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_opr_register_or_constant4

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr_register_or_constant4" ):
                listener.enterOpr_register_or_constant4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr_register_or_constant4" ):
                listener.exitOpr_register_or_constant4(self)




    def opr_register_or_constant4(self):

        localctx = PtxParser.Opr_register_or_constant4Context(self, self._ctx, self.state)
        self.enterRule(localctx, 676, self.RULE_opr_register_or_constant4)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2695
            self.opr_register_or_constant()
            self.state = 2696
            self.match(PtxParser.T_COMMA)
            self.state = 2697
            self.opr_register_or_constant()
            self.state = 2698
            self.match(PtxParser.T_COMMA)
            self.state = 2699
            self.opr_register_or_constant()
            self.state = 2700
            self.match(PtxParser.T_COMMA)
            self.state = 2701
            self.opr_register_or_constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opr_register_or_constant5Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_register_or_constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Opr_register_or_constantContext)
            else:
                return self.getTypedRuleContext(PtxParser.Opr_register_or_constantContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_opr_register_or_constant5

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr_register_or_constant5" ):
                listener.enterOpr_register_or_constant5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr_register_or_constant5" ):
                listener.exitOpr_register_or_constant5(self)




    def opr_register_or_constant5(self):

        localctx = PtxParser.Opr_register_or_constant5Context(self, self._ctx, self.state)
        self.enterRule(localctx, 678, self.RULE_opr_register_or_constant5)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2703
            self.opr_register_or_constant()
            self.state = 2704
            self.match(PtxParser.T_COMMA)
            self.state = 2705
            self.opr_register_or_constant()
            self.state = 2706
            self.match(PtxParser.T_COMMA)
            self.state = 2707
            self.opr_register_or_constant()
            self.state = 2708
            self.match(PtxParser.T_COMMA)
            self.state = 2709
            self.opr_register_or_constant()
            self.state = 2710
            self.match(PtxParser.T_COMMA)
            self.state = 2711
            self.opr_register_or_constant()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opr_labelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_WORD(self):
            return self.getToken(PtxParser.T_WORD, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_opr_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr_label" ):
                listener.enterOpr_label(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr_label" ):
                listener.exitOpr_label(self)




    def opr_label(self):

        localctx = PtxParser.Opr_labelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 680, self.RULE_opr_label)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2713
            self.match(PtxParser.T_WORD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr_aux(self):
            return self.getTypedRuleContext(PtxParser.Opr_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_opr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr" ):
                listener.enterOpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr" ):
                listener.exitOpr(self)




    def opr(self):

        localctx = PtxParser.OprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 682, self.RULE_opr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2715
            self.opr_aux()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opr_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_UNDERSCORE(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_UNDERSCORE)
            else:
                return self.getToken(PtxParser.T_UNDERSCORE, i)

        def T_OC(self):
            return self.getToken(PtxParser.T_OC, 0)

        def T_CC(self):
            return self.getToken(PtxParser.T_CC, 0)

        def id_or_opcode(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Id_or_opcodeContext)
            else:
                return self.getTypedRuleContext(PtxParser.Id_or_opcodeContext,i)


        def constant_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Constant_expressionContext)
            else:
                return self.getTypedRuleContext(PtxParser.Constant_expressionContext,i)


        def T_PLUS(self):
            return self.getToken(PtxParser.T_PLUS, 0)

        def T_LT(self):
            return self.getToken(PtxParser.T_LT, 0)

        def opr(self):
            return self.getTypedRuleContext(PtxParser.OprContext,0)


        def T_GT(self):
            return self.getToken(PtxParser.T_GT, 0)

        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def K_X(self):
            return self.getToken(PtxParser.K_X, 0)

        def K_Y(self):
            return self.getToken(PtxParser.K_Y, 0)

        def K_Z(self):
            return self.getToken(PtxParser.K_Z, 0)

        def K_W(self):
            return self.getToken(PtxParser.K_W, 0)

        def K_A(self):
            return self.getToken(PtxParser.K_A, 0)

        def K_R(self):
            return self.getToken(PtxParser.K_R, 0)

        def K_G(self):
            return self.getToken(PtxParser.K_G, 0)

        def K_B(self):
            return self.getToken(PtxParser.K_B, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_opr_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr_aux" ):
                listener.enterOpr_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr_aux" ):
                listener.exitOpr_aux(self)




    def opr_aux(self):

        localctx = PtxParser.Opr_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 684, self.RULE_opr_aux)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2751
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR, PtxParser.T_TILDE, PtxParser.T_FLT_LITERAL, PtxParser.T_HEX_LITERAL, PtxParser.T_OCT_LITERAL, PtxParser.T_DEC_LITERAL, PtxParser.T_PLUS, PtxParser.T_OP, PtxParser.T_NOT, PtxParser.T_MINUS, PtxParser.T_WORD]:
                self.state = 2722
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR, PtxParser.T_WORD]:
                    self.state = 2717
                    self.id_or_opcode()
                    self.state = 2719
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if ((((_la - 276)) & ~0x3f) == 0 and ((1 << (_la - 276)) & ((1 << (PtxParser.K_X - 276)) | (1 << (PtxParser.K_Y - 276)) | (1 << (PtxParser.K_Z - 276)) | (1 << (PtxParser.K_W - 276)) | (1 << (PtxParser.K_A - 276)) | (1 << (PtxParser.K_R - 276)) | (1 << (PtxParser.K_G - 276)) | (1 << (PtxParser.K_B - 276)))) != 0):
                        self.state = 2718
                        _la = self._input.LA(1)
                        if not(((((_la - 276)) & ~0x3f) == 0 and ((1 << (_la - 276)) & ((1 << (PtxParser.K_X - 276)) | (1 << (PtxParser.K_Y - 276)) | (1 << (PtxParser.K_Z - 276)) | (1 << (PtxParser.K_W - 276)) | (1 << (PtxParser.K_A - 276)) | (1 << (PtxParser.K_R - 276)) | (1 << (PtxParser.K_G - 276)) | (1 << (PtxParser.K_B - 276)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    pass
                elif token in [PtxParser.T_TILDE, PtxParser.T_FLT_LITERAL, PtxParser.T_HEX_LITERAL, PtxParser.T_OCT_LITERAL, PtxParser.T_DEC_LITERAL, PtxParser.T_PLUS, PtxParser.T_OP, PtxParser.T_NOT, PtxParser.T_MINUS]:
                    self.state = 2721
                    self.constant_expression()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 2726
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,227,self._ctx)
                if la_ == 1:
                    self.state = 2724
                    self.match(PtxParser.T_PLUS)
                    self.state = 2725
                    self.constant_expression()


                self.state = 2732
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==PtxParser.T_LT:
                    self.state = 2728
                    self.match(PtxParser.T_LT)
                    self.state = 2729
                    self.opr()
                    self.state = 2730
                    self.match(PtxParser.T_GT)


                pass
            elif token in [PtxParser.T_OC]:
                self.state = 2734
                self.match(PtxParser.T_OC)
                self.state = 2737
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR, PtxParser.T_WORD]:
                    self.state = 2735
                    self.id_or_opcode()
                    pass
                elif token in [PtxParser.T_UNDERSCORE]:
                    self.state = 2736
                    self.match(PtxParser.T_UNDERSCORE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 2746
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==PtxParser.T_COMMA:
                    self.state = 2739
                    self.match(PtxParser.T_COMMA)
                    self.state = 2742
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [PtxParser.KI_ABS, PtxParser.KI_ADD, PtxParser.KI_ADDC, PtxParser.KI_AND, PtxParser.KI_ATOM, PtxParser.KI_BAR, PtxParser.KI_BFE, PtxParser.KI_BFI, PtxParser.KI_BFIND, PtxParser.KI_BRA, PtxParser.KI_BREV, PtxParser.KI_BRKPT, PtxParser.KI_CALL, PtxParser.KI_CLZ, PtxParser.KI_CNOT, PtxParser.KI_COPYSIGN, PtxParser.KI_COS, PtxParser.KI_CVT, PtxParser.KI_CVTA, PtxParser.KI_DIV, PtxParser.KI_EX2, PtxParser.KI_EXIT, PtxParser.KI_FMA, PtxParser.KI_ISSPACEP, PtxParser.KI_LD, PtxParser.KI_LDU, PtxParser.KI_LG2, PtxParser.KI_MAD24, PtxParser.KI_MAD, PtxParser.KI_MADC, PtxParser.KI_MAX, PtxParser.KI_MEMBAR, PtxParser.KI_MIN, PtxParser.KI_MOV, PtxParser.KI_MUL24, PtxParser.KI_MUL, PtxParser.KI_NEG, PtxParser.KI_NOT, PtxParser.KI_OR, PtxParser.KI_PMEVENT, PtxParser.KI_POPC, PtxParser.KI_PREFETCH, PtxParser.KI_PREFETCHU, PtxParser.KI_PRMT, PtxParser.KI_RCP, PtxParser.KI_RED, PtxParser.KI_REM, PtxParser.KI_RET, PtxParser.KI_RSQRT, PtxParser.KI_SAD, PtxParser.KI_SELP, PtxParser.KI_SETP, PtxParser.KI_SET, PtxParser.KI_SHL, PtxParser.KI_SHR, PtxParser.KI_SIN, PtxParser.KI_SLCT, PtxParser.KI_SQRT, PtxParser.KI_ST, PtxParser.KI_SUB, PtxParser.KI_SUBC, PtxParser.KI_SULD, PtxParser.KI_SUQ, PtxParser.KI_SURED, PtxParser.KI_SUST, PtxParser.KI_TESTP, PtxParser.KI_TEX, PtxParser.KI_TRAP, PtxParser.KI_TXQ, PtxParser.KI_VABSDIFF, PtxParser.KI_VADD, PtxParser.KI_VMAD, PtxParser.KI_VMAX, PtxParser.KI_VMIN, PtxParser.KI_VOTE, PtxParser.KI_VSET, PtxParser.KI_VSHL, PtxParser.KI_VSHR, PtxParser.KI_VSUB, PtxParser.KI_XOR, PtxParser.T_WORD]:
                        self.state = 2740
                        self.id_or_opcode()
                        pass
                    elif token in [PtxParser.T_UNDERSCORE]:
                        self.state = 2741
                        self.match(PtxParser.T_UNDERSCORE)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 2748
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2749
                self.match(PtxParser.T_CC)
                pass
            elif token in [PtxParser.T_UNDERSCORE]:
                self.state = 2750
                self.match(PtxParser.T_UNDERSCORE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opr2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self):
            return self.getToken(PtxParser.T_COMMA, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_opr2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr2" ):
                listener.enterOpr2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr2" ):
                listener.exitOpr2(self)




    def opr2(self):

        localctx = PtxParser.Opr2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 686, self.RULE_opr2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2753
            self.opr()
            self.state = 2754
            self.match(PtxParser.T_COMMA)
            self.state = 2755
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opr3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_opr3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr3" ):
                listener.enterOpr3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr3" ):
                listener.exitOpr3(self)




    def opr3(self):

        localctx = PtxParser.Opr3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 688, self.RULE_opr3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2757
            self.opr()
            self.state = 2758
            self.match(PtxParser.T_COMMA)
            self.state = 2759
            self.opr()
            self.state = 2760
            self.match(PtxParser.T_COMMA)
            self.state = 2761
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opr4Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_opr4

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr4" ):
                listener.enterOpr4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr4" ):
                listener.exitOpr4(self)




    def opr4(self):

        localctx = PtxParser.Opr4Context(self, self._ctx, self.state)
        self.enterRule(localctx, 690, self.RULE_opr4)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2763
            self.opr()
            self.state = 2764
            self.match(PtxParser.T_COMMA)
            self.state = 2765
            self.opr()
            self.state = 2766
            self.match(PtxParser.T_COMMA)
            self.state = 2767
            self.opr()
            self.state = 2768
            self.match(PtxParser.T_COMMA)
            self.state = 2769
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Opr5Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def opr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.OprContext)
            else:
                return self.getTypedRuleContext(PtxParser.OprContext,i)


        def T_COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_COMMA)
            else:
                return self.getToken(PtxParser.T_COMMA, i)

        def getRuleIndex(self):
            return PtxParser.RULE_opr5

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpr5" ):
                listener.enterOpr5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpr5" ):
                listener.exitOpr5(self)




    def opr5(self):

        localctx = PtxParser.Opr5Context(self, self._ctx, self.state)
        self.enterRule(localctx, 692, self.RULE_opr5)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2771
            self.opr()
            self.state = 2772
            self.match(PtxParser.T_COMMA)
            self.state = 2773
            self.opr()
            self.state = 2774
            self.match(PtxParser.T_COMMA)
            self.state = 2775
            self.opr()
            self.state = 2776
            self.match(PtxParser.T_COMMA)
            self.state = 2777
            self.opr()
            self.state = 2778
            self.match(PtxParser.T_COMMA)
            self.state = 2779
            self.opr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constant_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant_expression_aux(self):
            return self.getTypedRuleContext(PtxParser.Constant_expression_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_constant_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant_expression" ):
                listener.enterConstant_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant_expression" ):
                listener.exitConstant_expression(self)




    def constant_expression(self):

        localctx = PtxParser.Constant_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 694, self.RULE_constant_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2781
            self.constant_expression_aux()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Constant_expression_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditional_expression(self):
            return self.getTypedRuleContext(PtxParser.Conditional_expressionContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_constant_expression_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant_expression_aux" ):
                listener.enterConstant_expression_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant_expression_aux" ):
                listener.exitConstant_expression_aux(self)




    def constant_expression_aux(self):

        localctx = PtxParser.Constant_expression_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 696, self.RULE_constant_expression_aux)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2783
            self.conditional_expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Conditional_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditional_or_expression(self):
            return self.getTypedRuleContext(PtxParser.Conditional_or_expressionContext,0)


        def T_QUESTION(self):
            return self.getToken(PtxParser.T_QUESTION, 0)

        def constant_expression_aux(self):
            return self.getTypedRuleContext(PtxParser.Constant_expression_auxContext,0)


        def T_COLON(self):
            return self.getToken(PtxParser.T_COLON, 0)

        def conditional_expression(self):
            return self.getTypedRuleContext(PtxParser.Conditional_expressionContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_conditional_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional_expression" ):
                listener.enterConditional_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional_expression" ):
                listener.exitConditional_expression(self)




    def conditional_expression(self):

        localctx = PtxParser.Conditional_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 698, self.RULE_conditional_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2785
            self.conditional_or_expression()
            self.state = 2791
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PtxParser.T_QUESTION:
                self.state = 2786
                self.match(PtxParser.T_QUESTION)
                self.state = 2787
                self.constant_expression_aux()
                self.state = 2788
                self.match(PtxParser.T_COLON)
                self.state = 2789
                self.conditional_expression()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Conditional_or_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def conditional_and_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Conditional_and_expressionContext)
            else:
                return self.getTypedRuleContext(PtxParser.Conditional_and_expressionContext,i)


        def T_OROR(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_OROR)
            else:
                return self.getToken(PtxParser.T_OROR, i)

        def getRuleIndex(self):
            return PtxParser.RULE_conditional_or_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional_or_expression" ):
                listener.enterConditional_or_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional_or_expression" ):
                listener.exitConditional_or_expression(self)




    def conditional_or_expression(self):

        localctx = PtxParser.Conditional_or_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 700, self.RULE_conditional_or_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2793
            self.conditional_and_expression()
            self.state = 2798
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_OROR:
                self.state = 2794
                self.match(PtxParser.T_OROR)
                self.state = 2795
                self.conditional_and_expression()
                self.state = 2800
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Conditional_and_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def inclusive_or_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Inclusive_or_expressionContext)
            else:
                return self.getTypedRuleContext(PtxParser.Inclusive_or_expressionContext,i)


        def T_ANDAND(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_ANDAND)
            else:
                return self.getToken(PtxParser.T_ANDAND, i)

        def getRuleIndex(self):
            return PtxParser.RULE_conditional_and_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConditional_and_expression" ):
                listener.enterConditional_and_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConditional_and_expression" ):
                listener.exitConditional_and_expression(self)




    def conditional_and_expression(self):

        localctx = PtxParser.Conditional_and_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 702, self.RULE_conditional_and_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2801
            self.inclusive_or_expression()
            self.state = 2806
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_ANDAND:
                self.state = 2802
                self.match(PtxParser.T_ANDAND)
                self.state = 2803
                self.inclusive_or_expression()
                self.state = 2808
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Inclusive_or_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def exclusive_or_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Exclusive_or_expressionContext)
            else:
                return self.getTypedRuleContext(PtxParser.Exclusive_or_expressionContext,i)


        def T_OR(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_OR)
            else:
                return self.getToken(PtxParser.T_OR, i)

        def getRuleIndex(self):
            return PtxParser.RULE_inclusive_or_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInclusive_or_expression" ):
                listener.enterInclusive_or_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInclusive_or_expression" ):
                listener.exitInclusive_or_expression(self)




    def inclusive_or_expression(self):

        localctx = PtxParser.Inclusive_or_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 704, self.RULE_inclusive_or_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2809
            self.exclusive_or_expression()
            self.state = 2814
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_OR:
                self.state = 2810
                self.match(PtxParser.T_OR)
                self.state = 2811
                self.exclusive_or_expression()
                self.state = 2816
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Exclusive_or_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def and_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.And_expressionContext)
            else:
                return self.getTypedRuleContext(PtxParser.And_expressionContext,i)


        def T_XOR(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_XOR)
            else:
                return self.getToken(PtxParser.T_XOR, i)

        def getRuleIndex(self):
            return PtxParser.RULE_exclusive_or_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExclusive_or_expression" ):
                listener.enterExclusive_or_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExclusive_or_expression" ):
                listener.exitExclusive_or_expression(self)




    def exclusive_or_expression(self):

        localctx = PtxParser.Exclusive_or_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 706, self.RULE_exclusive_or_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2817
            self.and_expression()
            self.state = 2822
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_XOR:
                self.state = 2818
                self.match(PtxParser.T_XOR)
                self.state = 2819
                self.and_expression()
                self.state = 2824
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class And_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def equality_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Equality_expressionContext)
            else:
                return self.getTypedRuleContext(PtxParser.Equality_expressionContext,i)


        def T_AND(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_AND)
            else:
                return self.getToken(PtxParser.T_AND, i)

        def getRuleIndex(self):
            return PtxParser.RULE_and_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnd_expression" ):
                listener.enterAnd_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnd_expression" ):
                listener.exitAnd_expression(self)




    def and_expression(self):

        localctx = PtxParser.And_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 708, self.RULE_and_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2825
            self.equality_expression()
            self.state = 2830
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_AND:
                self.state = 2826
                self.match(PtxParser.T_AND)
                self.state = 2827
                self.equality_expression()
                self.state = 2832
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Equality_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relational_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Relational_expressionContext)
            else:
                return self.getTypedRuleContext(PtxParser.Relational_expressionContext,i)


        def T_EQEQ(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_EQEQ)
            else:
                return self.getToken(PtxParser.T_EQEQ, i)

        def T_NOTEQ(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_NOTEQ)
            else:
                return self.getToken(PtxParser.T_NOTEQ, i)

        def getRuleIndex(self):
            return PtxParser.RULE_equality_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEquality_expression" ):
                listener.enterEquality_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEquality_expression" ):
                listener.exitEquality_expression(self)




    def equality_expression(self):

        localctx = PtxParser.Equality_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 710, self.RULE_equality_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2833
            self.relational_expression()
            self.state = 2838
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_EQEQ or _la==PtxParser.T_NOTEQ:
                self.state = 2834
                _la = self._input.LA(1)
                if not(_la==PtxParser.T_EQEQ or _la==PtxParser.T_NOTEQ):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2835
                self.relational_expression()
                self.state = 2840
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Relational_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shift_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Shift_expressionContext)
            else:
                return self.getTypedRuleContext(PtxParser.Shift_expressionContext,i)


        def relational_op(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Relational_opContext)
            else:
                return self.getTypedRuleContext(PtxParser.Relational_opContext,i)


        def getRuleIndex(self):
            return PtxParser.RULE_relational_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelational_expression" ):
                listener.enterRelational_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelational_expression" ):
                listener.exitRelational_expression(self)




    def relational_expression(self):

        localctx = PtxParser.Relational_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 712, self.RULE_relational_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2841
            self.shift_expression()
            self.state = 2847
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,240,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2842
                    self.relational_op()
                    self.state = 2843
                    self.shift_expression() 
                self.state = 2849
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,240,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Relational_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_LE(self):
            return self.getToken(PtxParser.T_LE, 0)

        def T_GE(self):
            return self.getToken(PtxParser.T_GE, 0)

        def T_LT(self):
            return self.getToken(PtxParser.T_LT, 0)

        def T_GT(self):
            return self.getToken(PtxParser.T_GT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_relational_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelational_op" ):
                listener.enterRelational_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelational_op" ):
                listener.exitRelational_op(self)




    def relational_op(self):

        localctx = PtxParser.Relational_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 714, self.RULE_relational_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2850
            _la = self._input.LA(1)
            if not(((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & ((1 << (PtxParser.T_LE - 88)) | (1 << (PtxParser.T_GE - 88)) | (1 << (PtxParser.T_GT - 88)) | (1 << (PtxParser.T_LT - 88)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Shift_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def additive_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Additive_expressionContext)
            else:
                return self.getTypedRuleContext(PtxParser.Additive_expressionContext,i)


        def shift_op(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Shift_opContext)
            else:
                return self.getTypedRuleContext(PtxParser.Shift_opContext,i)


        def getRuleIndex(self):
            return PtxParser.RULE_shift_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShift_expression" ):
                listener.enterShift_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShift_expression" ):
                listener.exitShift_expression(self)




    def shift_expression(self):

        localctx = PtxParser.Shift_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 716, self.RULE_shift_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2852
            self.additive_expression()
            self.state = 2858
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_LTLT or _la==PtxParser.T_GTGT:
                self.state = 2853
                self.shift_op()
                self.state = 2854
                self.additive_expression()
                self.state = 2860
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Shift_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_LTLT(self):
            return self.getToken(PtxParser.T_LTLT, 0)

        def T_GTGT(self):
            return self.getToken(PtxParser.T_GTGT, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_shift_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShift_op" ):
                listener.enterShift_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShift_op" ):
                listener.exitShift_op(self)




    def shift_op(self):

        localctx = PtxParser.Shift_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 718, self.RULE_shift_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2861
            _la = self._input.LA(1)
            if not(_la==PtxParser.T_LTLT or _la==PtxParser.T_GTGT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Additive_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiplicative_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Multiplicative_expressionContext)
            else:
                return self.getTypedRuleContext(PtxParser.Multiplicative_expressionContext,i)


        def T_PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_PLUS)
            else:
                return self.getToken(PtxParser.T_PLUS, i)

        def T_MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_MINUS)
            else:
                return self.getToken(PtxParser.T_MINUS, i)

        def getRuleIndex(self):
            return PtxParser.RULE_additive_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditive_expression" ):
                listener.enterAdditive_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditive_expression" ):
                listener.exitAdditive_expression(self)




    def additive_expression(self):

        localctx = PtxParser.Additive_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 720, self.RULE_additive_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2863
            self.multiplicative_expression()
            self.state = 2868
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,242,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2864
                    _la = self._input.LA(1)
                    if not(_la==PtxParser.T_PLUS or _la==PtxParser.T_MINUS):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 2865
                    self.multiplicative_expression() 
                self.state = 2870
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,242,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multiplicative_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unary_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(PtxParser.Unary_expressionContext)
            else:
                return self.getTypedRuleContext(PtxParser.Unary_expressionContext,i)


        def T_STAR(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_STAR)
            else:
                return self.getToken(PtxParser.T_STAR, i)

        def T_SLASH(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_SLASH)
            else:
                return self.getToken(PtxParser.T_SLASH, i)

        def T_PERCENT(self, i:int=None):
            if i is None:
                return self.getTokens(PtxParser.T_PERCENT)
            else:
                return self.getToken(PtxParser.T_PERCENT, i)

        def getRuleIndex(self):
            return PtxParser.RULE_multiplicative_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicative_expression" ):
                listener.enterMultiplicative_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicative_expression" ):
                listener.exitMultiplicative_expression(self)




    def multiplicative_expression(self):

        localctx = PtxParser.Multiplicative_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 722, self.RULE_multiplicative_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2871
            self.unary_expression()
            self.state = 2876
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PtxParser.T_STAR or _la==PtxParser.T_PERCENT or _la==PtxParser.T_SLASH:
                self.state = 2872
                _la = self._input.LA(1)
                if not(_la==PtxParser.T_STAR or _la==PtxParser.T_PERCENT or _la==PtxParser.T_SLASH):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2873
                self.unary_expression()
                self.state = 2878
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Unary_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_PLUS(self):
            return self.getToken(PtxParser.T_PLUS, 0)

        def unary_expression(self):
            return self.getTypedRuleContext(PtxParser.Unary_expressionContext,0)


        def T_MINUS(self):
            return self.getToken(PtxParser.T_MINUS, 0)

        def unary_expression_not_plus_minus(self):
            return self.getTypedRuleContext(PtxParser.Unary_expression_not_plus_minusContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_unary_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_expression" ):
                listener.enterUnary_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_expression" ):
                listener.exitUnary_expression(self)




    def unary_expression(self):

        localctx = PtxParser.Unary_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 724, self.RULE_unary_expression)
        try:
            self.state = 2884
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.T_PLUS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2879
                self.match(PtxParser.T_PLUS)
                self.state = 2880
                self.unary_expression()
                pass
            elif token in [PtxParser.T_MINUS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2881
                self.match(PtxParser.T_MINUS)
                self.state = 2882
                self.unary_expression()
                pass
            elif token in [PtxParser.T_TILDE, PtxParser.T_FLT_LITERAL, PtxParser.T_HEX_LITERAL, PtxParser.T_OCT_LITERAL, PtxParser.T_DEC_LITERAL, PtxParser.T_OP, PtxParser.T_NOT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2883
                self.unary_expression_not_plus_minus()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Unary_expression_not_plus_minusContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_TILDE(self):
            return self.getToken(PtxParser.T_TILDE, 0)

        def unary_expression(self):
            return self.getTypedRuleContext(PtxParser.Unary_expressionContext,0)


        def T_NOT(self):
            return self.getToken(PtxParser.T_NOT, 0)

        def cast_expression(self):
            return self.getTypedRuleContext(PtxParser.Cast_expressionContext,0)


        def primary(self):
            return self.getTypedRuleContext(PtxParser.PrimaryContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_unary_expression_not_plus_minus

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_expression_not_plus_minus" ):
                listener.enterUnary_expression_not_plus_minus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_expression_not_plus_minus" ):
                listener.exitUnary_expression_not_plus_minus(self)




    def unary_expression_not_plus_minus(self):

        localctx = PtxParser.Unary_expression_not_plus_minusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 726, self.RULE_unary_expression_not_plus_minus)
        try:
            self.state = 2892
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,245,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2886
                self.match(PtxParser.T_TILDE)
                self.state = 2887
                self.unary_expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2888
                self.match(PtxParser.T_NOT)
                self.state = 2889
                self.unary_expression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2890
                self.cast_expression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2891
                self.primary()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Cast_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cast_expression_aux(self):
            return self.getTypedRuleContext(PtxParser.Cast_expression_auxContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_cast_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast_expression" ):
                listener.enterCast_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast_expression" ):
                listener.exitCast_expression(self)




    def cast_expression(self):

        localctx = PtxParser.Cast_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 728, self.RULE_cast_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2894
            self.cast_expression_aux()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Cast_expression_auxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OP(self):
            return self.getToken(PtxParser.T_OP, 0)

        def T_CP(self):
            return self.getToken(PtxParser.T_CP, 0)

        def unary_expression(self):
            return self.getTypedRuleContext(PtxParser.Unary_expressionContext,0)


        def K_S64(self):
            return self.getToken(PtxParser.K_S64, 0)

        def K_U64(self):
            return self.getToken(PtxParser.K_U64, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_cast_expression_aux

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast_expression_aux" ):
                listener.enterCast_expression_aux(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast_expression_aux" ):
                listener.exitCast_expression_aux(self)




    def cast_expression_aux(self):

        localctx = PtxParser.Cast_expression_auxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 730, self.RULE_cast_expression_aux)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2896
            self.match(PtxParser.T_OP)
            self.state = 2897
            _la = self._input.LA(1)
            if not(_la==PtxParser.K_U64 or _la==PtxParser.K_S64):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2898
            self.match(PtxParser.T_CP)
            self.state = 2899
            self.unary_expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PrimaryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def par_expression(self):
            return self.getTypedRuleContext(PtxParser.Par_expressionContext,0)


        def integer(self):
            return self.getTypedRuleContext(PtxParser.IntegerContext,0)


        def float_(self):
            return self.getTypedRuleContext(PtxParser.Float_Context,0)


        def getRuleIndex(self):
            return PtxParser.RULE_primary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimary" ):
                listener.enterPrimary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimary" ):
                listener.exitPrimary(self)




    def primary(self):

        localctx = PtxParser.PrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 732, self.RULE_primary)
        try:
            self.state = 2904
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.T_OP]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2901
                self.par_expression()
                pass
            elif token in [PtxParser.T_HEX_LITERAL, PtxParser.T_OCT_LITERAL, PtxParser.T_DEC_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2902
                self.integer()
                pass
            elif token in [PtxParser.T_FLT_LITERAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2903
                self.float_()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Par_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OP(self):
            return self.getToken(PtxParser.T_OP, 0)

        def constant_expression_aux(self):
            return self.getTypedRuleContext(PtxParser.Constant_expression_auxContext,0)


        def T_CP(self):
            return self.getToken(PtxParser.T_CP, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_par_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_expression" ):
                listener.enterPar_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_expression" ):
                listener.exitPar_expression(self)




    def par_expression(self):

        localctx = PtxParser.Par_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 734, self.RULE_par_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2906
            self.match(PtxParser.T_OP)
            self.state = 2907
            self.constant_expression_aux()
            self.state = 2908
            self.match(PtxParser.T_CP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IntegerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def base_10_integer(self):
            return self.getTypedRuleContext(PtxParser.Base_10_integerContext,0)


        def base_8_integer(self):
            return self.getTypedRuleContext(PtxParser.Base_8_integerContext,0)


        def base_16_integer(self):
            return self.getTypedRuleContext(PtxParser.Base_16_integerContext,0)


        def getRuleIndex(self):
            return PtxParser.RULE_integer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInteger" ):
                listener.enterInteger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInteger" ):
                listener.exitInteger(self)




    def integer(self):

        localctx = PtxParser.IntegerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 736, self.RULE_integer)
        try:
            self.state = 2913
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PtxParser.T_DEC_LITERAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2910
                self.base_10_integer()
                pass
            elif token in [PtxParser.T_OCT_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2911
                self.base_8_integer()
                pass
            elif token in [PtxParser.T_HEX_LITERAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2912
                self.base_16_integer()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Float_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_FLT_LITERAL(self):
            return self.getToken(PtxParser.T_FLT_LITERAL, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_float_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFloat_" ):
                listener.enterFloat_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFloat_" ):
                listener.exitFloat_(self)




    def float_(self):

        localctx = PtxParser.Float_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 738, self.RULE_float_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2915
            self.match(PtxParser.T_FLT_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Base_10_integerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_DEC_LITERAL(self):
            return self.getToken(PtxParser.T_DEC_LITERAL, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_base_10_integer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBase_10_integer" ):
                listener.enterBase_10_integer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBase_10_integer" ):
                listener.exitBase_10_integer(self)




    def base_10_integer(self):

        localctx = PtxParser.Base_10_integerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 740, self.RULE_base_10_integer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2917
            self.match(PtxParser.T_DEC_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Base_8_integerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_OCT_LITERAL(self):
            return self.getToken(PtxParser.T_OCT_LITERAL, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_base_8_integer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBase_8_integer" ):
                listener.enterBase_8_integer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBase_8_integer" ):
                listener.exitBase_8_integer(self)




    def base_8_integer(self):

        localctx = PtxParser.Base_8_integerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 742, self.RULE_base_8_integer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2919
            self.match(PtxParser.T_OCT_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Base_16_integerContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def T_HEX_LITERAL(self):
            return self.getToken(PtxParser.T_HEX_LITERAL, 0)

        def getRuleIndex(self):
            return PtxParser.RULE_base_16_integer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBase_16_integer" ):
                listener.enterBase_16_integer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBase_16_integer" ):
                listener.exitBase_16_integer(self)




    def base_16_integer(self):

        localctx = PtxParser.Base_16_integerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 744, self.RULE_base_16_integer)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2921
            self.match(PtxParser.T_HEX_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





